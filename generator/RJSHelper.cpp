
  // Automatically generated, do not edit
  
          #include "RJSHelper.h"
        
          #include "header_cpp.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qcoreapplication_wrapper.h"
        
          #include "qguiapplication_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qpixmap_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qboxlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qboxlayout_wrapper.h"
        
          #include "qgradient_wrapper.h"
        
          #include "qgradient_wrapper.h"
        
          #include "qgradient_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qiodevicebase_wrapper.h"
        
          #include "qiodevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomcharacterdata_wrapper.h"
        
          #include "qdomcharacterdata_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomcharacterdata_wrapper.h"
        
          #include "qdomtext_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qdropevent_wrapper.h"
        
          #include "qdragmoveevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qdropevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qfiledevice_wrapper.h"
        
          #include "qiodevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qiodevicebase_wrapper.h"
        
          #include "qiodevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
          #include "qabstractfileiconprovider_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qgesture_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qgesture_wrapper.h"
        
          #include "qgesture_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qgraphicseffect_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qgraphicseffect_wrapper.h"
        
          #include "qgraphicseffect_wrapper.h"
        
          #include "qgraphicseffect_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qcoreapplication_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qiodevicebase_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemdelegate_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qlistview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
          #include "qabstractprintdialog_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qpagedpaintdevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qiodevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qqmlengine_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qjsengine_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwindow_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractslider_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractslider_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qabstractproxymodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractspinbox_wrapper.h"
        
          #include "qabstractspinbox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qstringconverterbase_wrapper.h"
        
          #include "qstringconverter_wrapper.h"
        
          #include "qstringconverter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qtableview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qtextedit_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qtextformat_wrapper.h"
        
          #include "qtextformat_wrapper.h"
        
          #include "qtextformat_wrapper.h"
        
          #include "qtextcharformat_wrapper.h"
        
          #include "qtextformat_wrapper.h"
        
          #include "qtextframeformat_wrapper.h"
        
          #include "qtextcharformat_wrapper.h"
        
          #include "qiodevicebase_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qtreeview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qvalidator_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qvalidator_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qvalidator_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qaction_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qsurface_wrapper.h"
        
          #include "qxmlreader_wrapper.h"
        
          #include "qxmlcontenthandler_wrapper.h"
        
          #include "qxmlerrorhandler_wrapper.h"
        
          #include "qxmldtdhandler_wrapper.h"
        
          #include "qxmlentityresolver_wrapper.h"
        
          #include "qxmllexicalhandler_wrapper.h"
        
          #include "qxmldeclhandler_wrapper.h"
        
        QList<RJSDowncaster_QAction*> RJSHelper::downcasters_QAction;
      
        QList<RJSDowncaster_QApplication*> RJSHelper::downcasters_QApplication;
      
        QList<RJSDowncaster_QComboBox*> RJSHelper::downcasters_QComboBox;
      
        QList<RJSDowncaster_QEvent*> RJSHelper::downcasters_QEvent;
      
        QList<RJSDowncaster_QDockWidget*> RJSHelper::downcasters_QDockWidget;
      
        QList<RJSDowncaster_QFileSystemModel*> RJSHelper::downcasters_QFileSystemModel;
      
        QList<RJSDowncaster_QFrame*> RJSHelper::downcasters_QFrame;
      
        QList<RJSDowncaster_QItemDelegate*> RJSHelper::downcasters_QItemDelegate;
      
        QList<RJSDowncaster_QJSEngine*> RJSHelper::downcasters_QJSEngine;
      
        QList<RJSDowncaster_QLayout*> RJSHelper::downcasters_QLayout;
      
        QList<RJSDowncaster_QLineEdit*> RJSHelper::downcasters_QLineEdit;
      
        QList<RJSDowncaster_QListView*> RJSHelper::downcasters_QListView;
      
        QList<RJSDowncaster_QListWidget*> RJSHelper::downcasters_QListWidget;
      
        QList<RJSDowncaster_QMainWindow*> RJSHelper::downcasters_QMainWindow;
      
        QList<RJSDowncaster_QMdiArea*> RJSHelper::downcasters_QMdiArea;
      
        QList<RJSDowncaster_QMdiSubWindow*> RJSHelper::downcasters_QMdiSubWindow;
      
        QList<RJSDowncaster_QObject*> RJSHelper::downcasters_QObject;
      
        QList<RJSDowncaster_QQmlEngine*> RJSHelper::downcasters_QQmlEngine;
      
        QList<RJSDowncaster_QTextBrowser*> RJSHelper::downcasters_QTextBrowser;
      
        QList<RJSDowncaster_QToolBar*> RJSHelper::downcasters_QToolBar;
      
        QList<RJSDowncaster_QToolButton*> RJSHelper::downcasters_QToolButton;
      
        QList<RJSDowncaster_QTreeWidget*> RJSHelper::downcasters_QTreeWidget;
      
        QList<RJSDowncaster_QWidget*> RJSHelper::downcasters_QWidget;
      
        QList<RJSQVariantConverter*> RJSHelper::qvariantConverters;
      
        QString RJSHelper::getTypeName(int type) {
          RJSTypeEnum* t = RJSTypeEnum::getById(type);
          return t->getName();
        }
      
      /**
       * \return existing wrapper object for the given object in the context of the given engine.
       */
      QVariant getWrapperProperty(RJSApi& handler, const QObject& obj) {
          QJSEngine* engine = handler.getEngine();
          return obj.property((const char*)QString("%1__wrapper__").arg(engine->objectName()).toUtf8());
      }

      /**
       * Attaches the script wrapper to the original QObject as a property in the context of the given engine.
       */
      void setWrapperProperty(RJSApi& handler, QObject& obj, const QVariant& wrapper) {
          QJSEngine* engine = handler.getEngine();
          obj.setProperty((const char*)QString("%1__wrapper__").arg(engine->objectName()).toUtf8(), wrapper);
      }

      QJSValue getWrapperQJSValue(const QJSValue& v) {
          if (v.prototype().hasOwnProperty("__WRAPPER__")) {
              return v.prototype();
          }
          else {
              return v;
          }
      }

      QObject* getWrapperQObject(const QJSValue& v) {
          QJSValue w = getWrapperQJSValue(v);
          if (!w.isQObject()) {
              return nullptr;
          }
          return w.toQObject();
      }

      RJSWrapper* getWrapperRJSWrapper(const QJSValue& v) {
          return dynamic_cast<RJSWrapper*>(getWrapperQObject(v));
      }

      //
      // custom types (manual implementation):
      //

      QJSValue RJSHelper::cpp2js_bool(RJSApi& handler, bool v) {
          return QJSValue(v);
      }

      bool RJSHelper::js2cpp_bool(RJSApi& handler, const QJSValue& v) {
          if (!v.isBool() && !v.isNumber()) {
              return false;
          }
          return v.toBool();
      }

      bool RJSHelper::is_bool(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }

          // 20221122: don't allow numbers in test to distinguish between bool / int in function overrides (e.g. RAddObjectsOperation::addObject):
          // || v.isNumber();

          return v.isBool();
      }

      QString RJSHelper::js2cpp_char_ptr(RJSApi& handler, const QJSValue& v) {
          if (v.isNumber() && v.toInt()==0) {
              // JS can pass 0 for null string:
              return QString();
          }

          return v.toString();
      }

      bool RJSHelper::is_char_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          // accept 0 for char pointer (null string):
          return v.isString() || (v.isNumber() && v.toInt()==0);
      }

      QJSValue RJSHelper::cpp2js_char(RJSApi& handler, const char* v) {
          return QJSValue(*v);
      }

      QJSValue RJSHelper::cpp2js_QJSValue(RJSApi& handler, const QJSValue& v) {
          return v;
      }

      QJSValue RJSHelper::cpp2js_QVariant(RJSApi& handler, const QVariant& v) {
          if (v.isNull()) {
              return QJSValue();
          }

          if (v.userType()==QMetaType::QVariantList) {
              // convert QVariant list to QJSValue array:
              QList<QVariant> vList = v.toList();
              QJSEngine* engine = handler.getEngine();
              QJSValue ret = engine->newArray();
              for (int i=0; i<vList.length(); i++) {
                  QVariant vItem = vList[i];
                  ret.setProperty(i, RJSHelper::cpp2js_QVariant(handler, vItem));
              }
              return ret;
          }

          if (v.userType()==QMetaType::QVariantMap) {
              // convert QVariant map to QJSValue object:
              QMap<QString, QVariant> vMap = v.toMap();
              QJSEngine* engine = handler.getEngine();
              QJSValue ret = engine->newObject();
              QList<QString> keys = vMap.keys();
              for (int i=0; i<keys.length(); i++) {
                  QVariant vItem = vMap[keys[i]];
                  ret.setProperty(keys[i], RJSHelper::cpp2js_QVariant(handler, vItem));
              }
              return ret;
          }

          //QVariant_Wrapper* ret = new QVariant_Wrapper(handler, new QVariant(v), true);
          //QVariant* v = ret->getWrapped();
          //if (v!=nullptr) {
              switch (v.userType()) {
              case QMetaType::Bool:
                  return QJSValue(v.toBool());
              case QMetaType::Int:
                  return QJSValue(v.toInt());
      //        case QMetaType::LongLong:
      //            return QJSValue(v.toLongLong());
              case QMetaType::UInt:
                  return QJSValue(v.toUInt());
      //        case QMetaType::ULongLong:
      //            return QJSValue(v.toULongLong());
              case QMetaType::Double:
                  return QJSValue(v.toDouble());
              case QMetaType::QString:
                  return QJSValue(v.toString());

              case QMetaType::QByteArray:
                  return RJSHelper::cpp2js_QByteArray(handler, v.toByteArray());
              case QMetaType::QChar:
                  return RJSHelper::cpp2js_QChar(handler, v.toChar());
              case QMetaType::QDate:
                  return RJSHelper::cpp2js_QDate(handler, v.toDate());
              case QMetaType::QDateTime:
                  return RJSHelper::cpp2js_QDateTime(handler, v.toDateTime());
              case QMetaType::QEasingCurve:
                  return RJSHelper::cpp2js_QEasingCurve(handler, v.toEasingCurve());
      //        case QMetaType::QJsonArray:
      //            return RJSHelper::cpp2js_QJsonArray(handler, v.toJsonArray());
      //        case QMetaType::QJsonDocument:
      //            return RJSHelper::cpp2js_QJsonDocument(handler, v.toJsonDocument());
      //        case QMetaType::QJsonObject:
      //            return RJSHelper::cpp2js_QJsonObject(handler, v.toJsonObject());
      //        case QMetaType::QJsonValue:
      //            return RJSHelper::cpp2js_QJsonValue(handler, v.toJsonValue());
              case QMetaType::QLine:
                  return RJSHelper::cpp2js_QLine(handler, v.toLine());
              case QMetaType::QLineF:
                  return RJSHelper::cpp2js_QLineF(handler, v.toLineF());
      //        case QMetaType::QVariantList:
      //            return RJSHelper::cpp2js_QVariantList(handler, v.toList());
              case QMetaType::QLocale:
                  return RJSHelper::cpp2js_QLocale(handler, v.toLocale());
              case QMetaType::QModelIndex:
                  return RJSHelper::cpp2js_QModelIndex(handler, v.toModelIndex());
      //        case QMetaType::QPersistentModelIndex:
      //            return RJSHelper::cpp2js_QPersistentModelIndex(handler, v.toPersistentModelIndex());
              case QMetaType::QPoint:
                  return RJSHelper::cpp2js_QPoint(handler, v.toPoint());
              case QMetaType::QPointF:
                  return RJSHelper::cpp2js_QPointF(handler, v.toPointF());
              case QMetaType::QRect:
                  return RJSHelper::cpp2js_QRect(handler, v.toRect());
              case QMetaType::QRectF:
                  return RJSHelper::cpp2js_QRectF(handler, v.toRectF());
              case QMetaType::QRegularExpression:
                  return RJSHelper::cpp2js_QRegularExpression(handler, v.toRegularExpression());
              case QMetaType::QSize:
                  return RJSHelper::cpp2js_QSize(handler, v.toSize());
              case QMetaType::QSizeF:
                  return RJSHelper::cpp2js_QSizeF(handler, v.toSizeF());
              case QMetaType::QTime:
                  return RJSHelper::cpp2js_QTime(handler, v.toTime());
              case QMetaType::QUrl:
                  return RJSHelper::cpp2js_QUrl(handler, v.toUrl());
              case QMetaType::QColor:
                  return RJSHelper::cpp2js_QColor(handler, v.value<QColor>());
              case QMetaType::QPalette:
                  return RJSHelper::cpp2js_QPalette(handler, v.value<QPalette>());
      //        case QMetaType::QUuid:
      //            return RJSHelper::cpp2js_QUuid(handler, v.toUuid());

              // TODO: add more conversions:
              default:
                  break;
              }
          //}

          if (v.canConvert<QFont>()) {
              return RJSHelper::cpp2js_QFont(handler, v.value<QFont>());
          }

          if (v.canConvert<QPushButton*>()) {
              return RJSHelper::cpp2js_QPushButton(handler, v.value<QPushButton*>());
          }

          if (v.canConvert<QList<double> >()) {
              return RJSHelper::cpp2js_QList_double(handler, v.value<QList<double> >());
          }
          if (v.canConvert<QStringList>()) {
              return RJSHelper::cpp2js_QStringList(handler, v.value<QStringList>());
          }
          if (v.canConvert<QKeySequence>()) {
              return RJSHelper::cpp2js_QKeySequence(handler, v.value<QKeySequence>());
          }

          // hook to convert more types from other modules:
          for (int i=0; i<qvariantConverters.length(); i++) {
            RJSQVariantConverter* vc = qvariantConverters[i];
            QJSValue res = vc->fromVariant(handler, v);
            if (!res.isUndefined()) {
              return res;
            }
          }

          qWarning() << "RJSHelper::cpp2js_QVariant: unhandled variant type: " << v.userType() << " / " << v.metaType().name();

          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of QVariant object:
          QVariant_Wrapper* ret = new QVariant_Wrapper(handler, new QVariant(v), true);
          //return engine->newQObject(ret);

          // JS: new QVariant('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QVariant");
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QVariant('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QVariant(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      bool RJSHelper::is_QVariant(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              // make sure a missing parameter is not counted as a valid variant:
              // e.g. QComboBox::addItem(icon, text, userData) != QComboBox::addItem(text, userData)
              return acceptUndefined;
          }

          return true;
      }

      QVariant RJSHelper::js2cpp_QVariant(RJSApi& handler, const QJSValue& v) {
          if (v.isNumber()) {
              // value is number:
              return QVariant(v.toNumber());
          }
          if (v.isBool()) {
              // value is bool:
              return QVariant(v.toBool());
          }
          if (v.isString()) {
              // value is string:
              return QVariant(v.toString());
          }
          if (v.isArray()) {
              // value is an array:
              QList<QVariant> variantList;
              const int length = v.property("length").toInt();
              for (int i = 0; i < length; ++i) {
                  variantList.append(RJSHelper::js2cpp_QVariant(handler, v.property(i)));
              }
              return QVariant(variantList);
          }

          // hook to convert more types from other modules:
          for (int i=0; i<qvariantConverters.length(); i++) {
            RJSQVariantConverter* vc = qvariantConverters[i];
            QVariant res = vc->toVariant(handler, v);
            if (res.isValid()) {
              return res;
            }
          }

          RJSWrapper* wrapper = getWrapperRJSWrapper(v);
          if (wrapper==nullptr) {
              // only if we have no wrapper (i.e. unknown type to C++):
              // after custom conversions to prevent false matches to Object instead of specialized classes:
              if (v.isObject()) {
                // JS objects are converted to QVariantMap:
                return v.toVariant(QJSValue::ConvertJSObjects);
              }

              qWarning() << "RJSHelper::js2cpp_QVariant: no wrapper";
              handler.trace();
              return QVariant();
          }

          // value is QSize, QUrl, ...:

          int t = wrapper->getWrappedType();
          if (t==RJSType_QModelIndex::getIdStatic()) {
            return QVariant(RJSHelper::js2cpp_QModelIndex(handler, v));
          }
          if (t==RJSType_QUrl::getIdStatic()) {
            return QVariant(RJSHelper::js2cpp_QUrl(handler, v));
          }
          if (t==RJSType_QRegularExpression::getIdStatic()) {
            return QVariant(RJSHelper::js2cpp_QRegularExpression(handler, v));
          }
          if (t==RJSType_QLocale::getIdStatic()) {
            return QVariant(RJSHelper::js2cpp_QLocale(handler, v));
          }
          if (t==RJSType_QRectF::getIdStatic()) {
            return QVariant(RJSHelper::js2cpp_QRectF(handler, v));
          }
          if (t==RJSType_QRect::getIdStatic()) {
            return QVariant(RJSHelper::js2cpp_QRect(handler, v));
          }
          if (t==RJSType_QLineF::getIdStatic()) {
            return QVariant(RJSHelper::js2cpp_QLineF(handler, v));
          }
          if (t==RJSType_QLine::getIdStatic()) {
            return QVariant(RJSHelper::js2cpp_QLine(handler, v));
          }
          if (t==RJSType_QPointF::getIdStatic()) {
            return QVariant(RJSHelper::js2cpp_QPointF(handler, v));
          }
          if (t==RJSType_QPoint::getIdStatic()) {
            return QVariant(RJSHelper::js2cpp_QPoint(handler, v));
          }
          if (t==RJSType_QSizeF::getIdStatic()) {
            return QVariant(RJSHelper::js2cpp_QSizeF(handler, v));
          }
          if (t==RJSType_QSize::getIdStatic()) {
            return QVariant(RJSHelper::js2cpp_QSize(handler, v));
          }
          if (t==RJSType_QDateTime::getIdStatic()) {
            return QVariant(RJSHelper::js2cpp_QDateTime(handler, v));
          }
          if (t==RJSType_QTime::getIdStatic()) {
            return QVariant(RJSHelper::js2cpp_QTime(handler, v));
          }
          if (t==RJSType_QDate::getIdStatic()) {
            return QVariant(RJSHelper::js2cpp_QDate(handler, v));
          }
          if (t==RJSType_QByteArray::getIdStatic()) {
            return QVariant(RJSHelper::js2cpp_QByteArray(handler, v));
          }
          if (t==RJSType_QWidget::getIdStatic()) {
            return QVariant::fromValue(RJSHelper::js2cpp_QWidget_ptr(handler, v));
          }
          if (t==RJSType_QToolBar::getIdStatic()) {
            return QVariant::fromValue(RJSHelper::js2cpp_QToolBar_ptr(handler, v));
          }
          if (t==RJSType_QPushButton::getIdStatic()) {
            return QVariant::fromValue(RJSHelper::js2cpp_QPushButton_ptr(handler, v));
          }
          if (t==RJSType_QPalette::getIdStatic()) {
            return QVariant::fromValue(RJSHelper::js2cpp_QPalette(handler, v));
          }
          if (t==RJSType_QKeySequence::getIdStatic()) {
            return QVariant::fromValue(RJSHelper::js2cpp_QKeySequence(handler, v));
          }
          if (t==RJSType_QFont::getIdStatic()) {
            return QVariant::fromValue(RJSHelper::js2cpp_QFont(handler, v));
          }
          if (t==RJSType_QVariant::getIdStatic()) {
            QVariant var = *(QVariant*)wrapper->getWrappedVoid();
            qDebug() << "variant:" << var;
            return var;
          }


          {
              QVariant var = *(QVariant*)wrapper->getWrappedVoid();
              if (var.canConvert<QList<QKeySequence> >()) {
                  return QVariant::fromValue(var.value<QList<QKeySequence> >());
              }
          }

          qWarning() << "unhandled QVariant type:" << RJSHelper::getTypeName(wrapper->getWrappedType());
          handler.trace();
          return *(QVariant*)wrapper->getWrappedVoid();

          

      }

      QJSValue RJSHelper::cpp2js_QObjectList(RJSApi& handler, const QList<QObject*>& v) {
          return RJSHelper::cpp2js_QList_QObject_ptr(handler, v);
      }

      QList<QObject*> RJSHelper::js2cpp_QObjectList(RJSApi& handler, const QJSValue& v) {
          return RJSHelper::js2cpp_QList_QObject_ptr(handler, v);
      }

      QJSValue RJSHelper::cpp2js_QObject(RJSApi& handler, QObject* v) {
          if (v==nullptr) {
              return QJSValue(QJSValue::UndefinedValue);
          }

          static QStringList ignoreList = {
            "QPropertyAnimation", 
            "QFormInternal::TranslationWatcher",
            "QItemSelectionModel",
            "QTableModel",
            "QStyledItemDelegate",
            "QWidgetTextControl",
            "QPlainTextEditControl",
            "QWidgetLineControl",
            "QTreeModel",
            "QComboMenuDelegate",
            "QStandardItemModel",
          };

          QString className = v->metaObject()->className();
          for (int i=0; i<ignoreList.length(); i++) {
            if (className==ignoreList[i]) {
              // silently ignore class:
              return QJSValue();
            }
          }

          if (v->isWidgetType()) {
              QWidget* o = qobject_cast<QWidget*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QWidget(handler, o);
              }
          }
          {
              QAction* o = qobject_cast<QAction*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QAction(handler, o);
              }
          }
          {
              QFile* o = qobject_cast<QFile*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QFile(handler, o);
              }
          }

          {
              QButtonGroup* o = qobject_cast<QButtonGroup*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QButtonGroup(handler, o);
              }
          }
          {
              QLayout* o = qobject_cast<QLayout*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QLayout(handler, o);
              }
          }


          for (int i=0; i<downcasters_QObject.length(); i++) {
              QJSValue dc = downcasters_QObject[i]->downcast(handler, v);
              if (!dc.isUndefined()) {
                  return dc;
              }
          }

          // don't return wrapper objects to prevent wrappers from being deleted in scripts (e.g. while destroying children):
          {
              RJSWrapperObj* o = qobject_cast<RJSWrapperObj*>(v);
              if (o!=nullptr) {
                  return QJSValue(QJSValue::UndefinedValue);
              }
          }
          // TODO: add more QObject but not QWidget or QLayout types

          qWarning() << "RJSHelper::cpp2js_QObject: not wrapping object:" << v->objectName() << " class: " << v->metaObject()->className();

          //QObject_Wrapper* ret = new QObject_Wrapper(handler, v, false);
          //return handler->newQObject(ret);

          /*
          QObject_Wrapper* ret = new QObject_Wrapper(handler, v, false);
          QJSEngine* engine = handler.getEngine();

          // JS: new QObject('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QObject");
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QObject('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QObject(wrapper)"
                      << ":" << r.toString();
          }
          return r;
          */

          return QJSValue(QJSValue::UndefinedValue);
      }

      QObject* RJSHelper::js2cpp_QObject_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "RJSHelper::js2cpp_QObject: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          //QObject_Wrapper* wrapper = qobject_cast<QObject_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QObject_Wrapper* wrapper = (QObject_Wrapper*)obj;
          //QObject_Wrapper* wrapper = getWrapper<QObject_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "RJSHelper::js2cpp_QObject: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QObject*)wrapper->getWrappedVoid();
          return QObject_Wrapper::getWrappedBase(wrapper);

          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QObject_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isObject() || (v.isNumber() && v.toInt()==0);
      }

      QJSValue RJSHelper::cpp2js_QWidget(RJSApi& handler, QWidget* v) {
          {
              QMainWindow* o = qobject_cast<QMainWindow*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QMainWindow(handler, o);
              }
          }

          {
              QDockWidget* o = qobject_cast<QDockWidget*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QDockWidget(handler, o);
              }
          }


          // QComboBox:
          {
              QFontComboBox* o = qobject_cast<QFontComboBox*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QFontComboBox(handler, o);
              }
          }
          {
              QComboBox* o = qobject_cast<QComboBox*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QComboBox(handler, o);
              }
          }

          // QLineEdit:
          {
              QLineEdit* o = qobject_cast<QLineEdit*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QLineEdit(handler, o);
              }
          }


          {
              QSpinBox* o = qobject_cast<QSpinBox*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QSpinBox(handler, o);
              }
          }

          {
              QMenu* o = qobject_cast<QMenu*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QMenu(handler, o);
              }
          }

          {
              QMenuBar* o = qobject_cast<QMenuBar*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QMenuBar(handler, o);
              }
          }

          {
              QLabel* o = qobject_cast<QLabel*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QLabel(handler, o);
              }
          }
          {
              QToolButton* o = qobject_cast<QToolButton*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QToolButton(handler, o);
              }
          }
          {
              QToolBar* o = qobject_cast<QToolBar*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QToolBar(handler, o);
              }
          }
          {
              QPushButton* o = qobject_cast<QPushButton*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QPushButton(handler, o);
              }
          }
          {
              QGroupBox* o = qobject_cast<QGroupBox*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QGroupBox(handler, o);
              }
          }
          {
              QDialogButtonBox* o = qobject_cast<QDialogButtonBox*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QDialogButtonBox(handler, o);
              }
          }
          {
              QSplitter* o = qobject_cast<QSplitter*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QSplitter(handler, o);
              }
          }
          {
              QMdiSubWindow* o = qobject_cast<QMdiSubWindow*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QMdiSubWindow(handler, o);
              }
          }
          {
              QMdiArea* o = qobject_cast<QMdiArea*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QMdiArea(handler, o);
              }
          }
          {
              QScrollBar* o = qobject_cast<QScrollBar*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QScrollBar(handler, o);
              }
          }
          {
              QPlainTextEdit* o = qobject_cast<QPlainTextEdit*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QPlainTextEdit(handler, o);
              }
          }
          {
              QScrollArea* o = qobject_cast<QScrollArea*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QScrollArea(handler, o);
              }
          }
          {
              QCheckBox* o = qobject_cast<QCheckBox*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QCheckBox(handler, o);
              }
          }
          {
              QRadioButton* o = qobject_cast<QRadioButton*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QRadioButton(handler, o);
              }
          }

          // QTreeWidget:
          {
              QTreeWidget* o = qobject_cast<QTreeWidget*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QTreeWidget(handler, o);
              }
          }

          // QListWidget:
          {
              QListWidget* o = qobject_cast<QListWidget*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QListWidget(handler, o);
              }
          }

          // QTextEdit:
          {
              QTextBrowser* o = qobject_cast<QTextBrowser*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QTextBrowser(handler, o);
              }
          }
          {
              QTextEdit* o = qobject_cast<QTextEdit*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QTextEdit(handler, o);
              }
          }

          {
              QTabWidget* o = qobject_cast<QTabWidget*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QTabWidget(handler, o);
              }
          }
          {
              QSlider* o = qobject_cast<QSlider*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QSlider(handler, o);
              }
          }



          {
              QFrame* o = qobject_cast<QFrame*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QFrame(handler, o);
              }
          }
          {
              QDialog* o = qobject_cast<QDialog*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QDialog(handler, o);
              }
          }

          {
              QStatusBar* o = qobject_cast<QStatusBar*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QStatusBar(handler, o);
              }
          }

          {
              QProgressBar* o = qobject_cast<QProgressBar*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QProgressBar(handler, o);
              }
          }

          {
              QTabBar* o = qobject_cast<QTabBar*>(v);
              if (o!=nullptr) {
                  return RJSHelper::cpp2js_QTabBar(handler, o);
              }
          }

          for (int i=0; i<downcasters_QWidget.length(); i++) {
              QJSValue dc = downcasters_QWidget[i]->downcast(handler, v);
              if (!dc.isUndefined()) {
                  return dc;
              }
          }

          // TODO: add more QWidget types

          //QWidget_Wrapper* ret = new QWidget_Wrapper(handler, v, false);
          //return handler->newQObject(ret);



          QWidget_Wrapper* ret = nullptr;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (unsigned long long int)v;
                  ret = new QWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QWidget_Wrapper(handler, nullptr, false);
          }



          //QWidget_Wrapper* ret = new QWidget_Wrapper(handler, v);
          QJSEngine* engine = handler.getEngine();

          // JS: new QWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QWidget");
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QWidget('__GOT_WRAPPER__', wrapper);");
          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QObject(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QWidget* RJSHelper::js2cpp_QWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "RJSHelper::js2cpp_QWidget: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QWidget_Wrapper* wrapper = qobject_cast<QWidget_Wrapper*>(obj);
          //QWidget_Wrapper* wrapper = (QWidget_Wrapper*)obj;
          //QWidget_Wrapper* wrapper = getWrapper<QWidget_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "RJSHelper::js2cpp_QWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QWidget*)wrapper->getWrappedVoid();
          //return wrapper->getWrapped();
          return QWidget_Wrapper::getWrappedBase(wrapper);
      }

      bool RJSHelper::is_QWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          //return v.isObject() || (v.isNumber() && v.toInt()==0);
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QWidget::getIdStatic())).toBool();
          //return fun.call(RJSType::QWidget_Type);
          //return fun.call().toInt()==RJSType::QWidget_Type;
      }

      QJSValue RJSHelper::cpp2js_QDomDocument_ParseResult(RJSApi& handler, QDomDocument::ParseResult v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newObject();
          ret.setProperty("errorColumn", (int)v.errorColumn);
          ret.setProperty("errorLine", (int)v.errorLine);
          ret.setProperty("errorMessage", v.errorMessage);
          ret.setProperty("result", (bool)v);
          return ret;
      }

      QJSValue RJSHelper::cpp2js_QList_QPair_QString_QString(RJSApi& handler, const QList<QPair<QString,QString>>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              ret.setProperty((quint32)i, RJSHelper::cpp2js_QPair_QString_QString(handler, v.at(i)));
          }
          return ret;
      }

      QList<QPair<QString,QString>> RJSHelper::js2cpp_QList_QPair_QString_QString(RJSApi& handler, const QJSValue& v) {
          QList<QPair<QString,QString>> ret;

          if (!v.isArray()) {
              qWarning() << "RJSHelper::js2cpp_QList_QPair_QString,QString: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(RJSHelper::js2cpp_QPair_QString_QString(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QPair_QString_QString(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
      
  // ----------------
  // primitive types:
  // ----------------
  
      QJSValue RJSHelper::cpp2js_QAbstractFileIconProvider_Options(RJSApi& handler, QAbstractFileIconProvider::Options v) {
        return QJSValue(v);
      }

      QAbstractFileIconProvider::Options RJSHelper::js2cpp_QAbstractFileIconProvider_Options(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QAbstractFileIconProvider::Options()
          ;
        }
        return 
        (QAbstractFileIconProvider::Options)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractFileIconProvider_Options(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractItemView_EditTriggers(RJSApi& handler, QAbstractItemView::EditTriggers v) {
        return QJSValue(v);
      }

      QAbstractItemView::EditTriggers RJSHelper::js2cpp_QAbstractItemView_EditTriggers(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QAbstractItemView::EditTriggers()
          ;
        }
        return 
        (QAbstractItemView::EditTriggers)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractItemView_EditTriggers(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractPrintDialog_PrintDialogOptions(RJSApi& handler, QAbstractPrintDialog::PrintDialogOptions v) {
        return QJSValue(v);
      }

      QAbstractPrintDialog::PrintDialogOptions RJSHelper::js2cpp_QAbstractPrintDialog_PrintDialogOptions(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QAbstractPrintDialog::PrintDialogOptions()
          ;
        }
        return 
        (QAbstractPrintDialog::PrintDialogOptions)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractPrintDialog_PrintDialogOptions(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QColorDialog_ColorDialogOptions(RJSApi& handler, QColorDialog::ColorDialogOptions v) {
        return QJSValue(v);
      }

      QColorDialog::ColorDialogOptions RJSHelper::js2cpp_QColorDialog_ColorDialogOptions(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QColorDialog::ColorDialogOptions()
          ;
        }
        return 
        (QColorDialog::ColorDialogOptions)
      v.toInt();
      }

      bool RJSHelper::is_QColorDialog_ColorDialogOptions(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QDialogButtonBox_StandardButtons(RJSApi& handler, QDialogButtonBox::StandardButtons v) {
        return QJSValue(v);
      }

      QDialogButtonBox::StandardButtons RJSHelper::js2cpp_QDialogButtonBox_StandardButtons(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QDialogButtonBox::StandardButtons()
          ;
        }
        return 
        (QDialogButtonBox::StandardButtons)
      v.toInt();
      }

      bool RJSHelper::is_QDialogButtonBox_StandardButtons(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QDir_Filters(RJSApi& handler, QDir::Filters v) {
        return QJSValue(v);
      }

      QDir::Filters RJSHelper::js2cpp_QDir_Filters(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QDir::Filters()
          ;
        }
        return 
        (QDir::Filters)
      v.toInt();
      }

      bool RJSHelper::is_QDir_Filters(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QDir_SortFlags(RJSApi& handler, QDir::SortFlags v) {
        return QJSValue(v);
      }

      QDir::SortFlags RJSHelper::js2cpp_QDir_SortFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QDir::SortFlags()
          ;
        }
        return 
        (QDir::SortFlags)
      v.toInt();
      }

      bool RJSHelper::is_QDir_SortFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QDirIterator_IteratorFlags(RJSApi& handler, QDirIterator::IteratorFlags v) {
        return QJSValue(v);
      }

      QDirIterator::IteratorFlags RJSHelper::js2cpp_QDirIterator_IteratorFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QDirIterator::IteratorFlags()
          ;
        }
        return 
        (QDirIterator::IteratorFlags)
      v.toInt();
      }

      bool RJSHelper::is_QDirIterator_IteratorFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QDockWidget_DockWidgetFeatures(RJSApi& handler, QDockWidget::DockWidgetFeatures v) {
        return QJSValue(v);
      }

      QDockWidget::DockWidgetFeatures RJSHelper::js2cpp_QDockWidget_DockWidgetFeatures(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QDockWidget::DockWidgetFeatures()
          ;
        }
        return 
        (QDockWidget::DockWidgetFeatures)
      v.toInt();
      }

      bool RJSHelper::is_QDockWidget_DockWidgetFeatures(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QEventLoop_ProcessEventsFlags(RJSApi& handler, QEventLoop::ProcessEventsFlags v) {
        return QJSValue(v);
      }

      QEventLoop::ProcessEventsFlags RJSHelper::js2cpp_QEventLoop_ProcessEventsFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QEventLoop::ProcessEventsFlags()
          ;
        }
        return 
        (QEventLoop::ProcessEventsFlags)
      v.toInt();
      }

      bool RJSHelper::is_QEventLoop_ProcessEventsFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFile_OpenMode(RJSApi& handler, QFile::OpenMode v) {
        return QJSValue(v);
      }

      QFile::OpenMode RJSHelper::js2cpp_QFile_OpenMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QFile::OpenMode()
          ;
        }
        return 
        (QFile::OpenMode)
      v.toInt();
      }

      bool RJSHelper::is_QFile_OpenMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFile_Permissions(RJSApi& handler, QFile::Permissions v) {
        return QJSValue(v);
      }

      QFile::Permissions RJSHelper::js2cpp_QFile_Permissions(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QFile::Permissions()
          ;
        }
        return 
        (QFile::Permissions)
      v.toInt();
      }

      bool RJSHelper::is_QFile_Permissions(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFileDialog_Options(RJSApi& handler, QFileDialog::Options v) {
        return QJSValue(v);
      }

      QFileDialog::Options RJSHelper::js2cpp_QFileDialog_Options(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QFileDialog::Options()
          ;
        }
        return 
        (QFileDialog::Options)
      v.toInt();
      }

      bool RJSHelper::is_QFileDialog_Options(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFileSystemModel_Options(RJSApi& handler, QFileSystemModel::Options v) {
        return QJSValue(v);
      }

      QFileSystemModel::Options RJSHelper::js2cpp_QFileSystemModel_Options(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QFileSystemModel::Options()
          ;
        }
        return 
        (QFileSystemModel::Options)
      v.toInt();
      }

      bool RJSHelper::is_QFileSystemModel_Options(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFontComboBox_FontFilters(RJSApi& handler, QFontComboBox::FontFilters v) {
        return QJSValue(v);
      }

      QFontComboBox::FontFilters RJSHelper::js2cpp_QFontComboBox_FontFilters(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QFontComboBox::FontFilters()
          ;
        }
        return 
        (QFontComboBox::FontFilters)
      v.toInt();
      }

      bool RJSHelper::is_QFontComboBox_FontFilters(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QGraphicsBlurEffect_BlurHints(RJSApi& handler, QGraphicsBlurEffect::BlurHints v) {
        return QJSValue(v);
      }

      QGraphicsBlurEffect::BlurHints RJSHelper::js2cpp_QGraphicsBlurEffect_BlurHints(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QGraphicsBlurEffect::BlurHints()
          ;
        }
        return 
        (QGraphicsBlurEffect::BlurHints)
      v.toInt();
      }

      bool RJSHelper::is_QGraphicsBlurEffect_BlurHints(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QGraphicsEffect_ChangeFlags(RJSApi& handler, QGraphicsEffect::ChangeFlags v) {
        return QJSValue(v);
      }

      QGraphicsEffect::ChangeFlags RJSHelper::js2cpp_QGraphicsEffect_ChangeFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QGraphicsEffect::ChangeFlags()
          ;
        }
        return 
        (QGraphicsEffect::ChangeFlags)
      v.toInt();
      }

      bool RJSHelper::is_QGraphicsEffect_ChangeFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QItemSelectionModel_SelectionFlags(RJSApi& handler, QItemSelectionModel::SelectionFlags v) {
        return QJSValue(v);
      }

      QItemSelectionModel::SelectionFlags RJSHelper::js2cpp_QItemSelectionModel_SelectionFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QItemSelectionModel::SelectionFlags()
          ;
        }
        return 
        (QItemSelectionModel::SelectionFlags)
      v.toInt();
      }

      bool RJSHelper::is_QItemSelectionModel_SelectionFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QLocale_DataSizeFormats(RJSApi& handler, QLocale::DataSizeFormats v) {
        return QJSValue(v);
      }

      QLocale::DataSizeFormats RJSHelper::js2cpp_QLocale_DataSizeFormats(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QLocale::DataSizeFormats()
          ;
        }
        return 
        (QLocale::DataSizeFormats)
      v.toInt();
      }

      bool RJSHelper::is_QLocale_DataSizeFormats(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QMessageBox_StandardButtons(RJSApi& handler, QMessageBox::StandardButtons v) {
        return QJSValue(v);
      }

      QMessageBox::StandardButtons RJSHelper::js2cpp_QMessageBox_StandardButtons(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QMessageBox::StandardButtons()
          ;
        }
        return 
        (QMessageBox::StandardButtons)
      v.toInt();
      }

      bool RJSHelper::is_QMessageBox_StandardButtons(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPinchGesture_ChangeFlags(RJSApi& handler, QPinchGesture::ChangeFlags v) {
        return QJSValue(v);
      }

      QPinchGesture::ChangeFlags RJSHelper::js2cpp_QPinchGesture_ChangeFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QPinchGesture::ChangeFlags()
          ;
        }
        return 
        (QPinchGesture::ChangeFlags)
      v.toInt();
      }

      bool RJSHelper::is_QPinchGesture_ChangeFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QRegularExpression_PatternOptions(RJSApi& handler, QRegularExpression::PatternOptions v) {
        return QJSValue(v);
      }

      QRegularExpression::PatternOptions RJSHelper::js2cpp_QRegularExpression_PatternOptions(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QRegularExpression::PatternOptions()
          ;
        }
        return 
        (QRegularExpression::PatternOptions)
      v.toInt();
      }

      bool RJSHelper::is_QRegularExpression_PatternOptions(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QRegularExpression_WildcardConversionOptions(RJSApi& handler, QRegularExpression::WildcardConversionOptions v) {
        return QJSValue(v);
      }

      QRegularExpression::WildcardConversionOptions RJSHelper::js2cpp_QRegularExpression_WildcardConversionOptions(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QRegularExpression::WildcardConversionOptions()
          ;
        }
        return 
        (QRegularExpression::WildcardConversionOptions)
      v.toInt();
      }

      bool RJSHelper::is_QRegularExpression_WildcardConversionOptions(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QSizePolicy_ControlTypes(RJSApi& handler, QSizePolicy::ControlTypes v) {
        return QJSValue(v);
      }

      QSizePolicy::ControlTypes RJSHelper::js2cpp_QSizePolicy_ControlTypes(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QSizePolicy::ControlTypes()
          ;
        }
        return 
        (QSizePolicy::ControlTypes)
      v.toInt();
      }

      bool RJSHelper::is_QSizePolicy_ControlTypes(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QSurfaceFormat_FormatOptions(RJSApi& handler, QSurfaceFormat::FormatOptions v) {
        return QJSValue(v);
      }

      QSurfaceFormat::FormatOptions RJSHelper::js2cpp_QSurfaceFormat_FormatOptions(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QSurfaceFormat::FormatOptions()
          ;
        }
        return 
        (QSurfaceFormat::FormatOptions)
      v.toInt();
      }

      bool RJSHelper::is_QSurfaceFormat_FormatOptions(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextDocument_FindFlags(RJSApi& handler, QTextDocument::FindFlags v) {
        return QJSValue(v);
      }

      QTextDocument::FindFlags RJSHelper::js2cpp_QTextDocument_FindFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QTextDocument::FindFlags()
          ;
        }
        return 
        (QTextDocument::FindFlags)
      v.toInt();
      }

      bool RJSHelper::is_QTextDocument_FindFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextEdit_AutoFormatting(RJSApi& handler, QTextEdit::AutoFormatting v) {
        return QJSValue(v);
      }

      QTextEdit::AutoFormatting RJSHelper::js2cpp_QTextEdit_AutoFormatting(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QTextEdit::AutoFormatting()
          ;
        }
        return 
        (QTextEdit::AutoFormatting)
      v.toInt();
      }

      bool RJSHelper::is_QTextEdit_AutoFormatting(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextFormat_PageBreakFlags(RJSApi& handler, QTextFormat::PageBreakFlags v) {
        return QJSValue(v);
      }

      QTextFormat::PageBreakFlags RJSHelper::js2cpp_QTextFormat_PageBreakFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QTextFormat::PageBreakFlags()
          ;
        }
        return 
        (QTextFormat::PageBreakFlags)
      v.toInt();
      }

      bool RJSHelper::is_QTextFormat_PageBreakFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QUrl_ComponentFormattingOptions(RJSApi& handler, QUrl::ComponentFormattingOptions v) {
        return QJSValue(v);
      }

      QUrl::ComponentFormattingOptions RJSHelper::js2cpp_QUrl_ComponentFormattingOptions(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QUrl::ComponentFormattingOptions()
          ;
        }
        return 
        (QUrl::ComponentFormattingOptions)
      v.toInt();
      }

      bool RJSHelper::is_QUrl_ComponentFormattingOptions(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QUrl_FormattingOptions(RJSApi& handler, QUrl::FormattingOptions v) {
        return QJSValue(v);
      }

      QUrl::FormattingOptions RJSHelper::js2cpp_QUrl_FormattingOptions(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QUrl::FormattingOptions()
          ;
        }
        return 
        (QUrl::FormattingOptions)
      v.toInt();
      }

      bool RJSHelper::is_QUrl_FormattingOptions(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QUrl_UserInputResolutionOptions(RJSApi& handler, QUrl::UserInputResolutionOptions v) {
        return QJSValue(v);
      }

      QUrl::UserInputResolutionOptions RJSHelper::js2cpp_QUrl_UserInputResolutionOptions(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return QUrl::UserInputResolutionOptions()
          ;
        }
        return 
        (QUrl::UserInputResolutionOptions)
      v.toInt();
      }

      bool RJSHelper::is_QUrl_UserInputResolutionOptions(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_Alignment(RJSApi& handler, Qt::Alignment v) {
        return QJSValue(v);
      }

      Qt::Alignment RJSHelper::js2cpp_Qt_Alignment(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return Qt::Alignment()
          ;
        }
        return 
        (Qt::Alignment)
      v.toInt();
      }

      bool RJSHelper::is_Qt_Alignment(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ApplicationStates(RJSApi& handler, Qt::ApplicationStates v) {
        return QJSValue(v);
      }

      Qt::ApplicationStates RJSHelper::js2cpp_Qt_ApplicationStates(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return Qt::ApplicationStates()
          ;
        }
        return 
        (Qt::ApplicationStates)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ApplicationStates(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_DropActions(RJSApi& handler, Qt::DropActions v) {
        return QJSValue(v);
      }

      Qt::DropActions RJSHelper::js2cpp_Qt_DropActions(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return Qt::DropActions()
          ;
        }
        return 
        (Qt::DropActions)
      v.toInt();
      }

      bool RJSHelper::is_Qt_DropActions(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_Edges(RJSApi& handler, Qt::Edges v) {
        return QJSValue(v);
      }

      Qt::Edges RJSHelper::js2cpp_Qt_Edges(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return Qt::Edges()
          ;
        }
        return 
        (Qt::Edges)
      v.toInt();
      }

      bool RJSHelper::is_Qt_Edges(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_InputMethodHints(RJSApi& handler, Qt::InputMethodHints v) {
        return QJSValue(v);
      }

      Qt::InputMethodHints RJSHelper::js2cpp_Qt_InputMethodHints(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return Qt::InputMethodHints()
          ;
        }
        return 
        (Qt::InputMethodHints)
      v.toInt();
      }

      bool RJSHelper::is_Qt_InputMethodHints(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ItemFlags(RJSApi& handler, Qt::ItemFlags v) {
        return QJSValue(v);
      }

      Qt::ItemFlags RJSHelper::js2cpp_Qt_ItemFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return Qt::ItemFlags()
          ;
        }
        return 
        (Qt::ItemFlags)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ItemFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_KeyboardModifiers(RJSApi& handler, Qt::KeyboardModifiers v) {
        return QJSValue(v);
      }

      Qt::KeyboardModifiers RJSHelper::js2cpp_Qt_KeyboardModifiers(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return Qt::KeyboardModifiers()
          ;
        }
        return 
        (Qt::KeyboardModifiers)
      v.toInt();
      }

      bool RJSHelper::is_Qt_KeyboardModifiers(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_Modifiers(RJSApi& handler, Qt::Modifiers v) {
        return QJSValue(v);
      }

      Qt::Modifiers RJSHelper::js2cpp_Qt_Modifiers(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return Qt::Modifiers()
          ;
        }
        return 
        (Qt::Modifiers)
      v.toInt();
      }

      bool RJSHelper::is_Qt_Modifiers(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_MouseButtons(RJSApi& handler, Qt::MouseButtons v) {
        return QJSValue(v);
      }

      Qt::MouseButtons RJSHelper::js2cpp_Qt_MouseButtons(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return Qt::MouseButtons()
          ;
        }
        return 
        (Qt::MouseButtons)
      v.toInt();
      }

      bool RJSHelper::is_Qt_MouseButtons(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_MouseEventFlags(RJSApi& handler, Qt::MouseEventFlags v) {
        return QJSValue(v);
      }

      Qt::MouseEventFlags RJSHelper::js2cpp_Qt_MouseEventFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return Qt::MouseEventFlags()
          ;
        }
        return 
        (Qt::MouseEventFlags)
      v.toInt();
      }

      bool RJSHelper::is_Qt_MouseEventFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_Orientations(RJSApi& handler, Qt::Orientations v) {
        return QJSValue(v);
      }

      Qt::Orientations RJSHelper::js2cpp_Qt_Orientations(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return Qt::Orientations()
          ;
        }
        return 
        (Qt::Orientations)
      v.toInt();
      }

      bool RJSHelper::is_Qt_Orientations(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_TextInteractionFlags(RJSApi& handler, Qt::TextInteractionFlags v) {
        return QJSValue(v);
      }

      Qt::TextInteractionFlags RJSHelper::js2cpp_Qt_TextInteractionFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return Qt::TextInteractionFlags()
          ;
        }
        return 
        (Qt::TextInteractionFlags)
      v.toInt();
      }

      bool RJSHelper::is_Qt_TextInteractionFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_WindowFlags(RJSApi& handler, Qt::WindowFlags v) {
        return QJSValue(v);
      }

      Qt::WindowFlags RJSHelper::js2cpp_Qt_WindowFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return Qt::WindowFlags()
          ;
        }
        return 
        (Qt::WindowFlags)
      v.toInt();
      }

      bool RJSHelper::is_Qt_WindowFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_WindowStates(RJSApi& handler, Qt::WindowStates v) {
        return QJSValue(v);
      }

      Qt::WindowStates RJSHelper::js2cpp_Qt_WindowStates(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return Qt::WindowStates()
          ;
        }
        return 
        (Qt::WindowStates)
      v.toInt();
      }

      bool RJSHelper::is_Qt_WindowStates(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractFileIconProvider_IconType(RJSApi& handler, QAbstractFileIconProvider::IconType v) {
        return QJSValue(v);
      }

      QAbstractFileIconProvider::IconType RJSHelper::js2cpp_QAbstractFileIconProvider_IconType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QAbstractFileIconProvider::IconType)0
          ;
        }
        return 
        (QAbstractFileIconProvider::IconType)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractFileIconProvider_IconType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractFileIconProvider_Option(RJSApi& handler, QAbstractFileIconProvider::Option v) {
        return QJSValue(v);
      }

      QAbstractFileIconProvider::Option RJSHelper::js2cpp_QAbstractFileIconProvider_Option(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QAbstractFileIconProvider::Option)0
          ;
        }
        return 
        (QAbstractFileIconProvider::Option)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractFileIconProvider_Option(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractItemDelegate_EndEditHint(RJSApi& handler, QAbstractItemDelegate::EndEditHint v) {
        return QJSValue(v);
      }

      QAbstractItemDelegate::EndEditHint RJSHelper::js2cpp_QAbstractItemDelegate_EndEditHint(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QAbstractItemDelegate::EndEditHint)0
          ;
        }
        return 
        (QAbstractItemDelegate::EndEditHint)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractItemDelegate_EndEditHint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractItemView_DragDropMode(RJSApi& handler, QAbstractItemView::DragDropMode v) {
        return QJSValue(v);
      }

      QAbstractItemView::DragDropMode RJSHelper::js2cpp_QAbstractItemView_DragDropMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QAbstractItemView::DragDropMode)0
          ;
        }
        return 
        (QAbstractItemView::DragDropMode)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractItemView_DragDropMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractItemView_EditTrigger(RJSApi& handler, QAbstractItemView::EditTrigger v) {
        return QJSValue(v);
      }

      QAbstractItemView::EditTrigger RJSHelper::js2cpp_QAbstractItemView_EditTrigger(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QAbstractItemView::EditTrigger)0
          ;
        }
        return 
        (QAbstractItemView::EditTrigger)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractItemView_EditTrigger(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractItemView_ScrollHint(RJSApi& handler, QAbstractItemView::ScrollHint v) {
        return QJSValue(v);
      }

      QAbstractItemView::ScrollHint RJSHelper::js2cpp_QAbstractItemView_ScrollHint(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QAbstractItemView::ScrollHint)0
          ;
        }
        return 
        (QAbstractItemView::ScrollHint)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractItemView_ScrollHint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractItemView_ScrollMode(RJSApi& handler, QAbstractItemView::ScrollMode v) {
        return QJSValue(v);
      }

      QAbstractItemView::ScrollMode RJSHelper::js2cpp_QAbstractItemView_ScrollMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QAbstractItemView::ScrollMode)0
          ;
        }
        return 
        (QAbstractItemView::ScrollMode)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractItemView_ScrollMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractItemView_SelectionBehavior(RJSApi& handler, QAbstractItemView::SelectionBehavior v) {
        return QJSValue(v);
      }

      QAbstractItemView::SelectionBehavior RJSHelper::js2cpp_QAbstractItemView_SelectionBehavior(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QAbstractItemView::SelectionBehavior)0
          ;
        }
        return 
        (QAbstractItemView::SelectionBehavior)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractItemView_SelectionBehavior(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractItemView_SelectionMode(RJSApi& handler, QAbstractItemView::SelectionMode v) {
        return QJSValue(v);
      }

      QAbstractItemView::SelectionMode RJSHelper::js2cpp_QAbstractItemView_SelectionMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QAbstractItemView::SelectionMode)0
          ;
        }
        return 
        (QAbstractItemView::SelectionMode)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractItemView_SelectionMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractPrintDialog_PrintDialogOption(RJSApi& handler, QAbstractPrintDialog::PrintDialogOption v) {
        return QJSValue(v);
      }

      QAbstractPrintDialog::PrintDialogOption RJSHelper::js2cpp_QAbstractPrintDialog_PrintDialogOption(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QAbstractPrintDialog::PrintDialogOption)0
          ;
        }
        return 
        (QAbstractPrintDialog::PrintDialogOption)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractPrintDialog_PrintDialogOption(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractPrintDialog_PrintRange(RJSApi& handler, QAbstractPrintDialog::PrintRange v) {
        return QJSValue(v);
      }

      QAbstractPrintDialog::PrintRange RJSHelper::js2cpp_QAbstractPrintDialog_PrintRange(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QAbstractPrintDialog::PrintRange)0
          ;
        }
        return 
        (QAbstractPrintDialog::PrintRange)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractPrintDialog_PrintRange(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractScrollArea_SizeAdjustPolicy(RJSApi& handler, QAbstractScrollArea::SizeAdjustPolicy v) {
        return QJSValue(v);
      }

      QAbstractScrollArea::SizeAdjustPolicy RJSHelper::js2cpp_QAbstractScrollArea_SizeAdjustPolicy(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QAbstractScrollArea::SizeAdjustPolicy)0
          ;
        }
        return 
        (QAbstractScrollArea::SizeAdjustPolicy)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractScrollArea_SizeAdjustPolicy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractSlider_SliderAction(RJSApi& handler, QAbstractSlider::SliderAction v) {
        return QJSValue(v);
      }

      QAbstractSlider::SliderAction RJSHelper::js2cpp_QAbstractSlider_SliderAction(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QAbstractSlider::SliderAction)0
          ;
        }
        return 
        (QAbstractSlider::SliderAction)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractSlider_SliderAction(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractSpinBox_StepType(RJSApi& handler, QAbstractSpinBox::StepType v) {
        return QJSValue(v);
      }

      QAbstractSpinBox::StepType RJSHelper::js2cpp_QAbstractSpinBox_StepType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QAbstractSpinBox::StepType)0
          ;
        }
        return 
        (QAbstractSpinBox::StepType)
      v.toInt();
      }

      bool RJSHelper::is_QAbstractSpinBox_StepType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAction_MenuRole(RJSApi& handler, QAction::MenuRole v) {
        return QJSValue(v);
      }

      QAction::MenuRole RJSHelper::js2cpp_QAction_MenuRole(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QAction::MenuRole)0
          ;
        }
        return 
        (QAction::MenuRole)
      v.toInt();
      }

      bool RJSHelper::is_QAction_MenuRole(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QAction_Priority(RJSApi& handler, QAction::Priority v) {
        return QJSValue(v);
      }

      QAction::Priority RJSHelper::js2cpp_QAction_Priority(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QAction::Priority)0
          ;
        }
        return 
        (QAction::Priority)
      v.toInt();
      }

      bool RJSHelper::is_QAction_Priority(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QBoxLayout_Direction(RJSApi& handler, QBoxLayout::Direction v) {
        return QJSValue(v);
      }

      QBoxLayout::Direction RJSHelper::js2cpp_QBoxLayout_Direction(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QBoxLayout::Direction)0
          ;
        }
        return 
        (QBoxLayout::Direction)
      v.toInt();
      }

      bool RJSHelper::is_QBoxLayout_Direction(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QChar(RJSApi& handler, const QString& v) {
        return QJSValue(v);
      }

      QChar RJSHelper::js2cpp_QChar(RJSApi& handler, const QJSValue& v) {
        if (!v.isString()) {
          return QChar();
        }
        return v.toString().at(0);
      }

      bool RJSHelper::is_QChar(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isString();
      }
    
      QJSValue RJSHelper::cpp2js_QClipboard_Mode(RJSApi& handler, QClipboard::Mode v) {
        return QJSValue(v);
      }

      QClipboard::Mode RJSHelper::js2cpp_QClipboard_Mode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QClipboard::Mode)0
          ;
        }
        return 
        (QClipboard::Mode)
      v.toInt();
      }

      bool RJSHelper::is_QClipboard_Mode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QColor_NameFormat(RJSApi& handler, QColor::NameFormat v) {
        return QJSValue(v);
      }

      QColor::NameFormat RJSHelper::js2cpp_QColor_NameFormat(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QColor::NameFormat)0
          ;
        }
        return 
        (QColor::NameFormat)
      v.toInt();
      }

      bool RJSHelper::is_QColor_NameFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QColor_Spec(RJSApi& handler, QColor::Spec v) {
        return QJSValue(v);
      }

      QColor::Spec RJSHelper::js2cpp_QColor_Spec(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QColor::Spec)0
          ;
        }
        return 
        (QColor::Spec)
      v.toInt();
      }

      bool RJSHelper::is_QColor_Spec(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QColorDialog_ColorDialogOption(RJSApi& handler, QColorDialog::ColorDialogOption v) {
        return QJSValue(v);
      }

      QColorDialog::ColorDialogOption RJSHelper::js2cpp_QColorDialog_ColorDialogOption(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QColorDialog::ColorDialogOption)0
          ;
        }
        return 
        (QColorDialog::ColorDialogOption)
      v.toInt();
      }

      bool RJSHelper::is_QColorDialog_ColorDialogOption(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QComboBox_InsertPolicy(RJSApi& handler, QComboBox::InsertPolicy v) {
        return QJSValue(v);
      }

      QComboBox::InsertPolicy RJSHelper::js2cpp_QComboBox_InsertPolicy(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QComboBox::InsertPolicy)0
          ;
        }
        return 
        (QComboBox::InsertPolicy)
      v.toInt();
      }

      bool RJSHelper::is_QComboBox_InsertPolicy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QComboBox_SizeAdjustPolicy(RJSApi& handler, QComboBox::SizeAdjustPolicy v) {
        return QJSValue(v);
      }

      QComboBox::SizeAdjustPolicy RJSHelper::js2cpp_QComboBox_SizeAdjustPolicy(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QComboBox::SizeAdjustPolicy)0
          ;
        }
        return 
        (QComboBox::SizeAdjustPolicy)
      v.toInt();
      }

      bool RJSHelper::is_QComboBox_SizeAdjustPolicy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QCompleter_CompletionMode(RJSApi& handler, QCompleter::CompletionMode v) {
        return QJSValue(v);
      }

      QCompleter::CompletionMode RJSHelper::js2cpp_QCompleter_CompletionMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QCompleter::CompletionMode)0
          ;
        }
        return 
        (QCompleter::CompletionMode)
      v.toInt();
      }

      bool RJSHelper::is_QCompleter_CompletionMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QCompleter_ModelSorting(RJSApi& handler, QCompleter::ModelSorting v) {
        return QJSValue(v);
      }

      QCompleter::ModelSorting RJSHelper::js2cpp_QCompleter_ModelSorting(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QCompleter::ModelSorting)0
          ;
        }
        return 
        (QCompleter::ModelSorting)
      v.toInt();
      }

      bool RJSHelper::is_QCompleter_ModelSorting(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QContextMenuEvent_Reason(RJSApi& handler, QContextMenuEvent::Reason v) {
        return QJSValue(v);
      }

      QContextMenuEvent::Reason RJSHelper::js2cpp_QContextMenuEvent_Reason(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QContextMenuEvent::Reason)0
          ;
        }
        return 
        (QContextMenuEvent::Reason)
      v.toInt();
      }

      bool RJSHelper::is_QContextMenuEvent_Reason(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QDialogButtonBox_ButtonLayout(RJSApi& handler, QDialogButtonBox::ButtonLayout v) {
        return QJSValue(v);
      }

      QDialogButtonBox::ButtonLayout RJSHelper::js2cpp_QDialogButtonBox_ButtonLayout(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QDialogButtonBox::ButtonLayout)0
          ;
        }
        return 
        (QDialogButtonBox::ButtonLayout)
      v.toInt();
      }

      bool RJSHelper::is_QDialogButtonBox_ButtonLayout(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QDialogButtonBox_ButtonRole(RJSApi& handler, QDialogButtonBox::ButtonRole v) {
        return QJSValue(v);
      }

      QDialogButtonBox::ButtonRole RJSHelper::js2cpp_QDialogButtonBox_ButtonRole(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QDialogButtonBox::ButtonRole)0
          ;
        }
        return 
        (QDialogButtonBox::ButtonRole)
      v.toInt();
      }

      bool RJSHelper::is_QDialogButtonBox_ButtonRole(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QDialogButtonBox_StandardButton(RJSApi& handler, QDialogButtonBox::StandardButton v) {
        return QJSValue(v);
      }

      QDialogButtonBox::StandardButton RJSHelper::js2cpp_QDialogButtonBox_StandardButton(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QDialogButtonBox::StandardButton)0
          ;
        }
        return 
        (QDialogButtonBox::StandardButton)
      v.toInt();
      }

      bool RJSHelper::is_QDialogButtonBox_StandardButton(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QDirIterator_IteratorFlag(RJSApi& handler, QDirIterator::IteratorFlag v) {
        return QJSValue(v);
      }

      QDirIterator::IteratorFlag RJSHelper::js2cpp_QDirIterator_IteratorFlag(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QDirIterator::IteratorFlag)0
          ;
        }
        return 
        (QDirIterator::IteratorFlag)
      v.toInt();
      }

      bool RJSHelper::is_QDirIterator_IteratorFlag(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QDockWidget_DockWidgetFeature(RJSApi& handler, QDockWidget::DockWidgetFeature v) {
        return QJSValue(v);
      }

      QDockWidget::DockWidgetFeature RJSHelper::js2cpp_QDockWidget_DockWidgetFeature(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QDockWidget::DockWidgetFeature)0
          ;
        }
        return 
        (QDockWidget::DockWidgetFeature)
      v.toInt();
      }

      bool RJSHelper::is_QDockWidget_DockWidgetFeature(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QDomImplementation_InvalidDataPolicy(RJSApi& handler, QDomImplementation::InvalidDataPolicy v) {
        return QJSValue(v);
      }

      QDomImplementation::InvalidDataPolicy RJSHelper::js2cpp_QDomImplementation_InvalidDataPolicy(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QDomImplementation::InvalidDataPolicy)0
          ;
        }
        return 
        (QDomImplementation::InvalidDataPolicy)
      v.toInt();
      }

      bool RJSHelper::is_QDomImplementation_InvalidDataPolicy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QDomNode_EncodingPolicy(RJSApi& handler, QDomNode::EncodingPolicy v) {
        return QJSValue(v);
      }

      QDomNode::EncodingPolicy RJSHelper::js2cpp_QDomNode_EncodingPolicy(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QDomNode::EncodingPolicy)0
          ;
        }
        return 
        (QDomNode::EncodingPolicy)
      v.toInt();
      }

      bool RJSHelper::is_QDomNode_EncodingPolicy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QDomNode_NodeType(RJSApi& handler, QDomNode::NodeType v) {
        return QJSValue(v);
      }

      QDomNode::NodeType RJSHelper::js2cpp_QDomNode_NodeType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QDomNode::NodeType)0
          ;
        }
        return 
        (QDomNode::NodeType)
      v.toInt();
      }

      bool RJSHelper::is_QDomNode_NodeType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QDoubleValidator_Notation(RJSApi& handler, QDoubleValidator::Notation v) {
        return QJSValue(v);
      }

      QDoubleValidator::Notation RJSHelper::js2cpp_QDoubleValidator_Notation(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QDoubleValidator::Notation)0
          ;
        }
        return 
        (QDoubleValidator::Notation)
      v.toInt();
      }

      bool RJSHelper::is_QDoubleValidator_Notation(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QEasingCurve_Type(RJSApi& handler, QEasingCurve::Type v) {
        return QJSValue(v);
      }

      QEasingCurve::Type RJSHelper::js2cpp_QEasingCurve_Type(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QEasingCurve::Type)0
          ;
        }
        return 
        (QEasingCurve::Type)
      v.toInt();
      }

      bool RJSHelper::is_QEasingCurve_Type(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QEvent_Type(RJSApi& handler, QEvent::Type v) {
        return QJSValue(v);
      }

      QEvent::Type RJSHelper::js2cpp_QEvent_Type(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QEvent::Type)0
          ;
        }
        return 
        (QEvent::Type)
      v.toInt();
      }

      bool RJSHelper::is_QEvent_Type(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QEventLoop_ProcessEventsFlag(RJSApi& handler, QEventLoop::ProcessEventsFlag v) {
        return QJSValue(v);
      }

      QEventLoop::ProcessEventsFlag RJSHelper::js2cpp_QEventLoop_ProcessEventsFlag(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QEventLoop::ProcessEventsFlag)0
          ;
        }
        return 
        (QEventLoop::ProcessEventsFlag)
      v.toInt();
      }

      bool RJSHelper::is_QEventLoop_ProcessEventsFlag(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QEventPoint_State(RJSApi& handler, QEventPoint::State v) {
        return QJSValue(v);
      }

      QEventPoint::State RJSHelper::js2cpp_QEventPoint_State(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QEventPoint::State)0
          ;
        }
        return 
        (QEventPoint::State)
      v.toInt();
      }

      bool RJSHelper::is_QEventPoint_State(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFile_FileTime(RJSApi& handler, QFile::FileTime v) {
        return QJSValue(v);
      }

      QFile::FileTime RJSHelper::js2cpp_QFile_FileTime(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFile::FileTime)0
          ;
        }
        return 
        (QFile::FileTime)
      v.toInt();
      }

      bool RJSHelper::is_QFile_FileTime(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFileDevice_FileError(RJSApi& handler, QFileDevice::FileError v) {
        return QJSValue(v);
      }

      QFileDevice::FileError RJSHelper::js2cpp_QFileDevice_FileError(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFileDevice::FileError)0
          ;
        }
        return 
        (QFileDevice::FileError)
      v.toInt();
      }

      bool RJSHelper::is_QFileDevice_FileError(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFileDevice_FileTime(RJSApi& handler, QFileDevice::FileTime v) {
        return QJSValue(v);
      }

      QFileDevice::FileTime RJSHelper::js2cpp_QFileDevice_FileTime(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFileDevice::FileTime)0
          ;
        }
        return 
        (QFileDevice::FileTime)
      v.toInt();
      }

      bool RJSHelper::is_QFileDevice_FileTime(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFileDevice_MemoryMapFlags(RJSApi& handler, QFileDevice::MemoryMapFlags v) {
        return QJSValue(v);
      }

      QFileDevice::MemoryMapFlags RJSHelper::js2cpp_QFileDevice_MemoryMapFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFileDevice::MemoryMapFlags)0
          ;
        }
        return 
        (QFileDevice::MemoryMapFlags)
      v.toInt();
      }

      bool RJSHelper::is_QFileDevice_MemoryMapFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFileDialog_AcceptMode(RJSApi& handler, QFileDialog::AcceptMode v) {
        return QJSValue(v);
      }

      QFileDialog::AcceptMode RJSHelper::js2cpp_QFileDialog_AcceptMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFileDialog::AcceptMode)0
          ;
        }
        return 
        (QFileDialog::AcceptMode)
      v.toInt();
      }

      bool RJSHelper::is_QFileDialog_AcceptMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFileDialog_DialogLabel(RJSApi& handler, QFileDialog::DialogLabel v) {
        return QJSValue(v);
      }

      QFileDialog::DialogLabel RJSHelper::js2cpp_QFileDialog_DialogLabel(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFileDialog::DialogLabel)0
          ;
        }
        return 
        (QFileDialog::DialogLabel)
      v.toInt();
      }

      bool RJSHelper::is_QFileDialog_DialogLabel(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFileDialog_FileMode(RJSApi& handler, QFileDialog::FileMode v) {
        return QJSValue(v);
      }

      QFileDialog::FileMode RJSHelper::js2cpp_QFileDialog_FileMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFileDialog::FileMode)0
          ;
        }
        return 
        (QFileDialog::FileMode)
      v.toInt();
      }

      bool RJSHelper::is_QFileDialog_FileMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFileDialog_Option(RJSApi& handler, QFileDialog::Option v) {
        return QJSValue(v);
      }

      QFileDialog::Option RJSHelper::js2cpp_QFileDialog_Option(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFileDialog::Option)0
          ;
        }
        return 
        (QFileDialog::Option)
      v.toInt();
      }

      bool RJSHelper::is_QFileDialog_Option(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFileDialog_ViewMode(RJSApi& handler, QFileDialog::ViewMode v) {
        return QJSValue(v);
      }

      QFileDialog::ViewMode RJSHelper::js2cpp_QFileDialog_ViewMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFileDialog::ViewMode)0
          ;
        }
        return 
        (QFileDialog::ViewMode)
      v.toInt();
      }

      bool RJSHelper::is_QFileDialog_ViewMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFileSystemModel_Option(RJSApi& handler, QFileSystemModel::Option v) {
        return QJSValue(v);
      }

      QFileSystemModel::Option RJSHelper::js2cpp_QFileSystemModel_Option(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFileSystemModel::Option)0
          ;
        }
        return 
        (QFileSystemModel::Option)
      v.toInt();
      }

      bool RJSHelper::is_QFileSystemModel_Option(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFont_Capitalization(RJSApi& handler, QFont::Capitalization v) {
        return QJSValue(v);
      }

      QFont::Capitalization RJSHelper::js2cpp_QFont_Capitalization(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFont::Capitalization)0
          ;
        }
        return 
        (QFont::Capitalization)
      v.toInt();
      }

      bool RJSHelper::is_QFont_Capitalization(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFont_HintingPreference(RJSApi& handler, QFont::HintingPreference v) {
        return QJSValue(v);
      }

      QFont::HintingPreference RJSHelper::js2cpp_QFont_HintingPreference(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFont::HintingPreference)0
          ;
        }
        return 
        (QFont::HintingPreference)
      v.toInt();
      }

      bool RJSHelper::is_QFont_HintingPreference(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFont_ResolveProperties(RJSApi& handler, QFont::ResolveProperties v) {
        return QJSValue(v);
      }

      QFont::ResolveProperties RJSHelper::js2cpp_QFont_ResolveProperties(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFont::ResolveProperties)0
          ;
        }
        return 
        (QFont::ResolveProperties)
      v.toInt();
      }

      bool RJSHelper::is_QFont_ResolveProperties(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFont_SpacingType(RJSApi& handler, QFont::SpacingType v) {
        return QJSValue(v);
      }

      QFont::SpacingType RJSHelper::js2cpp_QFont_SpacingType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFont::SpacingType)0
          ;
        }
        return 
        (QFont::SpacingType)
      v.toInt();
      }

      bool RJSHelper::is_QFont_SpacingType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFont_Stretch(RJSApi& handler, QFont::Stretch v) {
        return QJSValue(v);
      }

      QFont::Stretch RJSHelper::js2cpp_QFont_Stretch(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFont::Stretch)0
          ;
        }
        return 
        (QFont::Stretch)
      v.toInt();
      }

      bool RJSHelper::is_QFont_Stretch(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFont_Style(RJSApi& handler, QFont::Style v) {
        return QJSValue(v);
      }

      QFont::Style RJSHelper::js2cpp_QFont_Style(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFont::Style)0
          ;
        }
        return 
        (QFont::Style)
      v.toInt();
      }

      bool RJSHelper::is_QFont_Style(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFont_StyleHint(RJSApi& handler, QFont::StyleHint v) {
        return QJSValue(v);
      }

      QFont::StyleHint RJSHelper::js2cpp_QFont_StyleHint(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFont::StyleHint)0
          ;
        }
        return 
        (QFont::StyleHint)
      v.toInt();
      }

      bool RJSHelper::is_QFont_StyleHint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFont_StyleStrategy(RJSApi& handler, QFont::StyleStrategy v) {
        return QJSValue(v);
      }

      QFont::StyleStrategy RJSHelper::js2cpp_QFont_StyleStrategy(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFont::StyleStrategy)0
          ;
        }
        return 
        (QFont::StyleStrategy)
      v.toInt();
      }

      bool RJSHelper::is_QFont_StyleStrategy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFont_Weight(RJSApi& handler, QFont::Weight v) {
        return QJSValue(v);
      }

      QFont::Weight RJSHelper::js2cpp_QFont_Weight(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFont::Weight)0
          ;
        }
        return 
        (QFont::Weight)
      v.toInt();
      }

      bool RJSHelper::is_QFont_Weight(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFontComboBox_FontFilter(RJSApi& handler, QFontComboBox::FontFilter v) {
        return QJSValue(v);
      }

      QFontComboBox::FontFilter RJSHelper::js2cpp_QFontComboBox_FontFilter(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFontComboBox::FontFilter)0
          ;
        }
        return 
        (QFontComboBox::FontFilter)
      v.toInt();
      }

      bool RJSHelper::is_QFontComboBox_FontFilter(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFontDatabase_SystemFont(RJSApi& handler, QFontDatabase::SystemFont v) {
        return QJSValue(v);
      }

      QFontDatabase::SystemFont RJSHelper::js2cpp_QFontDatabase_SystemFont(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFontDatabase::SystemFont)0
          ;
        }
        return 
        (QFontDatabase::SystemFont)
      v.toInt();
      }

      bool RJSHelper::is_QFontDatabase_SystemFont(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFontDatabase_WritingSystem(RJSApi& handler, QFontDatabase::WritingSystem v) {
        return QJSValue(v);
      }

      QFontDatabase::WritingSystem RJSHelper::js2cpp_QFontDatabase_WritingSystem(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFontDatabase::WritingSystem)0
          ;
        }
        return 
        (QFontDatabase::WritingSystem)
      v.toInt();
      }

      bool RJSHelper::is_QFontDatabase_WritingSystem(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFormLayout_FieldGrowthPolicy(RJSApi& handler, QFormLayout::FieldGrowthPolicy v) {
        return QJSValue(v);
      }

      QFormLayout::FieldGrowthPolicy RJSHelper::js2cpp_QFormLayout_FieldGrowthPolicy(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFormLayout::FieldGrowthPolicy)0
          ;
        }
        return 
        (QFormLayout::FieldGrowthPolicy)
      v.toInt();
      }

      bool RJSHelper::is_QFormLayout_FieldGrowthPolicy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFormLayout_ItemRole(RJSApi& handler, QFormLayout::ItemRole v) {
        return QJSValue(v);
      }

      QFormLayout::ItemRole RJSHelper::js2cpp_QFormLayout_ItemRole(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFormLayout::ItemRole)0
          ;
        }
        return 
        (QFormLayout::ItemRole)
      v.toInt();
      }

      bool RJSHelper::is_QFormLayout_ItemRole(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFormLayout_RowWrapPolicy(RJSApi& handler, QFormLayout::RowWrapPolicy v) {
        return QJSValue(v);
      }

      QFormLayout::RowWrapPolicy RJSHelper::js2cpp_QFormLayout_RowWrapPolicy(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFormLayout::RowWrapPolicy)0
          ;
        }
        return 
        (QFormLayout::RowWrapPolicy)
      v.toInt();
      }

      bool RJSHelper::is_QFormLayout_RowWrapPolicy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFrame_Shadow(RJSApi& handler, QFrame::Shadow v) {
        return QJSValue(v);
      }

      QFrame::Shadow RJSHelper::js2cpp_QFrame_Shadow(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFrame::Shadow)0
          ;
        }
        return 
        (QFrame::Shadow)
      v.toInt();
      }

      bool RJSHelper::is_QFrame_Shadow(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QFrame_Shape(RJSApi& handler, QFrame::Shape v) {
        return QJSValue(v);
      }

      QFrame::Shape RJSHelper::js2cpp_QFrame_Shape(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QFrame::Shape)0
          ;
        }
        return 
        (QFrame::Shape)
      v.toInt();
      }

      bool RJSHelper::is_QFrame_Shape(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QGesture_GestureCancelPolicy(RJSApi& handler, QGesture::GestureCancelPolicy v) {
        return QJSValue(v);
      }

      QGesture::GestureCancelPolicy RJSHelper::js2cpp_QGesture_GestureCancelPolicy(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QGesture::GestureCancelPolicy)0
          ;
        }
        return 
        (QGesture::GestureCancelPolicy)
      v.toInt();
      }

      bool RJSHelper::is_QGesture_GestureCancelPolicy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QGradient_CoordinateMode(RJSApi& handler, QGradient::CoordinateMode v) {
        return QJSValue(v);
      }

      QGradient::CoordinateMode RJSHelper::js2cpp_QGradient_CoordinateMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QGradient::CoordinateMode)0
          ;
        }
        return 
        (QGradient::CoordinateMode)
      v.toInt();
      }

      bool RJSHelper::is_QGradient_CoordinateMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QGradient_InterpolationMode(RJSApi& handler, QGradient::InterpolationMode v) {
        return QJSValue(v);
      }

      QGradient::InterpolationMode RJSHelper::js2cpp_QGradient_InterpolationMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QGradient::InterpolationMode)0
          ;
        }
        return 
        (QGradient::InterpolationMode)
      v.toInt();
      }

      bool RJSHelper::is_QGradient_InterpolationMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QGradient_Preset(RJSApi& handler, QGradient::Preset v) {
        return QJSValue(v);
      }

      QGradient::Preset RJSHelper::js2cpp_QGradient_Preset(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QGradient::Preset)0
          ;
        }
        return 
        (QGradient::Preset)
      v.toInt();
      }

      bool RJSHelper::is_QGradient_Preset(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QGradient_Spread(RJSApi& handler, QGradient::Spread v) {
        return QJSValue(v);
      }

      QGradient::Spread RJSHelper::js2cpp_QGradient_Spread(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QGradient::Spread)0
          ;
        }
        return 
        (QGradient::Spread)
      v.toInt();
      }

      bool RJSHelper::is_QGradient_Spread(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QGradient_Type(RJSApi& handler, QGradient::Type v) {
        return QJSValue(v);
      }

      QGradient::Type RJSHelper::js2cpp_QGradient_Type(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QGradient::Type)0
          ;
        }
        return 
        (QGradient::Type)
      v.toInt();
      }

      bool RJSHelper::is_QGradient_Type(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QGraphicsBlurEffect_BlurHint(RJSApi& handler, QGraphicsBlurEffect::BlurHint v) {
        return QJSValue(v);
      }

      QGraphicsBlurEffect::BlurHint RJSHelper::js2cpp_QGraphicsBlurEffect_BlurHint(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QGraphicsBlurEffect::BlurHint)0
          ;
        }
        return 
        (QGraphicsBlurEffect::BlurHint)
      v.toInt();
      }

      bool RJSHelper::is_QGraphicsBlurEffect_BlurHint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QGraphicsEffect_ChangeFlag(RJSApi& handler, QGraphicsEffect::ChangeFlag v) {
        return QJSValue(v);
      }

      QGraphicsEffect::ChangeFlag RJSHelper::js2cpp_QGraphicsEffect_ChangeFlag(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QGraphicsEffect::ChangeFlag)0
          ;
        }
        return 
        (QGraphicsEffect::ChangeFlag)
      v.toInt();
      }

      bool RJSHelper::is_QGraphicsEffect_ChangeFlag(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QGraphicsEffect_PixmapPadMode(RJSApi& handler, QGraphicsEffect::PixmapPadMode v) {
        return QJSValue(v);
      }

      QGraphicsEffect::PixmapPadMode RJSHelper::js2cpp_QGraphicsEffect_PixmapPadMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QGraphicsEffect::PixmapPadMode)0
          ;
        }
        return 
        (QGraphicsEffect::PixmapPadMode)
      v.toInt();
      }

      bool RJSHelper::is_QGraphicsEffect_PixmapPadMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QHeaderView_ResizeMode(RJSApi& handler, QHeaderView::ResizeMode v) {
        return QJSValue(v);
      }

      QHeaderView::ResizeMode RJSHelper::js2cpp_QHeaderView_ResizeMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QHeaderView::ResizeMode)0
          ;
        }
        return 
        (QHeaderView::ResizeMode)
      v.toInt();
      }

      bool RJSHelper::is_QHeaderView_ResizeMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QIODeviceBase_OpenMode(RJSApi& handler, QIODeviceBase::OpenMode v) {
        return QJSValue(v);
      }

      QIODeviceBase::OpenMode RJSHelper::js2cpp_QIODeviceBase_OpenMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QIODeviceBase::OpenMode)0
          ;
        }
        return 
        (QIODeviceBase::OpenMode)
      v.toInt();
      }

      bool RJSHelper::is_QIODeviceBase_OpenMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QIcon_Mode(RJSApi& handler, QIcon::Mode v) {
        return QJSValue(v);
      }

      QIcon::Mode RJSHelper::js2cpp_QIcon_Mode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QIcon::Mode)0
          ;
        }
        return 
        (QIcon::Mode)
      v.toInt();
      }

      bool RJSHelper::is_QIcon_Mode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QIcon_State(RJSApi& handler, QIcon::State v) {
        return QJSValue(v);
      }

      QIcon::State RJSHelper::js2cpp_QIcon_State(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QIcon::State)0
          ;
        }
        return 
        (QIcon::State)
      v.toInt();
      }

      bool RJSHelper::is_QIcon_State(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QImage_Format(RJSApi& handler, QImage::Format v) {
        return QJSValue(v);
      }

      QImage::Format RJSHelper::js2cpp_QImage_Format(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QImage::Format)0
          ;
        }
        return 
        (QImage::Format)
      v.toInt();
      }

      bool RJSHelper::is_QImage_Format(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QImage_InvertMode(RJSApi& handler, QImage::InvertMode v) {
        return QJSValue(v);
      }

      QImage::InvertMode RJSHelper::js2cpp_QImage_InvertMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QImage::InvertMode)0
          ;
        }
        return 
        (QImage::InvertMode)
      v.toInt();
      }

      bool RJSHelper::is_QImage_InvertMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QImageIOHandler_ImageOption(RJSApi& handler, QImageIOHandler::ImageOption v) {
        return QJSValue(v);
      }

      QImageIOHandler::ImageOption RJSHelper::js2cpp_QImageIOHandler_ImageOption(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QImageIOHandler::ImageOption)0
          ;
        }
        return 
        (QImageIOHandler::ImageOption)
      v.toInt();
      }

      bool RJSHelper::is_QImageIOHandler_ImageOption(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QImageIOHandler_Transformations(RJSApi& handler, QImageIOHandler::Transformations v) {
        return QJSValue(v);
      }

      QImageIOHandler::Transformations RJSHelper::js2cpp_QImageIOHandler_Transformations(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QImageIOHandler::Transformations)0
          ;
        }
        return 
        (QImageIOHandler::Transformations)
      v.toInt();
      }

      bool RJSHelper::is_QImageIOHandler_Transformations(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QImageReader_ImageReaderError(RJSApi& handler, QImageReader::ImageReaderError v) {
        return QJSValue(v);
      }

      QImageReader::ImageReaderError RJSHelper::js2cpp_QImageReader_ImageReaderError(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QImageReader::ImageReaderError)0
          ;
        }
        return 
        (QImageReader::ImageReaderError)
      v.toInt();
      }

      bool RJSHelper::is_QImageReader_ImageReaderError(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QImageWriter_ImageWriterError(RJSApi& handler, QImageWriter::ImageWriterError v) {
        return QJSValue(v);
      }

      QImageWriter::ImageWriterError RJSHelper::js2cpp_QImageWriter_ImageWriterError(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QImageWriter::ImageWriterError)0
          ;
        }
        return 
        (QImageWriter::ImageWriterError)
      v.toInt();
      }

      bool RJSHelper::is_QImageWriter_ImageWriterError(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QItemSelectionModel_SelectionFlag(RJSApi& handler, QItemSelectionModel::SelectionFlag v) {
        return QJSValue(v);
      }

      QItemSelectionModel::SelectionFlag RJSHelper::js2cpp_QItemSelectionModel_SelectionFlag(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QItemSelectionModel::SelectionFlag)0
          ;
        }
        return 
        (QItemSelectionModel::SelectionFlag)
      v.toInt();
      }

      bool RJSHelper::is_QItemSelectionModel_SelectionFlag(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QKeySequence_SequenceFormat(RJSApi& handler, QKeySequence::SequenceFormat v) {
        return QJSValue(v);
      }

      QKeySequence::SequenceFormat RJSHelper::js2cpp_QKeySequence_SequenceFormat(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QKeySequence::SequenceFormat)0
          ;
        }
        return 
        (QKeySequence::SequenceFormat)
      v.toInt();
      }

      bool RJSHelper::is_QKeySequence_SequenceFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QKeySequence_SequenceMatch(RJSApi& handler, QKeySequence::SequenceMatch v) {
        return QJSValue(v);
      }

      QKeySequence::SequenceMatch RJSHelper::js2cpp_QKeySequence_SequenceMatch(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QKeySequence::SequenceMatch)0
          ;
        }
        return 
        (QKeySequence::SequenceMatch)
      v.toInt();
      }

      bool RJSHelper::is_QKeySequence_SequenceMatch(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QKeySequence_StandardKey(RJSApi& handler, QKeySequence::StandardKey v) {
        return QJSValue(v);
      }

      QKeySequence::StandardKey RJSHelper::js2cpp_QKeySequence_StandardKey(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QKeySequence::StandardKey)0
          ;
        }
        return 
        (QKeySequence::StandardKey)
      v.toInt();
      }

      bool RJSHelper::is_QKeySequence_StandardKey(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QLayout_SizeConstraint(RJSApi& handler, QLayout::SizeConstraint v) {
        return QJSValue(v);
      }

      QLayout::SizeConstraint RJSHelper::js2cpp_QLayout_SizeConstraint(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QLayout::SizeConstraint)0
          ;
        }
        return 
        (QLayout::SizeConstraint)
      v.toInt();
      }

      bool RJSHelper::is_QLayout_SizeConstraint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QLineEdit_ActionPosition(RJSApi& handler, QLineEdit::ActionPosition v) {
        return QJSValue(v);
      }

      QLineEdit::ActionPosition RJSHelper::js2cpp_QLineEdit_ActionPosition(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QLineEdit::ActionPosition)0
          ;
        }
        return 
        (QLineEdit::ActionPosition)
      v.toInt();
      }

      bool RJSHelper::is_QLineEdit_ActionPosition(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QLineEdit_EchoMode(RJSApi& handler, QLineEdit::EchoMode v) {
        return QJSValue(v);
      }

      QLineEdit::EchoMode RJSHelper::js2cpp_QLineEdit_EchoMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QLineEdit::EchoMode)0
          ;
        }
        return 
        (QLineEdit::EchoMode)
      v.toInt();
      }

      bool RJSHelper::is_QLineEdit_EchoMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QListView_Flow(RJSApi& handler, QListView::Flow v) {
        return QJSValue(v);
      }

      QListView::Flow RJSHelper::js2cpp_QListView_Flow(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QListView::Flow)0
          ;
        }
        return 
        (QListView::Flow)
      v.toInt();
      }

      bool RJSHelper::is_QListView_Flow(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QListView_LayoutMode(RJSApi& handler, QListView::LayoutMode v) {
        return QJSValue(v);
      }

      QListView::LayoutMode RJSHelper::js2cpp_QListView_LayoutMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QListView::LayoutMode)0
          ;
        }
        return 
        (QListView::LayoutMode)
      v.toInt();
      }

      bool RJSHelper::is_QListView_LayoutMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QListView_Movement(RJSApi& handler, QListView::Movement v) {
        return QJSValue(v);
      }

      QListView::Movement RJSHelper::js2cpp_QListView_Movement(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QListView::Movement)0
          ;
        }
        return 
        (QListView::Movement)
      v.toInt();
      }

      bool RJSHelper::is_QListView_Movement(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QListView_ResizeMode(RJSApi& handler, QListView::ResizeMode v) {
        return QJSValue(v);
      }

      QListView::ResizeMode RJSHelper::js2cpp_QListView_ResizeMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QListView::ResizeMode)0
          ;
        }
        return 
        (QListView::ResizeMode)
      v.toInt();
      }

      bool RJSHelper::is_QListView_ResizeMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QListView_ViewMode(RJSApi& handler, QListView::ViewMode v) {
        return QJSValue(v);
      }

      QListView::ViewMode RJSHelper::js2cpp_QListView_ViewMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QListView::ViewMode)0
          ;
        }
        return 
        (QListView::ViewMode)
      v.toInt();
      }

      bool RJSHelper::is_QListView_ViewMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QLocale_Country(RJSApi& handler, QLocale::Country v) {
        return QJSValue(v);
      }

      QLocale::Country RJSHelper::js2cpp_QLocale_Country(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QLocale::Country)0
          ;
        }
        return 
        (QLocale::Country)
      v.toInt();
      }

      bool RJSHelper::is_QLocale_Country(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QLocale_CurrencySymbolFormat(RJSApi& handler, QLocale::CurrencySymbolFormat v) {
        return QJSValue(v);
      }

      QLocale::CurrencySymbolFormat RJSHelper::js2cpp_QLocale_CurrencySymbolFormat(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QLocale::CurrencySymbolFormat)0
          ;
        }
        return 
        (QLocale::CurrencySymbolFormat)
      v.toInt();
      }

      bool RJSHelper::is_QLocale_CurrencySymbolFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QLocale_FormatType(RJSApi& handler, QLocale::FormatType v) {
        return QJSValue(v);
      }

      QLocale::FormatType RJSHelper::js2cpp_QLocale_FormatType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QLocale::FormatType)0
          ;
        }
        return 
        (QLocale::FormatType)
      v.toInt();
      }

      bool RJSHelper::is_QLocale_FormatType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QLocale_Language(RJSApi& handler, QLocale::Language v) {
        return QJSValue(v);
      }

      QLocale::Language RJSHelper::js2cpp_QLocale_Language(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QLocale::Language)0
          ;
        }
        return 
        (QLocale::Language)
      v.toInt();
      }

      bool RJSHelper::is_QLocale_Language(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QLocale_MeasurementSystem(RJSApi& handler, QLocale::MeasurementSystem v) {
        return QJSValue(v);
      }

      QLocale::MeasurementSystem RJSHelper::js2cpp_QLocale_MeasurementSystem(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QLocale::MeasurementSystem)0
          ;
        }
        return 
        (QLocale::MeasurementSystem)
      v.toInt();
      }

      bool RJSHelper::is_QLocale_MeasurementSystem(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QLocale_NumberOptions(RJSApi& handler, QLocale::NumberOptions v) {
        return QJSValue(v);
      }

      QLocale::NumberOptions RJSHelper::js2cpp_QLocale_NumberOptions(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QLocale::NumberOptions)0
          ;
        }
        return 
        (QLocale::NumberOptions)
      v.toInt();
      }

      bool RJSHelper::is_QLocale_NumberOptions(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QLocale_QuotationStyle(RJSApi& handler, QLocale::QuotationStyle v) {
        return QJSValue(v);
      }

      QLocale::QuotationStyle RJSHelper::js2cpp_QLocale_QuotationStyle(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QLocale::QuotationStyle)0
          ;
        }
        return 
        (QLocale::QuotationStyle)
      v.toInt();
      }

      bool RJSHelper::is_QLocale_QuotationStyle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QLocale_Script(RJSApi& handler, QLocale::Script v) {
        return QJSValue(v);
      }

      QLocale::Script RJSHelper::js2cpp_QLocale_Script(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QLocale::Script)0
          ;
        }
        return 
        (QLocale::Script)
      v.toInt();
      }

      bool RJSHelper::is_QLocale_Script(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QLocale_Territory(RJSApi& handler, QLocale::Territory v) {
        return QJSValue(v);
      }

      QLocale::Territory RJSHelper::js2cpp_QLocale_Territory(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QLocale::Territory)0
          ;
        }
        return 
        (QLocale::Territory)
      v.toInt();
      }

      bool RJSHelper::is_QLocale_Territory(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QMainWindow_DockOptions(RJSApi& handler, QMainWindow::DockOptions v) {
        return QJSValue(v);
      }

      QMainWindow::DockOptions RJSHelper::js2cpp_QMainWindow_DockOptions(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QMainWindow::DockOptions)0
          ;
        }
        return 
        (QMainWindow::DockOptions)
      v.toInt();
      }

      bool RJSHelper::is_QMainWindow_DockOptions(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QMdiArea_AreaOption(RJSApi& handler, QMdiArea::AreaOption v) {
        return QJSValue(v);
      }

      QMdiArea::AreaOption RJSHelper::js2cpp_QMdiArea_AreaOption(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QMdiArea::AreaOption)0
          ;
        }
        return 
        (QMdiArea::AreaOption)
      v.toInt();
      }

      bool RJSHelper::is_QMdiArea_AreaOption(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QMdiArea_ViewMode(RJSApi& handler, QMdiArea::ViewMode v) {
        return QJSValue(v);
      }

      QMdiArea::ViewMode RJSHelper::js2cpp_QMdiArea_ViewMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QMdiArea::ViewMode)0
          ;
        }
        return 
        (QMdiArea::ViewMode)
      v.toInt();
      }

      bool RJSHelper::is_QMdiArea_ViewMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QMdiArea_WindowOrder(RJSApi& handler, QMdiArea::WindowOrder v) {
        return QJSValue(v);
      }

      QMdiArea::WindowOrder RJSHelper::js2cpp_QMdiArea_WindowOrder(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QMdiArea::WindowOrder)0
          ;
        }
        return 
        (QMdiArea::WindowOrder)
      v.toInt();
      }

      bool RJSHelper::is_QMdiArea_WindowOrder(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QMdiSubWindow_SubWindowOption(RJSApi& handler, QMdiSubWindow::SubWindowOption v) {
        return QJSValue(v);
      }

      QMdiSubWindow::SubWindowOption RJSHelper::js2cpp_QMdiSubWindow_SubWindowOption(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QMdiSubWindow::SubWindowOption)0
          ;
        }
        return 
        (QMdiSubWindow::SubWindowOption)
      v.toInt();
      }

      bool RJSHelper::is_QMdiSubWindow_SubWindowOption(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QMessageBox_ButtonRole(RJSApi& handler, QMessageBox::ButtonRole v) {
        return QJSValue(v);
      }

      QMessageBox::ButtonRole RJSHelper::js2cpp_QMessageBox_ButtonRole(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QMessageBox::ButtonRole)0
          ;
        }
        return 
        (QMessageBox::ButtonRole)
      v.toInt();
      }

      bool RJSHelper::is_QMessageBox_ButtonRole(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QMessageBox_Icon(RJSApi& handler, QMessageBox::Icon v) {
        return QJSValue(v);
      }

      QMessageBox::Icon RJSHelper::js2cpp_QMessageBox_Icon(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QMessageBox::Icon)0
          ;
        }
        return 
        (QMessageBox::Icon)
      v.toInt();
      }

      bool RJSHelper::is_QMessageBox_Icon(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QMessageBox_StandardButton(RJSApi& handler, QMessageBox::StandardButton v) {
        return QJSValue(v);
      }

      QMessageBox::StandardButton RJSHelper::js2cpp_QMessageBox_StandardButton(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QMessageBox::StandardButton)0
          ;
        }
        return 
        (QMessageBox::StandardButton)
      v.toInt();
      }

      bool RJSHelper::is_QMessageBox_StandardButton(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QMetaType_Type(RJSApi& handler, QMetaType::Type v) {
        return QJSValue(v);
      }

      QMetaType::Type RJSHelper::js2cpp_QMetaType_Type(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QMetaType::Type)0
          ;
        }
        return 
        (QMetaType::Type)
      v.toInt();
      }

      bool RJSHelper::is_QMetaType_Type(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPageLayout_Mode(RJSApi& handler, QPageLayout::Mode v) {
        return QJSValue(v);
      }

      QPageLayout::Mode RJSHelper::js2cpp_QPageLayout_Mode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPageLayout::Mode)0
          ;
        }
        return 
        (QPageLayout::Mode)
      v.toInt();
      }

      bool RJSHelper::is_QPageLayout_Mode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPageLayout_Orientation(RJSApi& handler, QPageLayout::Orientation v) {
        return QJSValue(v);
      }

      QPageLayout::Orientation RJSHelper::js2cpp_QPageLayout_Orientation(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPageLayout::Orientation)0
          ;
        }
        return 
        (QPageLayout::Orientation)
      v.toInt();
      }

      bool RJSHelper::is_QPageLayout_Orientation(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPageLayout_Unit(RJSApi& handler, QPageLayout::Unit v) {
        return QJSValue(v);
      }

      QPageLayout::Unit RJSHelper::js2cpp_QPageLayout_Unit(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPageLayout::Unit)0
          ;
        }
        return 
        (QPageLayout::Unit)
      v.toInt();
      }

      bool RJSHelper::is_QPageLayout_Unit(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPageSize_PageSizeId(RJSApi& handler, QPageSize::PageSizeId v) {
        return QJSValue(v);
      }

      QPageSize::PageSizeId RJSHelper::js2cpp_QPageSize_PageSizeId(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPageSize::PageSizeId)0
          ;
        }
        return 
        (QPageSize::PageSizeId)
      v.toInt();
      }

      bool RJSHelper::is_QPageSize_PageSizeId(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPageSize_SizeMatchPolicy(RJSApi& handler, QPageSize::SizeMatchPolicy v) {
        return QJSValue(v);
      }

      QPageSize::SizeMatchPolicy RJSHelper::js2cpp_QPageSize_SizeMatchPolicy(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPageSize::SizeMatchPolicy)0
          ;
        }
        return 
        (QPageSize::SizeMatchPolicy)
      v.toInt();
      }

      bool RJSHelper::is_QPageSize_SizeMatchPolicy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPageSize_Unit(RJSApi& handler, QPageSize::Unit v) {
        return QJSValue(v);
      }

      QPageSize::Unit RJSHelper::js2cpp_QPageSize_Unit(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPageSize::Unit)0
          ;
        }
        return 
        (QPageSize::Unit)
      v.toInt();
      }

      bool RJSHelper::is_QPageSize_Unit(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPagedPaintDevice_PdfVersion(RJSApi& handler, QPagedPaintDevice::PdfVersion v) {
        return QJSValue(v);
      }

      QPagedPaintDevice::PdfVersion RJSHelper::js2cpp_QPagedPaintDevice_PdfVersion(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPagedPaintDevice::PdfVersion)0
          ;
        }
        return 
        (QPagedPaintDevice::PdfVersion)
      v.toInt();
      }

      bool RJSHelper::is_QPagedPaintDevice_PdfVersion(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPainter_CompositionMode(RJSApi& handler, QPainter::CompositionMode v) {
        return QJSValue(v);
      }

      QPainter::CompositionMode RJSHelper::js2cpp_QPainter_CompositionMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPainter::CompositionMode)0
          ;
        }
        return 
        (QPainter::CompositionMode)
      v.toInt();
      }

      bool RJSHelper::is_QPainter_CompositionMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPainter_PixmapFragmentHint(RJSApi& handler, QPainter::PixmapFragmentHint v) {
        return QJSValue(v);
      }

      QPainter::PixmapFragmentHint RJSHelper::js2cpp_QPainter_PixmapFragmentHint(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPainter::PixmapFragmentHint)0
          ;
        }
        return 
        (QPainter::PixmapFragmentHint)
      v.toInt();
      }

      bool RJSHelper::is_QPainter_PixmapFragmentHint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPainter_RenderHint(RJSApi& handler, QPainter::RenderHint v) {
        return QJSValue(v);
      }

      QPainter::RenderHint RJSHelper::js2cpp_QPainter_RenderHint(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPainter::RenderHint)0
          ;
        }
        return 
        (QPainter::RenderHint)
      v.toInt();
      }

      bool RJSHelper::is_QPainter_RenderHint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPainter_RenderHints(RJSApi& handler, QPainter::RenderHints v) {
        return QJSValue(v);
      }

      QPainter::RenderHints RJSHelper::js2cpp_QPainter_RenderHints(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPainter::RenderHints)0
          ;
        }
        return 
        (QPainter::RenderHints)
      v.toInt();
      }

      bool RJSHelper::is_QPainter_RenderHints(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPainterPath_ElementType(RJSApi& handler, QPainterPath::ElementType v) {
        return QJSValue(v);
      }

      QPainterPath::ElementType RJSHelper::js2cpp_QPainterPath_ElementType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPainterPath::ElementType)0
          ;
        }
        return 
        (QPainterPath::ElementType)
      v.toInt();
      }

      bool RJSHelper::is_QPainterPath_ElementType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPalette_ColorGroup(RJSApi& handler, QPalette::ColorGroup v) {
        return QJSValue(v);
      }

      QPalette::ColorGroup RJSHelper::js2cpp_QPalette_ColorGroup(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPalette::ColorGroup)0
          ;
        }
        return 
        (QPalette::ColorGroup)
      v.toInt();
      }

      bool RJSHelper::is_QPalette_ColorGroup(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPalette_ColorRole(RJSApi& handler, QPalette::ColorRole v) {
        return QJSValue(v);
      }

      QPalette::ColorRole RJSHelper::js2cpp_QPalette_ColorRole(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPalette::ColorRole)0
          ;
        }
        return 
        (QPalette::ColorRole)
      v.toInt();
      }

      bool RJSHelper::is_QPalette_ColorRole(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPinchGesture_ChangeFlag(RJSApi& handler, QPinchGesture::ChangeFlag v) {
        return QJSValue(v);
      }

      QPinchGesture::ChangeFlag RJSHelper::js2cpp_QPinchGesture_ChangeFlag(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPinchGesture::ChangeFlag)0
          ;
        }
        return 
        (QPinchGesture::ChangeFlag)
      v.toInt();
      }

      bool RJSHelper::is_QPinchGesture_ChangeFlag(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPlainTextEdit_LineWrapMode(RJSApi& handler, QPlainTextEdit::LineWrapMode v) {
        return QJSValue(v);
      }

      QPlainTextEdit::LineWrapMode RJSHelper::js2cpp_QPlainTextEdit_LineWrapMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPlainTextEdit::LineWrapMode)0
          ;
        }
        return 
        (QPlainTextEdit::LineWrapMode)
      v.toInt();
      }

      bool RJSHelper::is_QPlainTextEdit_LineWrapMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPrinter_ColorMode(RJSApi& handler, QPrinter::ColorMode v) {
        return QJSValue(v);
      }

      QPrinter::ColorMode RJSHelper::js2cpp_QPrinter_ColorMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPrinter::ColorMode)0
          ;
        }
        return 
        (QPrinter::ColorMode)
      v.toInt();
      }

      bool RJSHelper::is_QPrinter_ColorMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPrinter_DuplexMode(RJSApi& handler, QPrinter::DuplexMode v) {
        return QJSValue(v);
      }

      QPrinter::DuplexMode RJSHelper::js2cpp_QPrinter_DuplexMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPrinter::DuplexMode)0
          ;
        }
        return 
        (QPrinter::DuplexMode)
      v.toInt();
      }

      bool RJSHelper::is_QPrinter_DuplexMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPrinter_OutputFormat(RJSApi& handler, QPrinter::OutputFormat v) {
        return QJSValue(v);
      }

      QPrinter::OutputFormat RJSHelper::js2cpp_QPrinter_OutputFormat(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPrinter::OutputFormat)0
          ;
        }
        return 
        (QPrinter::OutputFormat)
      v.toInt();
      }

      bool RJSHelper::is_QPrinter_OutputFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPrinter_PageOrder(RJSApi& handler, QPrinter::PageOrder v) {
        return QJSValue(v);
      }

      QPrinter::PageOrder RJSHelper::js2cpp_QPrinter_PageOrder(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPrinter::PageOrder)0
          ;
        }
        return 
        (QPrinter::PageOrder)
      v.toInt();
      }

      bool RJSHelper::is_QPrinter_PageOrder(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPrinter_PaperSource(RJSApi& handler, QPrinter::PaperSource v) {
        return QJSValue(v);
      }

      QPrinter::PaperSource RJSHelper::js2cpp_QPrinter_PaperSource(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPrinter::PaperSource)0
          ;
        }
        return 
        (QPrinter::PaperSource)
      v.toInt();
      }

      bool RJSHelper::is_QPrinter_PaperSource(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPrinter_PrintRange(RJSApi& handler, QPrinter::PrintRange v) {
        return QJSValue(v);
      }

      QPrinter::PrintRange RJSHelper::js2cpp_QPrinter_PrintRange(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPrinter::PrintRange)0
          ;
        }
        return 
        (QPrinter::PrintRange)
      v.toInt();
      }

      bool RJSHelper::is_QPrinter_PrintRange(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPrinter_PrinterMode(RJSApi& handler, QPrinter::PrinterMode v) {
        return QJSValue(v);
      }

      QPrinter::PrinterMode RJSHelper::js2cpp_QPrinter_PrinterMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPrinter::PrinterMode)0
          ;
        }
        return 
        (QPrinter::PrinterMode)
      v.toInt();
      }

      bool RJSHelper::is_QPrinter_PrinterMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPrinter_PrinterState(RJSApi& handler, QPrinter::PrinterState v) {
        return QJSValue(v);
      }

      QPrinter::PrinterState RJSHelper::js2cpp_QPrinter_PrinterState(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPrinter::PrinterState)0
          ;
        }
        return 
        (QPrinter::PrinterState)
      v.toInt();
      }

      bool RJSHelper::is_QPrinter_PrinterState(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QPrinter_Unit(RJSApi& handler, QPrinter::Unit v) {
        return QJSValue(v);
      }

      QPrinter::Unit RJSHelper::js2cpp_QPrinter_Unit(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QPrinter::Unit)0
          ;
        }
        return 
        (QPrinter::Unit)
      v.toInt();
      }

      bool RJSHelper::is_QPrinter_Unit(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QProcess_ExitStatus(RJSApi& handler, QProcess::ExitStatus v) {
        return QJSValue(v);
      }

      QProcess::ExitStatus RJSHelper::js2cpp_QProcess_ExitStatus(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QProcess::ExitStatus)0
          ;
        }
        return 
        (QProcess::ExitStatus)
      v.toInt();
      }

      bool RJSHelper::is_QProcess_ExitStatus(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QProcess_InputChannelMode(RJSApi& handler, QProcess::InputChannelMode v) {
        return QJSValue(v);
      }

      QProcess::InputChannelMode RJSHelper::js2cpp_QProcess_InputChannelMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QProcess::InputChannelMode)0
          ;
        }
        return 
        (QProcess::InputChannelMode)
      v.toInt();
      }

      bool RJSHelper::is_QProcess_InputChannelMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QProcess_ProcessChannel(RJSApi& handler, QProcess::ProcessChannel v) {
        return QJSValue(v);
      }

      QProcess::ProcessChannel RJSHelper::js2cpp_QProcess_ProcessChannel(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QProcess::ProcessChannel)0
          ;
        }
        return 
        (QProcess::ProcessChannel)
      v.toInt();
      }

      bool RJSHelper::is_QProcess_ProcessChannel(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QProcess_ProcessChannelMode(RJSApi& handler, QProcess::ProcessChannelMode v) {
        return QJSValue(v);
      }

      QProcess::ProcessChannelMode RJSHelper::js2cpp_QProcess_ProcessChannelMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QProcess::ProcessChannelMode)0
          ;
        }
        return 
        (QProcess::ProcessChannelMode)
      v.toInt();
      }

      bool RJSHelper::is_QProcess_ProcessChannelMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QProcess_ProcessError(RJSApi& handler, QProcess::ProcessError v) {
        return QJSValue(v);
      }

      QProcess::ProcessError RJSHelper::js2cpp_QProcess_ProcessError(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QProcess::ProcessError)0
          ;
        }
        return 
        (QProcess::ProcessError)
      v.toInt();
      }

      bool RJSHelper::is_QProcess_ProcessError(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QProcess_ProcessState(RJSApi& handler, QProcess::ProcessState v) {
        return QJSValue(v);
      }

      QProcess::ProcessState RJSHelper::js2cpp_QProcess_ProcessState(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QProcess::ProcessState)0
          ;
        }
        return 
        (QProcess::ProcessState)
      v.toInt();
      }

      bool RJSHelper::is_QProcess_ProcessState(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QProcessEnvironment_Initialization(RJSApi& handler, QProcessEnvironment::Initialization v) {
        return QJSValue(v);
      }

      QProcessEnvironment::Initialization RJSHelper::js2cpp_QProcessEnvironment_Initialization(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QProcessEnvironment::Initialization)0
          ;
        }
        return 
        (QProcessEnvironment::Initialization)
      v.toInt();
      }

      bool RJSHelper::is_QProcessEnvironment_Initialization(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QProgressBar_Direction(RJSApi& handler, QProgressBar::Direction v) {
        return QJSValue(v);
      }

      QProgressBar::Direction RJSHelper::js2cpp_QProgressBar_Direction(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QProgressBar::Direction)0
          ;
        }
        return 
        (QProgressBar::Direction)
      v.toInt();
      }

      bool RJSHelper::is_QProgressBar_Direction(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QQuickView_ResizeMode(RJSApi& handler, QQuickView::ResizeMode v) {
        return QJSValue(v);
      }

      QQuickView::ResizeMode RJSHelper::js2cpp_QQuickView_ResizeMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QQuickView::ResizeMode)0
          ;
        }
        return 
        (QQuickView::ResizeMode)
      v.toInt();
      }

      bool RJSHelper::is_QQuickView_ResizeMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QQuickView_Status(RJSApi& handler, QQuickView::Status v) {
        return QJSValue(v);
      }

      QQuickView::Status RJSHelper::js2cpp_QQuickView_Status(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QQuickView::Status)0
          ;
        }
        return 
        (QQuickView::Status)
      v.toInt();
      }

      bool RJSHelper::is_QQuickView_Status(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QQuickWidget_ResizeMode(RJSApi& handler, QQuickWidget::ResizeMode v) {
        return QJSValue(v);
      }

      QQuickWidget::ResizeMode RJSHelper::js2cpp_QQuickWidget_ResizeMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QQuickWidget::ResizeMode)0
          ;
        }
        return 
        (QQuickWidget::ResizeMode)
      v.toInt();
      }

      bool RJSHelper::is_QQuickWidget_ResizeMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QQuickWidget_Status(RJSApi& handler, QQuickWidget::Status v) {
        return QJSValue(v);
      }

      QQuickWidget::Status RJSHelper::js2cpp_QQuickWidget_Status(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QQuickWidget::Status)0
          ;
        }
        return 
        (QQuickWidget::Status)
      v.toInt();
      }

      bool RJSHelper::is_QQuickWidget_Status(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QRegion_RegionType(RJSApi& handler, QRegion::RegionType v) {
        return QJSValue(v);
      }

      QRegion::RegionType RJSHelper::js2cpp_QRegion_RegionType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QRegion::RegionType)0
          ;
        }
        return 
        (QRegion::RegionType)
      v.toInt();
      }

      bool RJSHelper::is_QRegion_RegionType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QRegularExpression_MatchOptions(RJSApi& handler, QRegularExpression::MatchOptions v) {
        return QJSValue(v);
      }

      QRegularExpression::MatchOptions RJSHelper::js2cpp_QRegularExpression_MatchOptions(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QRegularExpression::MatchOptions)0
          ;
        }
        return 
        (QRegularExpression::MatchOptions)
      v.toInt();
      }

      bool RJSHelper::is_QRegularExpression_MatchOptions(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QRegularExpression_MatchType(RJSApi& handler, QRegularExpression::MatchType v) {
        return QJSValue(v);
      }

      QRegularExpression::MatchType RJSHelper::js2cpp_QRegularExpression_MatchType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QRegularExpression::MatchType)0
          ;
        }
        return 
        (QRegularExpression::MatchType)
      v.toInt();
      }

      bool RJSHelper::is_QRegularExpression_MatchType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QSettings_Format(RJSApi& handler, QSettings::Format v) {
        return QJSValue(v);
      }

      QSettings::Format RJSHelper::js2cpp_QSettings_Format(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QSettings::Format)0
          ;
        }
        return 
        (QSettings::Format)
      v.toInt();
      }

      bool RJSHelper::is_QSettings_Format(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QSettings_Scope(RJSApi& handler, QSettings::Scope v) {
        return QJSValue(v);
      }

      QSettings::Scope RJSHelper::js2cpp_QSettings_Scope(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QSettings::Scope)0
          ;
        }
        return 
        (QSettings::Scope)
      v.toInt();
      }

      bool RJSHelper::is_QSettings_Scope(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QSettings_Status(RJSApi& handler, QSettings::Status v) {
        return QJSValue(v);
      }

      QSettings::Status RJSHelper::js2cpp_QSettings_Status(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QSettings::Status)0
          ;
        }
        return 
        (QSettings::Status)
      v.toInt();
      }

      bool RJSHelper::is_QSettings_Status(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QSizePolicy_ControlType(RJSApi& handler, QSizePolicy::ControlType v) {
        return QJSValue(v);
      }

      QSizePolicy::ControlType RJSHelper::js2cpp_QSizePolicy_ControlType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QSizePolicy::ControlType)0
          ;
        }
        return 
        (QSizePolicy::ControlType)
      v.toInt();
      }

      bool RJSHelper::is_QSizePolicy_ControlType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QSizePolicy_Policy(RJSApi& handler, QSizePolicy::Policy v) {
        return QJSValue(v);
      }

      QSizePolicy::Policy RJSHelper::js2cpp_QSizePolicy_Policy(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QSizePolicy::Policy)0
          ;
        }
        return 
        (QSizePolicy::Policy)
      v.toInt();
      }

      bool RJSHelper::is_QSizePolicy_Policy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QSlider_TickPosition(RJSApi& handler, QSlider::TickPosition v) {
        return QJSValue(v);
      }

      QSlider::TickPosition RJSHelper::js2cpp_QSlider_TickPosition(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QSlider::TickPosition)0
          ;
        }
        return 
        (QSlider::TickPosition)
      v.toInt();
      }

      bool RJSHelper::is_QSlider_TickPosition(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QStackedLayout_StackingMode(RJSApi& handler, QStackedLayout::StackingMode v) {
        return QJSValue(v);
      }

      QStackedLayout::StackingMode RJSHelper::js2cpp_QStackedLayout_StackingMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QStackedLayout::StackingMode)0
          ;
        }
        return 
        (QStackedLayout::StackingMode)
      v.toInt();
      }

      bool RJSHelper::is_QStackedLayout_StackingMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QString(RJSApi& handler, const QString& v) {
        return QJSValue(v);
      }

      QString RJSHelper::js2cpp_QString(RJSApi& handler, const QJSValue& v) {
        if (!v.isString()) {
          return QString();
        }
        return v.toString();
      }

      bool RJSHelper::is_QString(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isString();
      }
    
      QJSValue RJSHelper::cpp2js_QStringConverter_Encoding(RJSApi& handler, QStringConverter::Encoding v) {
        return QJSValue(v);
      }

      QStringConverter::Encoding RJSHelper::js2cpp_QStringConverter_Encoding(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QStringConverter::Encoding)0
          ;
        }
        return 
        (QStringConverter::Encoding)
      v.toInt();
      }

      bool RJSHelper::is_QStringConverter_Encoding(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QStringView(RJSApi& handler, QStringView v) {
        return QJSValue(v.toString());
      }

      QStringView RJSHelper::js2cpp_QStringView(RJSApi& handler, const QJSValue& v) {
        if (!v.isString()) {
          return QStringView();
        }
        return v.toString();
      }

      bool RJSHelper::is_QStringView(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isString();
      }
    
      QJSValue RJSHelper::cpp2js_QSurfaceFormat_FormatOption(RJSApi& handler, QSurfaceFormat::FormatOption v) {
        return QJSValue(v);
      }

      QSurfaceFormat::FormatOption RJSHelper::js2cpp_QSurfaceFormat_FormatOption(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QSurfaceFormat::FormatOption)0
          ;
        }
        return 
        (QSurfaceFormat::FormatOption)
      v.toInt();
      }

      bool RJSHelper::is_QSurfaceFormat_FormatOption(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QSurfaceFormat_OpenGLContextProfile(RJSApi& handler, QSurfaceFormat::OpenGLContextProfile v) {
        return QJSValue(v);
      }

      QSurfaceFormat::OpenGLContextProfile RJSHelper::js2cpp_QSurfaceFormat_OpenGLContextProfile(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QSurfaceFormat::OpenGLContextProfile)0
          ;
        }
        return 
        (QSurfaceFormat::OpenGLContextProfile)
      v.toInt();
      }

      bool RJSHelper::is_QSurfaceFormat_OpenGLContextProfile(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QSurfaceFormat_RenderableType(RJSApi& handler, QSurfaceFormat::RenderableType v) {
        return QJSValue(v);
      }

      QSurfaceFormat::RenderableType RJSHelper::js2cpp_QSurfaceFormat_RenderableType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QSurfaceFormat::RenderableType)0
          ;
        }
        return 
        (QSurfaceFormat::RenderableType)
      v.toInt();
      }

      bool RJSHelper::is_QSurfaceFormat_RenderableType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QSurfaceFormat_SwapBehavior(RJSApi& handler, QSurfaceFormat::SwapBehavior v) {
        return QJSValue(v);
      }

      QSurfaceFormat::SwapBehavior RJSHelper::js2cpp_QSurfaceFormat_SwapBehavior(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QSurfaceFormat::SwapBehavior)0
          ;
        }
        return 
        (QSurfaceFormat::SwapBehavior)
      v.toInt();
      }

      bool RJSHelper::is_QSurfaceFormat_SwapBehavior(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QSwipeGesture_SwipeDirection(RJSApi& handler, QSwipeGesture::SwipeDirection v) {
        return QJSValue(v);
      }

      QSwipeGesture::SwipeDirection RJSHelper::js2cpp_QSwipeGesture_SwipeDirection(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QSwipeGesture::SwipeDirection)0
          ;
        }
        return 
        (QSwipeGesture::SwipeDirection)
      v.toInt();
      }

      bool RJSHelper::is_QSwipeGesture_SwipeDirection(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTabBar_ButtonPosition(RJSApi& handler, QTabBar::ButtonPosition v) {
        return QJSValue(v);
      }

      QTabBar::ButtonPosition RJSHelper::js2cpp_QTabBar_ButtonPosition(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTabBar::ButtonPosition)0
          ;
        }
        return 
        (QTabBar::ButtonPosition)
      v.toInt();
      }

      bool RJSHelper::is_QTabBar_ButtonPosition(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTabBar_SelectionBehavior(RJSApi& handler, QTabBar::SelectionBehavior v) {
        return QJSValue(v);
      }

      QTabBar::SelectionBehavior RJSHelper::js2cpp_QTabBar_SelectionBehavior(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTabBar::SelectionBehavior)0
          ;
        }
        return 
        (QTabBar::SelectionBehavior)
      v.toInt();
      }

      bool RJSHelper::is_QTabBar_SelectionBehavior(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTabBar_Shape(RJSApi& handler, QTabBar::Shape v) {
        return QJSValue(v);
      }

      QTabBar::Shape RJSHelper::js2cpp_QTabBar_Shape(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTabBar::Shape)0
          ;
        }
        return 
        (QTabBar::Shape)
      v.toInt();
      }

      bool RJSHelper::is_QTabBar_Shape(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTabWidget_TabPosition(RJSApi& handler, QTabWidget::TabPosition v) {
        return QJSValue(v);
      }

      QTabWidget::TabPosition RJSHelper::js2cpp_QTabWidget_TabPosition(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTabWidget::TabPosition)0
          ;
        }
        return 
        (QTabWidget::TabPosition)
      v.toInt();
      }

      bool RJSHelper::is_QTabWidget_TabPosition(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTabWidget_TabShape(RJSApi& handler, QTabWidget::TabShape v) {
        return QJSValue(v);
      }

      QTabWidget::TabShape RJSHelper::js2cpp_QTabWidget_TabShape(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTabWidget::TabShape)0
          ;
        }
        return 
        (QTabWidget::TabShape)
      v.toInt();
      }

      bool RJSHelper::is_QTabWidget_TabShape(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextCharFormat_FontPropertiesInheritanceBehavior(RJSApi& handler, QTextCharFormat::FontPropertiesInheritanceBehavior v) {
        return QJSValue(v);
      }

      QTextCharFormat::FontPropertiesInheritanceBehavior RJSHelper::js2cpp_QTextCharFormat_FontPropertiesInheritanceBehavior(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextCharFormat::FontPropertiesInheritanceBehavior)0
          ;
        }
        return 
        (QTextCharFormat::FontPropertiesInheritanceBehavior)
      v.toInt();
      }

      bool RJSHelper::is_QTextCharFormat_FontPropertiesInheritanceBehavior(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextCharFormat_UnderlineStyle(RJSApi& handler, QTextCharFormat::UnderlineStyle v) {
        return QJSValue(v);
      }

      QTextCharFormat::UnderlineStyle RJSHelper::js2cpp_QTextCharFormat_UnderlineStyle(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextCharFormat::UnderlineStyle)0
          ;
        }
        return 
        (QTextCharFormat::UnderlineStyle)
      v.toInt();
      }

      bool RJSHelper::is_QTextCharFormat_UnderlineStyle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextCharFormat_VerticalAlignment(RJSApi& handler, QTextCharFormat::VerticalAlignment v) {
        return QJSValue(v);
      }

      QTextCharFormat::VerticalAlignment RJSHelper::js2cpp_QTextCharFormat_VerticalAlignment(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextCharFormat::VerticalAlignment)0
          ;
        }
        return 
        (QTextCharFormat::VerticalAlignment)
      v.toInt();
      }

      bool RJSHelper::is_QTextCharFormat_VerticalAlignment(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextCursor_MoveMode(RJSApi& handler, QTextCursor::MoveMode v) {
        return QJSValue(v);
      }

      QTextCursor::MoveMode RJSHelper::js2cpp_QTextCursor_MoveMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextCursor::MoveMode)0
          ;
        }
        return 
        (QTextCursor::MoveMode)
      v.toInt();
      }

      bool RJSHelper::is_QTextCursor_MoveMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextCursor_MoveOperation(RJSApi& handler, QTextCursor::MoveOperation v) {
        return QJSValue(v);
      }

      QTextCursor::MoveOperation RJSHelper::js2cpp_QTextCursor_MoveOperation(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextCursor::MoveOperation)0
          ;
        }
        return 
        (QTextCursor::MoveOperation)
      v.toInt();
      }

      bool RJSHelper::is_QTextCursor_MoveOperation(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextCursor_SelectionType(RJSApi& handler, QTextCursor::SelectionType v) {
        return QJSValue(v);
      }

      QTextCursor::SelectionType RJSHelper::js2cpp_QTextCursor_SelectionType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextCursor::SelectionType)0
          ;
        }
        return 
        (QTextCursor::SelectionType)
      v.toInt();
      }

      bool RJSHelper::is_QTextCursor_SelectionType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextDocument_FindFlag(RJSApi& handler, QTextDocument::FindFlag v) {
        return QJSValue(v);
      }

      QTextDocument::FindFlag RJSHelper::js2cpp_QTextDocument_FindFlag(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextDocument::FindFlag)0
          ;
        }
        return 
        (QTextDocument::FindFlag)
      v.toInt();
      }

      bool RJSHelper::is_QTextDocument_FindFlag(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextDocument_MarkdownFeatures(RJSApi& handler, QTextDocument::MarkdownFeatures v) {
        return QJSValue(v);
      }

      QTextDocument::MarkdownFeatures RJSHelper::js2cpp_QTextDocument_MarkdownFeatures(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextDocument::MarkdownFeatures)0
          ;
        }
        return 
        (QTextDocument::MarkdownFeatures)
      v.toInt();
      }

      bool RJSHelper::is_QTextDocument_MarkdownFeatures(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextDocument_MetaInformation(RJSApi& handler, QTextDocument::MetaInformation v) {
        return QJSValue(v);
      }

      QTextDocument::MetaInformation RJSHelper::js2cpp_QTextDocument_MetaInformation(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextDocument::MetaInformation)0
          ;
        }
        return 
        (QTextDocument::MetaInformation)
      v.toInt();
      }

      bool RJSHelper::is_QTextDocument_MetaInformation(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextDocument_ResourceType(RJSApi& handler, QTextDocument::ResourceType v) {
        return QJSValue(v);
      }

      QTextDocument::ResourceType RJSHelper::js2cpp_QTextDocument_ResourceType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextDocument::ResourceType)0
          ;
        }
        return 
        (QTextDocument::ResourceType)
      v.toInt();
      }

      bool RJSHelper::is_QTextDocument_ResourceType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextDocument_Stacks(RJSApi& handler, QTextDocument::Stacks v) {
        return QJSValue(v);
      }

      QTextDocument::Stacks RJSHelper::js2cpp_QTextDocument_Stacks(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextDocument::Stacks)0
          ;
        }
        return 
        (QTextDocument::Stacks)
      v.toInt();
      }

      bool RJSHelper::is_QTextDocument_Stacks(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextEdit_AutoFormattingFlag(RJSApi& handler, QTextEdit::AutoFormattingFlag v) {
        return QJSValue(v);
      }

      QTextEdit::AutoFormattingFlag RJSHelper::js2cpp_QTextEdit_AutoFormattingFlag(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextEdit::AutoFormattingFlag)0
          ;
        }
        return 
        (QTextEdit::AutoFormattingFlag)
      v.toInt();
      }

      bool RJSHelper::is_QTextEdit_AutoFormattingFlag(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextEdit_LineWrapMode(RJSApi& handler, QTextEdit::LineWrapMode v) {
        return QJSValue(v);
      }

      QTextEdit::LineWrapMode RJSHelper::js2cpp_QTextEdit_LineWrapMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextEdit::LineWrapMode)0
          ;
        }
        return 
        (QTextEdit::LineWrapMode)
      v.toInt();
      }

      bool RJSHelper::is_QTextEdit_LineWrapMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextFrameFormat_BorderStyle(RJSApi& handler, QTextFrameFormat::BorderStyle v) {
        return QJSValue(v);
      }

      QTextFrameFormat::BorderStyle RJSHelper::js2cpp_QTextFrameFormat_BorderStyle(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextFrameFormat::BorderStyle)0
          ;
        }
        return 
        (QTextFrameFormat::BorderStyle)
      v.toInt();
      }

      bool RJSHelper::is_QTextFrameFormat_BorderStyle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextFrameFormat_Position(RJSApi& handler, QTextFrameFormat::Position v) {
        return QJSValue(v);
      }

      QTextFrameFormat::Position RJSHelper::js2cpp_QTextFrameFormat_Position(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextFrameFormat::Position)0
          ;
        }
        return 
        (QTextFrameFormat::Position)
      v.toInt();
      }

      bool RJSHelper::is_QTextFrameFormat_Position(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextLayout_CursorMode(RJSApi& handler, QTextLayout::CursorMode v) {
        return QJSValue(v);
      }

      QTextLayout::CursorMode RJSHelper::js2cpp_QTextLayout_CursorMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextLayout::CursorMode)0
          ;
        }
        return 
        (QTextLayout::CursorMode)
      v.toInt();
      }

      bool RJSHelper::is_QTextLayout_CursorMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextLength_Type(RJSApi& handler, QTextLength::Type v) {
        return QJSValue(v);
      }

      QTextLength::Type RJSHelper::js2cpp_QTextLength_Type(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextLength::Type)0
          ;
        }
        return 
        (QTextLength::Type)
      v.toInt();
      }

      bool RJSHelper::is_QTextLength_Type(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextListFormat_Style(RJSApi& handler, QTextListFormat::Style v) {
        return QJSValue(v);
      }

      QTextListFormat::Style RJSHelper::js2cpp_QTextListFormat_Style(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextListFormat::Style)0
          ;
        }
        return 
        (QTextListFormat::Style)
      v.toInt();
      }

      bool RJSHelper::is_QTextListFormat_Style(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextOption_WrapMode(RJSApi& handler, QTextOption::WrapMode v) {
        return QJSValue(v);
      }

      QTextOption::WrapMode RJSHelper::js2cpp_QTextOption_WrapMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextOption::WrapMode)0
          ;
        }
        return 
        (QTextOption::WrapMode)
      v.toInt();
      }

      bool RJSHelper::is_QTextOption_WrapMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextStream_FieldAlignment(RJSApi& handler, QTextStream::FieldAlignment v) {
        return QJSValue(v);
      }

      QTextStream::FieldAlignment RJSHelper::js2cpp_QTextStream_FieldAlignment(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextStream::FieldAlignment)0
          ;
        }
        return 
        (QTextStream::FieldAlignment)
      v.toInt();
      }

      bool RJSHelper::is_QTextStream_FieldAlignment(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextStream_NumberFlags(RJSApi& handler, QTextStream::NumberFlags v) {
        return QJSValue(v);
      }

      QTextStream::NumberFlags RJSHelper::js2cpp_QTextStream_NumberFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextStream::NumberFlags)0
          ;
        }
        return 
        (QTextStream::NumberFlags)
      v.toInt();
      }

      bool RJSHelper::is_QTextStream_NumberFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextStream_RealNumberNotation(RJSApi& handler, QTextStream::RealNumberNotation v) {
        return QJSValue(v);
      }

      QTextStream::RealNumberNotation RJSHelper::js2cpp_QTextStream_RealNumberNotation(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextStream::RealNumberNotation)0
          ;
        }
        return 
        (QTextStream::RealNumberNotation)
      v.toInt();
      }

      bool RJSHelper::is_QTextStream_RealNumberNotation(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTextStream_Status(RJSApi& handler, QTextStream::Status v) {
        return QJSValue(v);
      }

      QTextStream::Status RJSHelper::js2cpp_QTextStream_Status(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTextStream::Status)0
          ;
        }
        return 
        (QTextStream::Status)
      v.toInt();
      }

      bool RJSHelper::is_QTextStream_Status(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QToolButton_ToolButtonPopupMode(RJSApi& handler, QToolButton::ToolButtonPopupMode v) {
        return QJSValue(v);
      }

      QToolButton::ToolButtonPopupMode RJSHelper::js2cpp_QToolButton_ToolButtonPopupMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QToolButton::ToolButtonPopupMode)0
          ;
        }
        return 
        (QToolButton::ToolButtonPopupMode)
      v.toInt();
      }

      bool RJSHelper::is_QToolButton_ToolButtonPopupMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTransform_TransformationType(RJSApi& handler, QTransform::TransformationType v) {
        return QJSValue(v);
      }

      QTransform::TransformationType RJSHelper::js2cpp_QTransform_TransformationType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTransform::TransformationType)0
          ;
        }
        return 
        (QTransform::TransformationType)
      v.toInt();
      }

      bool RJSHelper::is_QTransform_TransformationType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QTreeWidgetItem_ChildIndicatorPolicy(RJSApi& handler, QTreeWidgetItem::ChildIndicatorPolicy v) {
        return QJSValue(v);
      }

      QTreeWidgetItem::ChildIndicatorPolicy RJSHelper::js2cpp_QTreeWidgetItem_ChildIndicatorPolicy(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QTreeWidgetItem::ChildIndicatorPolicy)0
          ;
        }
        return 
        (QTreeWidgetItem::ChildIndicatorPolicy)
      v.toInt();
      }

      bool RJSHelper::is_QTreeWidgetItem_ChildIndicatorPolicy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QUrl_ComponentFormattingOption(RJSApi& handler, QUrl::ComponentFormattingOption v) {
        return QJSValue(v);
      }

      QUrl::ComponentFormattingOption RJSHelper::js2cpp_QUrl_ComponentFormattingOption(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QUrl::ComponentFormattingOption)0
          ;
        }
        return 
        (QUrl::ComponentFormattingOption)
      v.toInt();
      }

      bool RJSHelper::is_QUrl_ComponentFormattingOption(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QUrl_ParsingMode(RJSApi& handler, QUrl::ParsingMode v) {
        return QJSValue(v);
      }

      QUrl::ParsingMode RJSHelper::js2cpp_QUrl_ParsingMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QUrl::ParsingMode)0
          ;
        }
        return 
        (QUrl::ParsingMode)
      v.toInt();
      }

      bool RJSHelper::is_QUrl_ParsingMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QUrl_UrlFormattingOption(RJSApi& handler, QUrl::UrlFormattingOption v) {
        return QJSValue(v);
      }

      QUrl::UrlFormattingOption RJSHelper::js2cpp_QUrl_UrlFormattingOption(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QUrl::UrlFormattingOption)0
          ;
        }
        return 
        (QUrl::UrlFormattingOption)
      v.toInt();
      }

      bool RJSHelper::is_QUrl_UrlFormattingOption(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QUrl_UserInputResolutionOption(RJSApi& handler, QUrl::UserInputResolutionOption v) {
        return QJSValue(v);
      }

      QUrl::UserInputResolutionOption RJSHelper::js2cpp_QUrl_UserInputResolutionOption(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QUrl::UserInputResolutionOption)0
          ;
        }
        return 
        (QUrl::UserInputResolutionOption)
      v.toInt();
      }

      bool RJSHelper::is_QUrl_UserInputResolutionOption(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QValidator_State(RJSApi& handler, QValidator::State v) {
        return QJSValue(v);
      }

      QValidator::State RJSHelper::js2cpp_QValidator_State(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QValidator::State)0
          ;
        }
        return 
        (QValidator::State)
      v.toInt();
      }

      bool RJSHelper::is_QValidator_State(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QWidget_RenderFlags(RJSApi& handler, QWidget::RenderFlags v) {
        return QJSValue(v);
      }

      QWidget::RenderFlags RJSHelper::js2cpp_QWidget_RenderFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QWidget::RenderFlags)0
          ;
        }
        return 
        (QWidget::RenderFlags)
      v.toInt();
      }

      bool RJSHelper::is_QWidget_RenderFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QWindow_AncestorMode(RJSApi& handler, QWindow::AncestorMode v) {
        return QJSValue(v);
      }

      QWindow::AncestorMode RJSHelper::js2cpp_QWindow_AncestorMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QWindow::AncestorMode)0
          ;
        }
        return 
        (QWindow::AncestorMode)
      v.toInt();
      }

      bool RJSHelper::is_QWindow_AncestorMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QWindow_Visibility(RJSApi& handler, QWindow::Visibility v) {
        return QJSValue(v);
      }

      QWindow::Visibility RJSHelper::js2cpp_QWindow_Visibility(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QWindow::Visibility)0
          ;
        }
        return 
        (QWindow::Visibility)
      v.toInt();
      }

      bool RJSHelper::is_QWindow_Visibility(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlStreamReader_Error(RJSApi& handler, QXmlStreamReader::Error v) {
        return QJSValue(v);
      }

      QXmlStreamReader::Error RJSHelper::js2cpp_QXmlStreamReader_Error(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QXmlStreamReader::Error)0
          ;
        }
        return 
        (QXmlStreamReader::Error)
      v.toInt();
      }

      bool RJSHelper::is_QXmlStreamReader_Error(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlStreamReader_ReadElementTextBehaviour(RJSApi& handler, QXmlStreamReader::ReadElementTextBehaviour v) {
        return QJSValue(v);
      }

      QXmlStreamReader::ReadElementTextBehaviour RJSHelper::js2cpp_QXmlStreamReader_ReadElementTextBehaviour(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QXmlStreamReader::ReadElementTextBehaviour)0
          ;
        }
        return 
        (QXmlStreamReader::ReadElementTextBehaviour)
      v.toInt();
      }

      bool RJSHelper::is_QXmlStreamReader_ReadElementTextBehaviour(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlStreamReader_TokenType(RJSApi& handler, QXmlStreamReader::TokenType v) {
        return QJSValue(v);
      }

      QXmlStreamReader::TokenType RJSHelper::js2cpp_QXmlStreamReader_TokenType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (QXmlStreamReader::TokenType)0
          ;
        }
        return 
        (QXmlStreamReader::TokenType)
      v.toInt();
      }

      bool RJSHelper::is_QXmlStreamReader_TokenType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_AlignmentFlag(RJSApi& handler, Qt::AlignmentFlag v) {
        return QJSValue(v);
      }

      Qt::AlignmentFlag RJSHelper::js2cpp_Qt_AlignmentFlag(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::AlignmentFlag)0
          ;
        }
        return 
        (Qt::AlignmentFlag)
      v.toInt();
      }

      bool RJSHelper::is_Qt_AlignmentFlag(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ApplicationAttribute(RJSApi& handler, Qt::ApplicationAttribute v) {
        return QJSValue(v);
      }

      Qt::ApplicationAttribute RJSHelper::js2cpp_Qt_ApplicationAttribute(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::ApplicationAttribute)0
          ;
        }
        return 
        (Qt::ApplicationAttribute)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ApplicationAttribute(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ApplicationState(RJSApi& handler, Qt::ApplicationState v) {
        return QJSValue(v);
      }

      Qt::ApplicationState RJSHelper::js2cpp_Qt_ApplicationState(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::ApplicationState)0
          ;
        }
        return 
        (Qt::ApplicationState)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ApplicationState(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ArrowType(RJSApi& handler, Qt::ArrowType v) {
        return QJSValue(v);
      }

      Qt::ArrowType RJSHelper::js2cpp_Qt_ArrowType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::ArrowType)0
          ;
        }
        return 
        (Qt::ArrowType)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ArrowType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_AspectRatioMode(RJSApi& handler, Qt::AspectRatioMode v) {
        return QJSValue(v);
      }

      Qt::AspectRatioMode RJSHelper::js2cpp_Qt_AspectRatioMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::AspectRatioMode)0
          ;
        }
        return 
        (Qt::AspectRatioMode)
      v.toInt();
      }

      bool RJSHelper::is_Qt_AspectRatioMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_Axis(RJSApi& handler, Qt::Axis v) {
        return QJSValue(v);
      }

      Qt::Axis RJSHelper::js2cpp_Qt_Axis(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::Axis)0
          ;
        }
        return 
        (Qt::Axis)
      v.toInt();
      }

      bool RJSHelper::is_Qt_Axis(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_BGMode(RJSApi& handler, Qt::BGMode v) {
        return QJSValue(v);
      }

      Qt::BGMode RJSHelper::js2cpp_Qt_BGMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::BGMode)0
          ;
        }
        return 
        (Qt::BGMode)
      v.toInt();
      }

      bool RJSHelper::is_Qt_BGMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_BrushStyle(RJSApi& handler, Qt::BrushStyle v) {
        return QJSValue(v);
      }

      Qt::BrushStyle RJSHelper::js2cpp_Qt_BrushStyle(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::BrushStyle)0
          ;
        }
        return 
        (Qt::BrushStyle)
      v.toInt();
      }

      bool RJSHelper::is_Qt_BrushStyle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_CaseSensitivity(RJSApi& handler, Qt::CaseSensitivity v) {
        return QJSValue(v);
      }

      Qt::CaseSensitivity RJSHelper::js2cpp_Qt_CaseSensitivity(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::CaseSensitivity)0
          ;
        }
        return 
        (Qt::CaseSensitivity)
      v.toInt();
      }

      bool RJSHelper::is_Qt_CaseSensitivity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_CheckState(RJSApi& handler, Qt::CheckState v) {
        return QJSValue(v);
      }

      Qt::CheckState RJSHelper::js2cpp_Qt_CheckState(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::CheckState)0
          ;
        }
        return 
        (Qt::CheckState)
      v.toInt();
      }

      bool RJSHelper::is_Qt_CheckState(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ClipOperation(RJSApi& handler, Qt::ClipOperation v) {
        return QJSValue(v);
      }

      Qt::ClipOperation RJSHelper::js2cpp_Qt_ClipOperation(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::ClipOperation)0
          ;
        }
        return 
        (Qt::ClipOperation)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ClipOperation(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ContextMenuPolicy(RJSApi& handler, Qt::ContextMenuPolicy v) {
        return QJSValue(v);
      }

      Qt::ContextMenuPolicy RJSHelper::js2cpp_Qt_ContextMenuPolicy(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::ContextMenuPolicy)0
          ;
        }
        return 
        (Qt::ContextMenuPolicy)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ContextMenuPolicy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_Corner(RJSApi& handler, Qt::Corner v) {
        return QJSValue(v);
      }

      Qt::Corner RJSHelper::js2cpp_Qt_Corner(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::Corner)0
          ;
        }
        return 
        (Qt::Corner)
      v.toInt();
      }

      bool RJSHelper::is_Qt_Corner(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_CursorMoveStyle(RJSApi& handler, Qt::CursorMoveStyle v) {
        return QJSValue(v);
      }

      Qt::CursorMoveStyle RJSHelper::js2cpp_Qt_CursorMoveStyle(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::CursorMoveStyle)0
          ;
        }
        return 
        (Qt::CursorMoveStyle)
      v.toInt();
      }

      bool RJSHelper::is_Qt_CursorMoveStyle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_CursorShape(RJSApi& handler, Qt::CursorShape v) {
        return QJSValue(v);
      }

      Qt::CursorShape RJSHelper::js2cpp_Qt_CursorShape(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::CursorShape)0
          ;
        }
        return 
        (Qt::CursorShape)
      v.toInt();
      }

      bool RJSHelper::is_Qt_CursorShape(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_DateFormat(RJSApi& handler, Qt::DateFormat v) {
        return QJSValue(v);
      }

      Qt::DateFormat RJSHelper::js2cpp_Qt_DateFormat(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::DateFormat)0
          ;
        }
        return 
        (Qt::DateFormat)
      v.toInt();
      }

      bool RJSHelper::is_Qt_DateFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_DayOfWeek(RJSApi& handler, Qt::DayOfWeek v) {
        return QJSValue(v);
      }

      Qt::DayOfWeek RJSHelper::js2cpp_Qt_DayOfWeek(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::DayOfWeek)0
          ;
        }
        return 
        (Qt::DayOfWeek)
      v.toInt();
      }

      bool RJSHelper::is_Qt_DayOfWeek(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_DockWidgetArea(RJSApi& handler, Qt::DockWidgetArea v) {
        return QJSValue(v);
      }

      Qt::DockWidgetArea RJSHelper::js2cpp_Qt_DockWidgetArea(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::DockWidgetArea)0
          ;
        }
        return 
        (Qt::DockWidgetArea)
      v.toInt();
      }

      bool RJSHelper::is_Qt_DockWidgetArea(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_DockWidgetAreas(RJSApi& handler, Qt::DockWidgetAreas v) {
        return QJSValue(v);
      }

      Qt::DockWidgetAreas RJSHelper::js2cpp_Qt_DockWidgetAreas(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::DockWidgetAreas)0
          ;
        }
        return 
        (Qt::DockWidgetAreas)
      v.toInt();
      }

      bool RJSHelper::is_Qt_DockWidgetAreas(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_DropAction(RJSApi& handler, Qt::DropAction v) {
        return QJSValue(v);
      }

      Qt::DropAction RJSHelper::js2cpp_Qt_DropAction(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::DropAction)0
          ;
        }
        return 
        (Qt::DropAction)
      v.toInt();
      }

      bool RJSHelper::is_Qt_DropAction(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_Edge(RJSApi& handler, Qt::Edge v) {
        return QJSValue(v);
      }

      Qt::Edge RJSHelper::js2cpp_Qt_Edge(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::Edge)0
          ;
        }
        return 
        (Qt::Edge)
      v.toInt();
      }

      bool RJSHelper::is_Qt_Edge(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_FillRule(RJSApi& handler, Qt::FillRule v) {
        return QJSValue(v);
      }

      Qt::FillRule RJSHelper::js2cpp_Qt_FillRule(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::FillRule)0
          ;
        }
        return 
        (Qt::FillRule)
      v.toInt();
      }

      bool RJSHelper::is_Qt_FillRule(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_FindChildOptions(RJSApi& handler, Qt::FindChildOptions v) {
        return QJSValue(v);
      }

      Qt::FindChildOptions RJSHelper::js2cpp_Qt_FindChildOptions(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::FindChildOptions)0
          ;
        }
        return 
        (Qt::FindChildOptions)
      v.toInt();
      }

      bool RJSHelper::is_Qt_FindChildOptions(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_FocusPolicy(RJSApi& handler, Qt::FocusPolicy v) {
        return QJSValue(v);
      }

      Qt::FocusPolicy RJSHelper::js2cpp_Qt_FocusPolicy(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::FocusPolicy)0
          ;
        }
        return 
        (Qt::FocusPolicy)
      v.toInt();
      }

      bool RJSHelper::is_Qt_FocusPolicy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_FocusReason(RJSApi& handler, Qt::FocusReason v) {
        return QJSValue(v);
      }

      Qt::FocusReason RJSHelper::js2cpp_Qt_FocusReason(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::FocusReason)0
          ;
        }
        return 
        (Qt::FocusReason)
      v.toInt();
      }

      bool RJSHelper::is_Qt_FocusReason(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_GestureFlags(RJSApi& handler, Qt::GestureFlags v) {
        return QJSValue(v);
      }

      Qt::GestureFlags RJSHelper::js2cpp_Qt_GestureFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::GestureFlags)0
          ;
        }
        return 
        (Qt::GestureFlags)
      v.toInt();
      }

      bool RJSHelper::is_Qt_GestureFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_GestureState(RJSApi& handler, Qt::GestureState v) {
        return QJSValue(v);
      }

      Qt::GestureState RJSHelper::js2cpp_Qt_GestureState(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::GestureState)0
          ;
        }
        return 
        (Qt::GestureState)
      v.toInt();
      }

      bool RJSHelper::is_Qt_GestureState(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_GestureType(RJSApi& handler, Qt::GestureType v) {
        return QJSValue(v);
      }

      Qt::GestureType RJSHelper::js2cpp_Qt_GestureType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::GestureType)0
          ;
        }
        return 
        (Qt::GestureType)
      v.toInt();
      }

      bool RJSHelper::is_Qt_GestureType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_GlobalColor(RJSApi& handler, Qt::GlobalColor v) {
        return QJSValue(v);
      }

      Qt::GlobalColor RJSHelper::js2cpp_Qt_GlobalColor(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::GlobalColor)0
          ;
        }
        return 
        (Qt::GlobalColor)
      v.toInt();
      }

      bool RJSHelper::is_Qt_GlobalColor(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ImageConversionFlags(RJSApi& handler, Qt::ImageConversionFlags v) {
        return QJSValue(v);
      }

      Qt::ImageConversionFlags RJSHelper::js2cpp_Qt_ImageConversionFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::ImageConversionFlags)0
          ;
        }
        return 
        (Qt::ImageConversionFlags)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ImageConversionFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_InputMethodQuery(RJSApi& handler, Qt::InputMethodQuery v) {
        return QJSValue(v);
      }

      Qt::InputMethodQuery RJSHelper::js2cpp_Qt_InputMethodQuery(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::InputMethodQuery)0
          ;
        }
        return 
        (Qt::InputMethodQuery)
      v.toInt();
      }

      bool RJSHelper::is_Qt_InputMethodQuery(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ItemFlag(RJSApi& handler, Qt::ItemFlag v) {
        return QJSValue(v);
      }

      Qt::ItemFlag RJSHelper::js2cpp_Qt_ItemFlag(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::ItemFlag)0
          ;
        }
        return 
        (Qt::ItemFlag)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ItemFlag(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_Key(RJSApi& handler, Qt::Key v) {
        return QJSValue(v);
      }

      Qt::Key RJSHelper::js2cpp_Qt_Key(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::Key)0
          ;
        }
        return 
        (Qt::Key)
      v.toInt();
      }

      bool RJSHelper::is_Qt_Key(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_LayoutDirection(RJSApi& handler, Qt::LayoutDirection v) {
        return QJSValue(v);
      }

      Qt::LayoutDirection RJSHelper::js2cpp_Qt_LayoutDirection(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::LayoutDirection)0
          ;
        }
        return 
        (Qt::LayoutDirection)
      v.toInt();
      }

      bool RJSHelper::is_Qt_LayoutDirection(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_MaskMode(RJSApi& handler, Qt::MaskMode v) {
        return QJSValue(v);
      }

      Qt::MaskMode RJSHelper::js2cpp_Qt_MaskMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::MaskMode)0
          ;
        }
        return 
        (Qt::MaskMode)
      v.toInt();
      }

      bool RJSHelper::is_Qt_MaskMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_MatchFlags(RJSApi& handler, Qt::MatchFlags v) {
        return QJSValue(v);
      }

      Qt::MatchFlags RJSHelper::js2cpp_Qt_MatchFlags(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::MatchFlags)0
          ;
        }
        return 
        (Qt::MatchFlags)
      v.toInt();
      }

      bool RJSHelper::is_Qt_MatchFlags(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_MouseButton(RJSApi& handler, Qt::MouseButton v) {
        return QJSValue(v);
      }

      Qt::MouseButton RJSHelper::js2cpp_Qt_MouseButton(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::MouseButton)0
          ;
        }
        return 
        (Qt::MouseButton)
      v.toInt();
      }

      bool RJSHelper::is_Qt_MouseButton(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_MouseEventSource(RJSApi& handler, Qt::MouseEventSource v) {
        return QJSValue(v);
      }

      Qt::MouseEventSource RJSHelper::js2cpp_Qt_MouseEventSource(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::MouseEventSource)0
          ;
        }
        return 
        (Qt::MouseEventSource)
      v.toInt();
      }

      bool RJSHelper::is_Qt_MouseEventSource(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_NavigationMode(RJSApi& handler, Qt::NavigationMode v) {
        return QJSValue(v);
      }

      Qt::NavigationMode RJSHelper::js2cpp_Qt_NavigationMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::NavigationMode)0
          ;
        }
        return 
        (Qt::NavigationMode)
      v.toInt();
      }

      bool RJSHelper::is_Qt_NavigationMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_Orientation(RJSApi& handler, Qt::Orientation v) {
        return QJSValue(v);
      }

      Qt::Orientation RJSHelper::js2cpp_Qt_Orientation(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::Orientation)0
          ;
        }
        return 
        (Qt::Orientation)
      v.toInt();
      }

      bool RJSHelper::is_Qt_Orientation(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_PenCapStyle(RJSApi& handler, Qt::PenCapStyle v) {
        return QJSValue(v);
      }

      Qt::PenCapStyle RJSHelper::js2cpp_Qt_PenCapStyle(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::PenCapStyle)0
          ;
        }
        return 
        (Qt::PenCapStyle)
      v.toInt();
      }

      bool RJSHelper::is_Qt_PenCapStyle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_PenJoinStyle(RJSApi& handler, Qt::PenJoinStyle v) {
        return QJSValue(v);
      }

      Qt::PenJoinStyle RJSHelper::js2cpp_Qt_PenJoinStyle(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::PenJoinStyle)0
          ;
        }
        return 
        (Qt::PenJoinStyle)
      v.toInt();
      }

      bool RJSHelper::is_Qt_PenJoinStyle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_PenStyle(RJSApi& handler, Qt::PenStyle v) {
        return QJSValue(v);
      }

      Qt::PenStyle RJSHelper::js2cpp_Qt_PenStyle(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::PenStyle)0
          ;
        }
        return 
        (Qt::PenStyle)
      v.toInt();
      }

      bool RJSHelper::is_Qt_PenStyle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ReturnByValueConstant(RJSApi& handler, Qt::ReturnByValueConstant v) {
        return QJSValue(v);
      }

      Qt::ReturnByValueConstant RJSHelper::js2cpp_Qt_ReturnByValueConstant(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::ReturnByValueConstant)0
          ;
        }
        return 
        (Qt::ReturnByValueConstant)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ReturnByValueConstant(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ScreenOrientation(RJSApi& handler, Qt::ScreenOrientation v) {
        return QJSValue(v);
      }

      Qt::ScreenOrientation RJSHelper::js2cpp_Qt_ScreenOrientation(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::ScreenOrientation)0
          ;
        }
        return 
        (Qt::ScreenOrientation)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ScreenOrientation(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ScrollBarPolicy(RJSApi& handler, Qt::ScrollBarPolicy v) {
        return QJSValue(v);
      }

      Qt::ScrollBarPolicy RJSHelper::js2cpp_Qt_ScrollBarPolicy(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::ScrollBarPolicy)0
          ;
        }
        return 
        (Qt::ScrollBarPolicy)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ScrollBarPolicy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ScrollPhase(RJSApi& handler, Qt::ScrollPhase v) {
        return QJSValue(v);
      }

      Qt::ScrollPhase RJSHelper::js2cpp_Qt_ScrollPhase(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::ScrollPhase)0
          ;
        }
        return 
        (Qt::ScrollPhase)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ScrollPhase(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ShortcutContext(RJSApi& handler, Qt::ShortcutContext v) {
        return QJSValue(v);
      }

      Qt::ShortcutContext RJSHelper::js2cpp_Qt_ShortcutContext(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::ShortcutContext)0
          ;
        }
        return 
        (Qt::ShortcutContext)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ShortcutContext(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_SizeMode(RJSApi& handler, Qt::SizeMode v) {
        return QJSValue(v);
      }

      Qt::SizeMode RJSHelper::js2cpp_Qt_SizeMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::SizeMode)0
          ;
        }
        return 
        (Qt::SizeMode)
      v.toInt();
      }

      bool RJSHelper::is_Qt_SizeMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_SortOrder(RJSApi& handler, Qt::SortOrder v) {
        return QJSValue(v);
      }

      Qt::SortOrder RJSHelper::js2cpp_Qt_SortOrder(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::SortOrder)0
          ;
        }
        return 
        (Qt::SortOrder)
      v.toInt();
      }

      bool RJSHelper::is_Qt_SortOrder(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_TextElideMode(RJSApi& handler, Qt::TextElideMode v) {
        return QJSValue(v);
      }

      Qt::TextElideMode RJSHelper::js2cpp_Qt_TextElideMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::TextElideMode)0
          ;
        }
        return 
        (Qt::TextElideMode)
      v.toInt();
      }

      bool RJSHelper::is_Qt_TextElideMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_TextFormat(RJSApi& handler, Qt::TextFormat v) {
        return QJSValue(v);
      }

      Qt::TextFormat RJSHelper::js2cpp_Qt_TextFormat(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::TextFormat)0
          ;
        }
        return 
        (Qt::TextFormat)
      v.toInt();
      }

      bool RJSHelper::is_Qt_TextFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_TextInteractionFlag(RJSApi& handler, Qt::TextInteractionFlag v) {
        return QJSValue(v);
      }

      Qt::TextInteractionFlag RJSHelper::js2cpp_Qt_TextInteractionFlag(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::TextInteractionFlag)0
          ;
        }
        return 
        (Qt::TextInteractionFlag)
      v.toInt();
      }

      bool RJSHelper::is_Qt_TextInteractionFlag(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_TimeSpec(RJSApi& handler, Qt::TimeSpec v) {
        return QJSValue(v);
      }

      Qt::TimeSpec RJSHelper::js2cpp_Qt_TimeSpec(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::TimeSpec)0
          ;
        }
        return 
        (Qt::TimeSpec)
      v.toInt();
      }

      bool RJSHelper::is_Qt_TimeSpec(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_TimerType(RJSApi& handler, Qt::TimerType v) {
        return QJSValue(v);
      }

      Qt::TimerType RJSHelper::js2cpp_Qt_TimerType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::TimerType)0
          ;
        }
        return 
        (Qt::TimerType)
      v.toInt();
      }

      bool RJSHelper::is_Qt_TimerType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ToolBarArea(RJSApi& handler, Qt::ToolBarArea v) {
        return QJSValue(v);
      }

      Qt::ToolBarArea RJSHelper::js2cpp_Qt_ToolBarArea(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::ToolBarArea)0
          ;
        }
        return 
        (Qt::ToolBarArea)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ToolBarArea(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ToolBarAreas(RJSApi& handler, Qt::ToolBarAreas v) {
        return QJSValue(v);
      }

      Qt::ToolBarAreas RJSHelper::js2cpp_Qt_ToolBarAreas(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::ToolBarAreas)0
          ;
        }
        return 
        (Qt::ToolBarAreas)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ToolBarAreas(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_ToolButtonStyle(RJSApi& handler, Qt::ToolButtonStyle v) {
        return QJSValue(v);
      }

      Qt::ToolButtonStyle RJSHelper::js2cpp_Qt_ToolButtonStyle(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::ToolButtonStyle)0
          ;
        }
        return 
        (Qt::ToolButtonStyle)
      v.toInt();
      }

      bool RJSHelper::is_Qt_ToolButtonStyle(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_TransformationMode(RJSApi& handler, Qt::TransformationMode v) {
        return QJSValue(v);
      }

      Qt::TransformationMode RJSHelper::js2cpp_Qt_TransformationMode(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::TransformationMode)0
          ;
        }
        return 
        (Qt::TransformationMode)
      v.toInt();
      }

      bool RJSHelper::is_Qt_TransformationMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_WidgetAttribute(RJSApi& handler, Qt::WidgetAttribute v) {
        return QJSValue(v);
      }

      Qt::WidgetAttribute RJSHelper::js2cpp_Qt_WidgetAttribute(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::WidgetAttribute)0
          ;
        }
        return 
        (Qt::WidgetAttribute)
      v.toInt();
      }

      bool RJSHelper::is_Qt_WidgetAttribute(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_WindowModality(RJSApi& handler, Qt::WindowModality v) {
        return QJSValue(v);
      }

      Qt::WindowModality RJSHelper::js2cpp_Qt_WindowModality(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::WindowModality)0
          ;
        }
        return 
        (Qt::WindowModality)
      v.toInt();
      }

      bool RJSHelper::is_Qt_WindowModality(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_WindowState(RJSApi& handler, Qt::WindowState v) {
        return QJSValue(v);
      }

      Qt::WindowState RJSHelper::js2cpp_Qt_WindowState(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::WindowState)0
          ;
        }
        return 
        (Qt::WindowState)
      v.toInt();
      }

      bool RJSHelper::is_Qt_WindowState(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_Qt_WindowType(RJSApi& handler, Qt::WindowType v) {
        return QJSValue(v);
      }

      Qt::WindowType RJSHelper::js2cpp_Qt_WindowType(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 
            (Qt::WindowType)0
          ;
        }
        return 
        (Qt::WindowType)
      v.toInt();
      }

      bool RJSHelper::is_Qt_WindowType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_WId(RJSApi& handler, WId v) {
        return QJSValue((int)v);
      }

      WId RJSHelper::js2cpp_WId(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_WId(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_char(RJSApi& handler, char v) {
        return QJSValue(v);
      }

      char RJSHelper::js2cpp_char(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_char(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_double(RJSApi& handler, double v) {
        return QJSValue(v);
      }

      double RJSHelper::js2cpp_double(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_double(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_float(RJSApi& handler, float v) {
        return QJSValue(v);
      }

      float RJSHelper::js2cpp_float(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_float(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_int(RJSApi& handler, int v) {
        return QJSValue(v);
      }

      int RJSHelper::js2cpp_int(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_int(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_long(RJSApi& handler, long v) {
        return QJSValue((int)v);
      }

      long RJSHelper::js2cpp_long(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_long(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_qint64(RJSApi& handler, qint64 v) {
        return QJSValue((int)v);
      }

      qint64 RJSHelper::js2cpp_qint64(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_qint64(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_qlonglong(RJSApi& handler, qlonglong v) {
        return QJSValue((int)v);
      }

      qlonglong RJSHelper::js2cpp_qlonglong(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_qlonglong(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_qreal(RJSApi& handler, qreal v) {
        return QJSValue(v);
      }

      qreal RJSHelper::js2cpp_qreal(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_qreal(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_qsizetype(RJSApi& handler, qsizetype v) {
        return QJSValue((int)v);
      }

      qsizetype RJSHelper::js2cpp_qsizetype(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_qsizetype(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_quint16(RJSApi& handler, quint16 v) {
        return QJSValue(v);
      }

      quint16 RJSHelper::js2cpp_quint16(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_quint16(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_quint32(RJSApi& handler, quint32 v) {
        return QJSValue(v);
      }

      quint32 RJSHelper::js2cpp_quint32(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_quint32(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_quint64(RJSApi& handler, quint64 v) {
        return QJSValue((int)v);
      }

      quint64 RJSHelper::js2cpp_quint64(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_quint64(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_qulonglong(RJSApi& handler, qulonglong v) {
        return QJSValue((int)v);
      }

      qulonglong RJSHelper::js2cpp_qulonglong(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_qulonglong(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_short(RJSApi& handler, short v) {
        return QJSValue(v);
      }

      short RJSHelper::js2cpp_short(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_short(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_uint(RJSApi& handler, uint v) {
        return QJSValue(v);
      }

      uint RJSHelper::js2cpp_uint(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_uint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_ulong(RJSApi& handler, ulong v) {
        return QJSValue((int)v);
      }

      ulong RJSHelper::js2cpp_ulong(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_ulong(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_unsignedlong(RJSApi& handler, unsigned long v) {
        return QJSValue((int)v);
      }

      unsigned long RJSHelper::js2cpp_unsignedlong(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_unsignedlong(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
      QJSValue RJSHelper::cpp2js_ushort(RJSApi& handler, ushort v) {
        return QJSValue(v);
      }

      ushort RJSHelper::js2cpp_ushort(RJSApi& handler, const QJSValue& v) {
        if (!v.isNumber()) {
          return 0;
        }
        return v.toNumber();
      }

      bool RJSHelper::is_ushort(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
        if (v.isUndefined() || v.isNull()) {
          return acceptUndefined;
        }
        return v.isNumber();
      }
    
  // ------------------------------------
  // QSharedPointer types (non-copyable):
  // ------------------------------------
  
      QJSValue RJSHelper::cpp2js_QSharedPointer_QTextLayout(RJSApi& handler, const QSharedPointer<QTextLayout>& v) {
          QJSEngine* engine = handler.getEngine();
          QTextLayout_Wrapper* ret = new QTextLayout_Wrapper(handler, v);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //return engine->evaluate("new QTextLayout('__GOT_WRAPPER__', wrapper);");

          // attempt to downcast to specific type (non-copyable shared pointer):
          

          // JS: new QTextLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextLayout is undefined. Use QTextLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          return cl.callAsConstructor(args);
      }

      QSharedPointer<QTextLayout> RJSHelper::js2cpp_QSharedPointer_QTextLayout(RJSApi& handler, const QJSValue& v) {

          QTextLayout_Wrapper* wrapper = getWrapper<QTextLayout_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSharedPointer_QTextLayout: no wrapper";
              handler.trace();
              return QSharedPointer<QTextLayout>();
          }
          //return QSharedPointer<QTextLayout>(getWrapped_QTextLayout(wrapper));
          if (wrapper->hasWrappedSp()) {
              return wrapper->getWrappedSp();
          }
          else if (wrapper->getWrapped()==nullptr) {
              return QSharedPointer<QTextLayout>();
          }
          else {
              // wrapper of normal pointer, create QSharedPointer on the fly over clone of object:
              //return QSharedPointer<QTextLayout>(wrapper->getWrappedClone());
              //return QSharedPointer<QTextLayout>(wrapper->getWrapped()->clone());
              //qWarning() << "js2cpp_QSharedPointer_QTextLayout: object cannot be cloned";
              //return QSharedPointer<QTextLayout>();

              
                  // cannot be cloned:
                  return QSharedPointer<QTextLayout>(wrapper->getWrapped());
                
          }
      }

      bool RJSHelper::is_QSharedPointer_QTextLayout(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //return v.property("getType").call().toInt()==RJSType::QSharedPointer_QTextLayout_Type;
          return !v.isUndefined();
      }
    
  // --------------
  // wrapped types:
  // --------------
  
      QJSValue RJSHelper::cpp2js_QBitmap(RJSApi& handler, const QBitmap* v) {
          QJSEngine* engine = handler.getEngine();
          QBitmap_Wrapper* ret;

          if (v==nullptr) {
              ret = new QBitmap_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QBitmap object:
              ret = new QBitmap_Wrapper(handler, new QBitmap(*v), true);
          }

          // JS: new QBitmap('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QBitmap");
          if (cl.isUndefined()) {
              qWarning() << "Class QBitmap is undefined. Use QBitmap_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QBitmap('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QBitmap(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QBitmap(RJSApi& handler, const QBitmap& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QBitmap object:
          QBitmap_Wrapper* ret = new QBitmap_Wrapper(handler, new QBitmap(v), true);

          // JS: new QBitmap('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QBitmap");
          if (cl.isUndefined()) {
              qWarning() << "Class QBitmap is undefined. Use QBitmap_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QBitmap('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QBitmap(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QBitmap RJSHelper::js2cpp_QBitmap(RJSApi& handler, const QJSValue& v) {
          /*
          QBitmap_Wrapper* wrapper = getWrapper<QBitmap_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QBitmap: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QBitmap();
          }
          //return *(QBitmap*)wrapper->getWrappedVoid();
          QBitmap* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QBitmap: wrapped pointer is NULL";
              return QBitmap();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QBitmap: not a QObject";
              return QBitmap();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QBitmap_ptr: no wrapper";
              handler.trace();
              return QBitmap();
          }
          //QBitmap* ret = getWrapped_QBitmap(wrapper);
          QBitmap* ret = QBitmap_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QBitmap();
          }
          return *ret;
      }

      bool RJSHelper::is_QBitmap(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QBitmap: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QBitmap::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QBrush(RJSApi& handler, const QBrush* v) {
          QJSEngine* engine = handler.getEngine();
          QBrush_Wrapper* ret;

          if (v==nullptr) {
              ret = new QBrush_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QBrush object:
              ret = new QBrush_Wrapper(handler, new QBrush(*v), true);
          }

          // JS: new QBrush('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QBrush");
          if (cl.isUndefined()) {
              qWarning() << "Class QBrush is undefined. Use QBrush_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QBrush('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QBrush(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QBrush(RJSApi& handler, const QBrush& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QBrush object:
          QBrush_Wrapper* ret = new QBrush_Wrapper(handler, new QBrush(v), true);

          // JS: new QBrush('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QBrush");
          if (cl.isUndefined()) {
              qWarning() << "Class QBrush is undefined. Use QBrush_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QBrush('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QBrush(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QBrush RJSHelper::js2cpp_QBrush(RJSApi& handler, const QJSValue& v) {
          /*
          QBrush_Wrapper* wrapper = getWrapper<QBrush_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QBrush: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QBrush();
          }
          //return *(QBrush*)wrapper->getWrappedVoid();
          QBrush* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QBrush: wrapped pointer is NULL";
              return QBrush();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QBrush: not a QObject";
              return QBrush();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QBrush_ptr: no wrapper";
              handler.trace();
              return QBrush();
          }
          //QBrush* ret = getWrapped_QBrush(wrapper);
          QBrush* ret = QBrush_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QBrush();
          }
          return *ret;
      }

      bool RJSHelper::is_QBrush(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QBrush: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QBrush::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QByteArray(RJSApi& handler, const QByteArray* v) {
          QJSEngine* engine = handler.getEngine();
          QByteArray_Wrapper* ret;

          if (v==nullptr) {
              ret = new QByteArray_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QByteArray object:
              ret = new QByteArray_Wrapper(handler, new QByteArray(*v), true);
          }

          // JS: new QByteArray('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QByteArray");
          if (cl.isUndefined()) {
              qWarning() << "Class QByteArray is undefined. Use QByteArray_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QByteArray('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QByteArray(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QByteArray(RJSApi& handler, const QByteArray& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QByteArray object:
          QByteArray_Wrapper* ret = new QByteArray_Wrapper(handler, new QByteArray(v), true);

          // JS: new QByteArray('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QByteArray");
          if (cl.isUndefined()) {
              qWarning() << "Class QByteArray is undefined. Use QByteArray_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QByteArray('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QByteArray(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QByteArray RJSHelper::js2cpp_QByteArray(RJSApi& handler, const QJSValue& v) {
          /*
          QByteArray_Wrapper* wrapper = getWrapper<QByteArray_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QByteArray: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QByteArray();
          }
          //return *(QByteArray*)wrapper->getWrappedVoid();
          QByteArray* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QByteArray: wrapped pointer is NULL";
              return QByteArray();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QByteArray: not a QObject";
              return QByteArray();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QByteArray_ptr: no wrapper";
              handler.trace();
              return QByteArray();
          }
          //QByteArray* ret = getWrapped_QByteArray(wrapper);
          QByteArray* ret = QByteArray_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QByteArray();
          }
          return *ret;
      }

      bool RJSHelper::is_QByteArray(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QByteArray: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QByteArray::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QColor(RJSApi& handler, const QColor* v) {
          QJSEngine* engine = handler.getEngine();
          QColor_Wrapper* ret;

          if (v==nullptr) {
              ret = new QColor_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QColor object:
              ret = new QColor_Wrapper(handler, new QColor(*v), true);
          }

          // JS: new QColor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QColor");
          if (cl.isUndefined()) {
              qWarning() << "Class QColor is undefined. Use QColor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QColor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QColor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QColor(RJSApi& handler, const QColor& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QColor object:
          QColor_Wrapper* ret = new QColor_Wrapper(handler, new QColor(v), true);

          // JS: new QColor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QColor");
          if (cl.isUndefined()) {
              qWarning() << "Class QColor is undefined. Use QColor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QColor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QColor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QColor RJSHelper::js2cpp_QColor(RJSApi& handler, const QJSValue& v) {
          /*
          QColor_Wrapper* wrapper = getWrapper<QColor_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QColor: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QColor();
          }
          //return *(QColor*)wrapper->getWrappedVoid();
          QColor* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QColor: wrapped pointer is NULL";
              return QColor();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QColor: not a QObject";
              return QColor();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QColor_ptr: no wrapper";
              handler.trace();
              return QColor();
          }
          //QColor* ret = getWrapped_QColor(wrapper);
          QColor* ret = QColor_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QColor();
          }
          return *ret;
      }

      bool RJSHelper::is_QColor(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QColor: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QColor::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QConicalGradient(RJSApi& handler, const QConicalGradient* v) {
          QJSEngine* engine = handler.getEngine();
          QConicalGradient_Wrapper* ret;

          if (v==nullptr) {
              ret = new QConicalGradient_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QConicalGradient object:
              ret = new QConicalGradient_Wrapper(handler, new QConicalGradient(*v), true);
          }

          // JS: new QConicalGradient('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QConicalGradient");
          if (cl.isUndefined()) {
              qWarning() << "Class QConicalGradient is undefined. Use QConicalGradient_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QConicalGradient('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QConicalGradient(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QConicalGradient(RJSApi& handler, const QConicalGradient& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QConicalGradient object:
          QConicalGradient_Wrapper* ret = new QConicalGradient_Wrapper(handler, new QConicalGradient(v), true);

          // JS: new QConicalGradient('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QConicalGradient");
          if (cl.isUndefined()) {
              qWarning() << "Class QConicalGradient is undefined. Use QConicalGradient_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QConicalGradient('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QConicalGradient(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QConicalGradient RJSHelper::js2cpp_QConicalGradient(RJSApi& handler, const QJSValue& v) {
          /*
          QConicalGradient_Wrapper* wrapper = getWrapper<QConicalGradient_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QConicalGradient: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QConicalGradient();
          }
          //return *(QConicalGradient*)wrapper->getWrappedVoid();
          QConicalGradient* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QConicalGradient: wrapped pointer is NULL";
              return QConicalGradient();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QConicalGradient: not a QObject";
              return QConicalGradient();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QConicalGradient_ptr: no wrapper";
              handler.trace();
              return QConicalGradient();
          }
          //QConicalGradient* ret = getWrapped_QConicalGradient(wrapper);
          QConicalGradient* ret = QConicalGradient_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QConicalGradient();
          }
          return *ret;
      }

      bool RJSHelper::is_QConicalGradient(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QConicalGradient: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QConicalGradient::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QCursor(RJSApi& handler, const QCursor* v) {
          QJSEngine* engine = handler.getEngine();
          QCursor_Wrapper* ret;

          if (v==nullptr) {
              ret = new QCursor_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QCursor object:
              ret = new QCursor_Wrapper(handler, new QCursor(*v), true);
          }

          // JS: new QCursor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QCursor");
          if (cl.isUndefined()) {
              qWarning() << "Class QCursor is undefined. Use QCursor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QCursor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QCursor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QCursor(RJSApi& handler, const QCursor& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QCursor object:
          QCursor_Wrapper* ret = new QCursor_Wrapper(handler, new QCursor(v), true);

          // JS: new QCursor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QCursor");
          if (cl.isUndefined()) {
              qWarning() << "Class QCursor is undefined. Use QCursor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QCursor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QCursor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QCursor RJSHelper::js2cpp_QCursor(RJSApi& handler, const QJSValue& v) {
          /*
          QCursor_Wrapper* wrapper = getWrapper<QCursor_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QCursor: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QCursor();
          }
          //return *(QCursor*)wrapper->getWrappedVoid();
          QCursor* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QCursor: wrapped pointer is NULL";
              return QCursor();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QCursor: not a QObject";
              return QCursor();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QCursor_ptr: no wrapper";
              handler.trace();
              return QCursor();
          }
          //QCursor* ret = getWrapped_QCursor(wrapper);
          QCursor* ret = QCursor_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QCursor();
          }
          return *ret;
      }

      bool RJSHelper::is_QCursor(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QCursor: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QCursor::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDate(RJSApi& handler, const QDate* v) {
          QJSEngine* engine = handler.getEngine();
          QDate_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDate_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDate object:
              ret = new QDate_Wrapper(handler, new QDate(*v), true);
          }

          // JS: new QDate('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDate");
          if (cl.isUndefined()) {
              qWarning() << "Class QDate is undefined. Use QDate_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDate('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDate(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDate(RJSApi& handler, const QDate& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDate object:
          QDate_Wrapper* ret = new QDate_Wrapper(handler, new QDate(v), true);

          // JS: new QDate('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDate");
          if (cl.isUndefined()) {
              qWarning() << "Class QDate is undefined. Use QDate_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDate('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDate(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDate RJSHelper::js2cpp_QDate(RJSApi& handler, const QJSValue& v) {
          /*
          QDate_Wrapper* wrapper = getWrapper<QDate_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDate: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDate();
          }
          //return *(QDate*)wrapper->getWrappedVoid();
          QDate* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDate: wrapped pointer is NULL";
              return QDate();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDate: not a QObject";
              return QDate();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDate_ptr: no wrapper";
              handler.trace();
              return QDate();
          }
          //QDate* ret = getWrapped_QDate(wrapper);
          QDate* ret = QDate_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDate();
          }
          return *ret;
      }

      bool RJSHelper::is_QDate(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDate: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDate::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDateTime(RJSApi& handler, const QDateTime* v) {
          QJSEngine* engine = handler.getEngine();
          QDateTime_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDateTime_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDateTime object:
              ret = new QDateTime_Wrapper(handler, new QDateTime(*v), true);
          }

          // JS: new QDateTime('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDateTime");
          if (cl.isUndefined()) {
              qWarning() << "Class QDateTime is undefined. Use QDateTime_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDateTime('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDateTime(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDateTime(RJSApi& handler, const QDateTime& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDateTime object:
          QDateTime_Wrapper* ret = new QDateTime_Wrapper(handler, new QDateTime(v), true);

          // JS: new QDateTime('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDateTime");
          if (cl.isUndefined()) {
              qWarning() << "Class QDateTime is undefined. Use QDateTime_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDateTime('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDateTime(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDateTime RJSHelper::js2cpp_QDateTime(RJSApi& handler, const QJSValue& v) {
          /*
          QDateTime_Wrapper* wrapper = getWrapper<QDateTime_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDateTime: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDateTime();
          }
          //return *(QDateTime*)wrapper->getWrappedVoid();
          QDateTime* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDateTime: wrapped pointer is NULL";
              return QDateTime();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDateTime: not a QObject";
              return QDateTime();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDateTime_ptr: no wrapper";
              handler.trace();
              return QDateTime();
          }
          //QDateTime* ret = getWrapped_QDateTime(wrapper);
          QDateTime* ret = QDateTime_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDateTime();
          }
          return *ret;
      }

      bool RJSHelper::is_QDateTime(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDateTime: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDateTime::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDesktopServices(RJSApi& handler, const QDesktopServices* v) {
          QJSEngine* engine = handler.getEngine();
          QDesktopServices_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDesktopServices_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDesktopServices object:
              ret = new QDesktopServices_Wrapper(handler, new QDesktopServices(*v), true);
          }

          // JS: new QDesktopServices('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDesktopServices");
          if (cl.isUndefined()) {
              qWarning() << "Class QDesktopServices is undefined. Use QDesktopServices_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDesktopServices('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDesktopServices(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDesktopServices(RJSApi& handler, const QDesktopServices& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDesktopServices object:
          QDesktopServices_Wrapper* ret = new QDesktopServices_Wrapper(handler, new QDesktopServices(v), true);

          // JS: new QDesktopServices('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDesktopServices");
          if (cl.isUndefined()) {
              qWarning() << "Class QDesktopServices is undefined. Use QDesktopServices_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDesktopServices('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDesktopServices(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDesktopServices RJSHelper::js2cpp_QDesktopServices(RJSApi& handler, const QJSValue& v) {
          /*
          QDesktopServices_Wrapper* wrapper = getWrapper<QDesktopServices_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDesktopServices: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDesktopServices();
          }
          //return *(QDesktopServices*)wrapper->getWrappedVoid();
          QDesktopServices* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDesktopServices: wrapped pointer is NULL";
              return QDesktopServices();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDesktopServices: not a QObject";
              return QDesktopServices();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDesktopServices_ptr: no wrapper";
              handler.trace();
              return QDesktopServices();
          }
          //QDesktopServices* ret = getWrapped_QDesktopServices(wrapper);
          QDesktopServices* ret = QDesktopServices_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDesktopServices();
          }
          return *ret;
      }

      bool RJSHelper::is_QDesktopServices(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDesktopServices: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDesktopServices::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDir(RJSApi& handler, const QDir* v) {
          QJSEngine* engine = handler.getEngine();
          QDir_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDir_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDir object:
              ret = new QDir_Wrapper(handler, new QDir(*v), true);
          }

          // JS: new QDir('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDir");
          if (cl.isUndefined()) {
              qWarning() << "Class QDir is undefined. Use QDir_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDir('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDir(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDir(RJSApi& handler, const QDir& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDir object:
          QDir_Wrapper* ret = new QDir_Wrapper(handler, new QDir(v), true);

          // JS: new QDir('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDir");
          if (cl.isUndefined()) {
              qWarning() << "Class QDir is undefined. Use QDir_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDir('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDir(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDir RJSHelper::js2cpp_QDir(RJSApi& handler, const QJSValue& v) {
          /*
          QDir_Wrapper* wrapper = getWrapper<QDir_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDir: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDir();
          }
          //return *(QDir*)wrapper->getWrappedVoid();
          QDir* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDir: wrapped pointer is NULL";
              return QDir();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDir: not a QObject";
              return QDir();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDir_ptr: no wrapper";
              handler.trace();
              return QDir();
          }
          //QDir* ret = getWrapped_QDir(wrapper);
          QDir* ret = QDir_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDir();
          }
          return *ret;
      }

      bool RJSHelper::is_QDir(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDir: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDir::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomAttr(RJSApi& handler, const QDomAttr* v) {
          QJSEngine* engine = handler.getEngine();
          QDomAttr_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomAttr_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomAttr object:
              ret = new QDomAttr_Wrapper(handler, new QDomAttr(*v), true);
          }

          // JS: new QDomAttr('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomAttr");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomAttr is undefined. Use QDomAttr_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomAttr('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomAttr(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomAttr(RJSApi& handler, const QDomAttr& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomAttr object:
          QDomAttr_Wrapper* ret = new QDomAttr_Wrapper(handler, new QDomAttr(v), true);

          // JS: new QDomAttr('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomAttr");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomAttr is undefined. Use QDomAttr_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomAttr('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomAttr(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomAttr RJSHelper::js2cpp_QDomAttr(RJSApi& handler, const QJSValue& v) {
          /*
          QDomAttr_Wrapper* wrapper = getWrapper<QDomAttr_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomAttr: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomAttr();
          }
          //return *(QDomAttr*)wrapper->getWrappedVoid();
          QDomAttr* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomAttr: wrapped pointer is NULL";
              return QDomAttr();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomAttr: not a QObject";
              return QDomAttr();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomAttr_ptr: no wrapper";
              handler.trace();
              return QDomAttr();
          }
          //QDomAttr* ret = getWrapped_QDomAttr(wrapper);
          QDomAttr* ret = QDomAttr_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomAttr();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomAttr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomAttr: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomAttr::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomCDATASection(RJSApi& handler, const QDomCDATASection* v) {
          QJSEngine* engine = handler.getEngine();
          QDomCDATASection_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomCDATASection_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomCDATASection object:
              ret = new QDomCDATASection_Wrapper(handler, new QDomCDATASection(*v), true);
          }

          // JS: new QDomCDATASection('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomCDATASection");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomCDATASection is undefined. Use QDomCDATASection_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomCDATASection('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomCDATASection(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomCDATASection(RJSApi& handler, const QDomCDATASection& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomCDATASection object:
          QDomCDATASection_Wrapper* ret = new QDomCDATASection_Wrapper(handler, new QDomCDATASection(v), true);

          // JS: new QDomCDATASection('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomCDATASection");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomCDATASection is undefined. Use QDomCDATASection_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomCDATASection('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomCDATASection(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomCDATASection RJSHelper::js2cpp_QDomCDATASection(RJSApi& handler, const QJSValue& v) {
          /*
          QDomCDATASection_Wrapper* wrapper = getWrapper<QDomCDATASection_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomCDATASection: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomCDATASection();
          }
          //return *(QDomCDATASection*)wrapper->getWrappedVoid();
          QDomCDATASection* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomCDATASection: wrapped pointer is NULL";
              return QDomCDATASection();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomCDATASection: not a QObject";
              return QDomCDATASection();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomCDATASection_ptr: no wrapper";
              handler.trace();
              return QDomCDATASection();
          }
          //QDomCDATASection* ret = getWrapped_QDomCDATASection(wrapper);
          QDomCDATASection* ret = QDomCDATASection_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomCDATASection();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomCDATASection(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomCDATASection: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomCDATASection::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomCharacterData(RJSApi& handler, const QDomCharacterData* v) {
          QJSEngine* engine = handler.getEngine();
          QDomCharacterData_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomCharacterData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomCharacterData object:
              ret = new QDomCharacterData_Wrapper(handler, new QDomCharacterData(*v), true);
          }

          // JS: new QDomCharacterData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomCharacterData");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomCharacterData is undefined. Use QDomCharacterData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomCharacterData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomCharacterData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomCharacterData(RJSApi& handler, const QDomCharacterData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomCharacterData object:
          QDomCharacterData_Wrapper* ret = new QDomCharacterData_Wrapper(handler, new QDomCharacterData(v), true);

          // JS: new QDomCharacterData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomCharacterData");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomCharacterData is undefined. Use QDomCharacterData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomCharacterData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomCharacterData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomCharacterData RJSHelper::js2cpp_QDomCharacterData(RJSApi& handler, const QJSValue& v) {
          /*
          QDomCharacterData_Wrapper* wrapper = getWrapper<QDomCharacterData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomCharacterData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomCharacterData();
          }
          //return *(QDomCharacterData*)wrapper->getWrappedVoid();
          QDomCharacterData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomCharacterData: wrapped pointer is NULL";
              return QDomCharacterData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomCharacterData: not a QObject";
              return QDomCharacterData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomCharacterData_ptr: no wrapper";
              handler.trace();
              return QDomCharacterData();
          }
          //QDomCharacterData* ret = getWrapped_QDomCharacterData(wrapper);
          QDomCharacterData* ret = QDomCharacterData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomCharacterData();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomCharacterData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomCharacterData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomCharacterData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomComment(RJSApi& handler, const QDomComment* v) {
          QJSEngine* engine = handler.getEngine();
          QDomComment_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomComment_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomComment object:
              ret = new QDomComment_Wrapper(handler, new QDomComment(*v), true);
          }

          // JS: new QDomComment('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomComment");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomComment is undefined. Use QDomComment_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomComment('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomComment(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomComment(RJSApi& handler, const QDomComment& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomComment object:
          QDomComment_Wrapper* ret = new QDomComment_Wrapper(handler, new QDomComment(v), true);

          // JS: new QDomComment('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomComment");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomComment is undefined. Use QDomComment_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomComment('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomComment(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomComment RJSHelper::js2cpp_QDomComment(RJSApi& handler, const QJSValue& v) {
          /*
          QDomComment_Wrapper* wrapper = getWrapper<QDomComment_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomComment: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomComment();
          }
          //return *(QDomComment*)wrapper->getWrappedVoid();
          QDomComment* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomComment: wrapped pointer is NULL";
              return QDomComment();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomComment: not a QObject";
              return QDomComment();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomComment_ptr: no wrapper";
              handler.trace();
              return QDomComment();
          }
          //QDomComment* ret = getWrapped_QDomComment(wrapper);
          QDomComment* ret = QDomComment_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomComment();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomComment(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomComment: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomComment::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomDocument(RJSApi& handler, const QDomDocument* v) {
          QJSEngine* engine = handler.getEngine();
          QDomDocument_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomDocument_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomDocument object:
              ret = new QDomDocument_Wrapper(handler, new QDomDocument(*v), true);
          }

          // JS: new QDomDocument('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomDocument");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomDocument is undefined. Use QDomDocument_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomDocument('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomDocument(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomDocument(RJSApi& handler, const QDomDocument& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomDocument object:
          QDomDocument_Wrapper* ret = new QDomDocument_Wrapper(handler, new QDomDocument(v), true);

          // JS: new QDomDocument('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomDocument");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomDocument is undefined. Use QDomDocument_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomDocument('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomDocument(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomDocument RJSHelper::js2cpp_QDomDocument(RJSApi& handler, const QJSValue& v) {
          /*
          QDomDocument_Wrapper* wrapper = getWrapper<QDomDocument_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomDocument: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomDocument();
          }
          //return *(QDomDocument*)wrapper->getWrappedVoid();
          QDomDocument* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomDocument: wrapped pointer is NULL";
              return QDomDocument();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomDocument: not a QObject";
              return QDomDocument();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomDocument_ptr: no wrapper";
              handler.trace();
              return QDomDocument();
          }
          //QDomDocument* ret = getWrapped_QDomDocument(wrapper);
          QDomDocument* ret = QDomDocument_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomDocument();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomDocument(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomDocument: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomDocument::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomDocumentFragment(RJSApi& handler, const QDomDocumentFragment* v) {
          QJSEngine* engine = handler.getEngine();
          QDomDocumentFragment_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomDocumentFragment_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomDocumentFragment object:
              ret = new QDomDocumentFragment_Wrapper(handler, new QDomDocumentFragment(*v), true);
          }

          // JS: new QDomDocumentFragment('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomDocumentFragment");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomDocumentFragment is undefined. Use QDomDocumentFragment_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomDocumentFragment('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomDocumentFragment(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomDocumentFragment(RJSApi& handler, const QDomDocumentFragment& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomDocumentFragment object:
          QDomDocumentFragment_Wrapper* ret = new QDomDocumentFragment_Wrapper(handler, new QDomDocumentFragment(v), true);

          // JS: new QDomDocumentFragment('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomDocumentFragment");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomDocumentFragment is undefined. Use QDomDocumentFragment_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomDocumentFragment('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomDocumentFragment(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomDocumentFragment RJSHelper::js2cpp_QDomDocumentFragment(RJSApi& handler, const QJSValue& v) {
          /*
          QDomDocumentFragment_Wrapper* wrapper = getWrapper<QDomDocumentFragment_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomDocumentFragment: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomDocumentFragment();
          }
          //return *(QDomDocumentFragment*)wrapper->getWrappedVoid();
          QDomDocumentFragment* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomDocumentFragment: wrapped pointer is NULL";
              return QDomDocumentFragment();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomDocumentFragment: not a QObject";
              return QDomDocumentFragment();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomDocumentFragment_ptr: no wrapper";
              handler.trace();
              return QDomDocumentFragment();
          }
          //QDomDocumentFragment* ret = getWrapped_QDomDocumentFragment(wrapper);
          QDomDocumentFragment* ret = QDomDocumentFragment_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomDocumentFragment();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomDocumentFragment(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomDocumentFragment: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomDocumentFragment::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomDocumentType(RJSApi& handler, const QDomDocumentType* v) {
          QJSEngine* engine = handler.getEngine();
          QDomDocumentType_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomDocumentType_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomDocumentType object:
              ret = new QDomDocumentType_Wrapper(handler, new QDomDocumentType(*v), true);
          }

          // JS: new QDomDocumentType('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomDocumentType");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomDocumentType is undefined. Use QDomDocumentType_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomDocumentType('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomDocumentType(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomDocumentType(RJSApi& handler, const QDomDocumentType& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomDocumentType object:
          QDomDocumentType_Wrapper* ret = new QDomDocumentType_Wrapper(handler, new QDomDocumentType(v), true);

          // JS: new QDomDocumentType('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomDocumentType");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomDocumentType is undefined. Use QDomDocumentType_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomDocumentType('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomDocumentType(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomDocumentType RJSHelper::js2cpp_QDomDocumentType(RJSApi& handler, const QJSValue& v) {
          /*
          QDomDocumentType_Wrapper* wrapper = getWrapper<QDomDocumentType_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomDocumentType: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomDocumentType();
          }
          //return *(QDomDocumentType*)wrapper->getWrappedVoid();
          QDomDocumentType* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomDocumentType: wrapped pointer is NULL";
              return QDomDocumentType();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomDocumentType: not a QObject";
              return QDomDocumentType();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomDocumentType_ptr: no wrapper";
              handler.trace();
              return QDomDocumentType();
          }
          //QDomDocumentType* ret = getWrapped_QDomDocumentType(wrapper);
          QDomDocumentType* ret = QDomDocumentType_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomDocumentType();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomDocumentType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomDocumentType: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomDocumentType::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomElement(RJSApi& handler, const QDomElement* v) {
          QJSEngine* engine = handler.getEngine();
          QDomElement_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomElement_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomElement object:
              ret = new QDomElement_Wrapper(handler, new QDomElement(*v), true);
          }

          // JS: new QDomElement('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomElement");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomElement is undefined. Use QDomElement_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomElement('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomElement(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomElement(RJSApi& handler, const QDomElement& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomElement object:
          QDomElement_Wrapper* ret = new QDomElement_Wrapper(handler, new QDomElement(v), true);

          // JS: new QDomElement('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomElement");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomElement is undefined. Use QDomElement_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomElement('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomElement(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomElement RJSHelper::js2cpp_QDomElement(RJSApi& handler, const QJSValue& v) {
          /*
          QDomElement_Wrapper* wrapper = getWrapper<QDomElement_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomElement: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomElement();
          }
          //return *(QDomElement*)wrapper->getWrappedVoid();
          QDomElement* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomElement: wrapped pointer is NULL";
              return QDomElement();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomElement: not a QObject";
              return QDomElement();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomElement_ptr: no wrapper";
              handler.trace();
              return QDomElement();
          }
          //QDomElement* ret = getWrapped_QDomElement(wrapper);
          QDomElement* ret = QDomElement_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomElement();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomElement(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomElement: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomElement::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomEntity(RJSApi& handler, const QDomEntity* v) {
          QJSEngine* engine = handler.getEngine();
          QDomEntity_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomEntity_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomEntity object:
              ret = new QDomEntity_Wrapper(handler, new QDomEntity(*v), true);
          }

          // JS: new QDomEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomEntity is undefined. Use QDomEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomEntity(RJSApi& handler, const QDomEntity& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomEntity object:
          QDomEntity_Wrapper* ret = new QDomEntity_Wrapper(handler, new QDomEntity(v), true);

          // JS: new QDomEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomEntity is undefined. Use QDomEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomEntity RJSHelper::js2cpp_QDomEntity(RJSApi& handler, const QJSValue& v) {
          /*
          QDomEntity_Wrapper* wrapper = getWrapper<QDomEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomEntity: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomEntity();
          }
          //return *(QDomEntity*)wrapper->getWrappedVoid();
          QDomEntity* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomEntity: wrapped pointer is NULL";
              return QDomEntity();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomEntity: not a QObject";
              return QDomEntity();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomEntity_ptr: no wrapper";
              handler.trace();
              return QDomEntity();
          }
          //QDomEntity* ret = getWrapped_QDomEntity(wrapper);
          QDomEntity* ret = QDomEntity_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomEntity();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomEntityReference(RJSApi& handler, const QDomEntityReference* v) {
          QJSEngine* engine = handler.getEngine();
          QDomEntityReference_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomEntityReference_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomEntityReference object:
              ret = new QDomEntityReference_Wrapper(handler, new QDomEntityReference(*v), true);
          }

          // JS: new QDomEntityReference('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomEntityReference");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomEntityReference is undefined. Use QDomEntityReference_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomEntityReference('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomEntityReference(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomEntityReference(RJSApi& handler, const QDomEntityReference& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomEntityReference object:
          QDomEntityReference_Wrapper* ret = new QDomEntityReference_Wrapper(handler, new QDomEntityReference(v), true);

          // JS: new QDomEntityReference('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomEntityReference");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomEntityReference is undefined. Use QDomEntityReference_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomEntityReference('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomEntityReference(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomEntityReference RJSHelper::js2cpp_QDomEntityReference(RJSApi& handler, const QJSValue& v) {
          /*
          QDomEntityReference_Wrapper* wrapper = getWrapper<QDomEntityReference_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomEntityReference: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomEntityReference();
          }
          //return *(QDomEntityReference*)wrapper->getWrappedVoid();
          QDomEntityReference* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomEntityReference: wrapped pointer is NULL";
              return QDomEntityReference();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomEntityReference: not a QObject";
              return QDomEntityReference();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomEntityReference_ptr: no wrapper";
              handler.trace();
              return QDomEntityReference();
          }
          //QDomEntityReference* ret = getWrapped_QDomEntityReference(wrapper);
          QDomEntityReference* ret = QDomEntityReference_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomEntityReference();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomEntityReference(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomEntityReference: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomEntityReference::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomImplementation(RJSApi& handler, const QDomImplementation* v) {
          QJSEngine* engine = handler.getEngine();
          QDomImplementation_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomImplementation_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomImplementation object:
              ret = new QDomImplementation_Wrapper(handler, new QDomImplementation(*v), true);
          }

          // JS: new QDomImplementation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomImplementation");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomImplementation is undefined. Use QDomImplementation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomImplementation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomImplementation(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomImplementation(RJSApi& handler, const QDomImplementation& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomImplementation object:
          QDomImplementation_Wrapper* ret = new QDomImplementation_Wrapper(handler, new QDomImplementation(v), true);

          // JS: new QDomImplementation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomImplementation");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomImplementation is undefined. Use QDomImplementation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomImplementation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomImplementation(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomImplementation RJSHelper::js2cpp_QDomImplementation(RJSApi& handler, const QJSValue& v) {
          /*
          QDomImplementation_Wrapper* wrapper = getWrapper<QDomImplementation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomImplementation: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomImplementation();
          }
          //return *(QDomImplementation*)wrapper->getWrappedVoid();
          QDomImplementation* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomImplementation: wrapped pointer is NULL";
              return QDomImplementation();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomImplementation: not a QObject";
              return QDomImplementation();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomImplementation_ptr: no wrapper";
              handler.trace();
              return QDomImplementation();
          }
          //QDomImplementation* ret = getWrapped_QDomImplementation(wrapper);
          QDomImplementation* ret = QDomImplementation_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomImplementation();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomImplementation(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomImplementation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomImplementation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomNamedNodeMap(RJSApi& handler, const QDomNamedNodeMap* v) {
          QJSEngine* engine = handler.getEngine();
          QDomNamedNodeMap_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomNamedNodeMap_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomNamedNodeMap object:
              ret = new QDomNamedNodeMap_Wrapper(handler, new QDomNamedNodeMap(*v), true);
          }

          // JS: new QDomNamedNodeMap('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomNamedNodeMap");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomNamedNodeMap is undefined. Use QDomNamedNodeMap_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomNamedNodeMap('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomNamedNodeMap(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomNamedNodeMap(RJSApi& handler, const QDomNamedNodeMap& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomNamedNodeMap object:
          QDomNamedNodeMap_Wrapper* ret = new QDomNamedNodeMap_Wrapper(handler, new QDomNamedNodeMap(v), true);

          // JS: new QDomNamedNodeMap('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomNamedNodeMap");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomNamedNodeMap is undefined. Use QDomNamedNodeMap_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomNamedNodeMap('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomNamedNodeMap(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomNamedNodeMap RJSHelper::js2cpp_QDomNamedNodeMap(RJSApi& handler, const QJSValue& v) {
          /*
          QDomNamedNodeMap_Wrapper* wrapper = getWrapper<QDomNamedNodeMap_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomNamedNodeMap: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomNamedNodeMap();
          }
          //return *(QDomNamedNodeMap*)wrapper->getWrappedVoid();
          QDomNamedNodeMap* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomNamedNodeMap: wrapped pointer is NULL";
              return QDomNamedNodeMap();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomNamedNodeMap: not a QObject";
              return QDomNamedNodeMap();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomNamedNodeMap_ptr: no wrapper";
              handler.trace();
              return QDomNamedNodeMap();
          }
          //QDomNamedNodeMap* ret = getWrapped_QDomNamedNodeMap(wrapper);
          QDomNamedNodeMap* ret = QDomNamedNodeMap_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomNamedNodeMap();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomNamedNodeMap(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomNamedNodeMap: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomNamedNodeMap::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomNode(RJSApi& handler, const QDomNode* v) {
          QJSEngine* engine = handler.getEngine();
          QDomNode_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomNode_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomNode object:
              ret = new QDomNode_Wrapper(handler, new QDomNode(*v), true);
          }

          // JS: new QDomNode('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomNode");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomNode is undefined. Use QDomNode_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomNode('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomNode(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomNode(RJSApi& handler, const QDomNode& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomNode object:
          QDomNode_Wrapper* ret = new QDomNode_Wrapper(handler, new QDomNode(v), true);

          // JS: new QDomNode('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomNode");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomNode is undefined. Use QDomNode_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomNode('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomNode(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomNode RJSHelper::js2cpp_QDomNode(RJSApi& handler, const QJSValue& v) {
          /*
          QDomNode_Wrapper* wrapper = getWrapper<QDomNode_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomNode: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomNode();
          }
          //return *(QDomNode*)wrapper->getWrappedVoid();
          QDomNode* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomNode: wrapped pointer is NULL";
              return QDomNode();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomNode: not a QObject";
              return QDomNode();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomNode_ptr: no wrapper";
              handler.trace();
              return QDomNode();
          }
          //QDomNode* ret = getWrapped_QDomNode(wrapper);
          QDomNode* ret = QDomNode_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomNode();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomNode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomNode: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomNode::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomNodeList(RJSApi& handler, const QDomNodeList* v) {
          QJSEngine* engine = handler.getEngine();
          QDomNodeList_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomNodeList_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomNodeList object:
              ret = new QDomNodeList_Wrapper(handler, new QDomNodeList(*v), true);
          }

          // JS: new QDomNodeList('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomNodeList");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomNodeList is undefined. Use QDomNodeList_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomNodeList('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomNodeList(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomNodeList(RJSApi& handler, const QDomNodeList& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomNodeList object:
          QDomNodeList_Wrapper* ret = new QDomNodeList_Wrapper(handler, new QDomNodeList(v), true);

          // JS: new QDomNodeList('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomNodeList");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomNodeList is undefined. Use QDomNodeList_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomNodeList('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomNodeList(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomNodeList RJSHelper::js2cpp_QDomNodeList(RJSApi& handler, const QJSValue& v) {
          /*
          QDomNodeList_Wrapper* wrapper = getWrapper<QDomNodeList_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomNodeList: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomNodeList();
          }
          //return *(QDomNodeList*)wrapper->getWrappedVoid();
          QDomNodeList* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomNodeList: wrapped pointer is NULL";
              return QDomNodeList();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomNodeList: not a QObject";
              return QDomNodeList();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomNodeList_ptr: no wrapper";
              handler.trace();
              return QDomNodeList();
          }
          //QDomNodeList* ret = getWrapped_QDomNodeList(wrapper);
          QDomNodeList* ret = QDomNodeList_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomNodeList();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomNodeList(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomNodeList: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomNodeList::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomNotation(RJSApi& handler, const QDomNotation* v) {
          QJSEngine* engine = handler.getEngine();
          QDomNotation_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomNotation_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomNotation object:
              ret = new QDomNotation_Wrapper(handler, new QDomNotation(*v), true);
          }

          // JS: new QDomNotation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomNotation");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomNotation is undefined. Use QDomNotation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomNotation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomNotation(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomNotation(RJSApi& handler, const QDomNotation& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomNotation object:
          QDomNotation_Wrapper* ret = new QDomNotation_Wrapper(handler, new QDomNotation(v), true);

          // JS: new QDomNotation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomNotation");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomNotation is undefined. Use QDomNotation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomNotation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomNotation(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomNotation RJSHelper::js2cpp_QDomNotation(RJSApi& handler, const QJSValue& v) {
          /*
          QDomNotation_Wrapper* wrapper = getWrapper<QDomNotation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomNotation: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomNotation();
          }
          //return *(QDomNotation*)wrapper->getWrappedVoid();
          QDomNotation* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomNotation: wrapped pointer is NULL";
              return QDomNotation();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomNotation: not a QObject";
              return QDomNotation();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomNotation_ptr: no wrapper";
              handler.trace();
              return QDomNotation();
          }
          //QDomNotation* ret = getWrapped_QDomNotation(wrapper);
          QDomNotation* ret = QDomNotation_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomNotation();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomNotation(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomNotation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomNotation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomProcessingInstruction(RJSApi& handler, const QDomProcessingInstruction* v) {
          QJSEngine* engine = handler.getEngine();
          QDomProcessingInstruction_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomProcessingInstruction_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomProcessingInstruction object:
              ret = new QDomProcessingInstruction_Wrapper(handler, new QDomProcessingInstruction(*v), true);
          }

          // JS: new QDomProcessingInstruction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomProcessingInstruction");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomProcessingInstruction is undefined. Use QDomProcessingInstruction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomProcessingInstruction('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomProcessingInstruction(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomProcessingInstruction(RJSApi& handler, const QDomProcessingInstruction& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomProcessingInstruction object:
          QDomProcessingInstruction_Wrapper* ret = new QDomProcessingInstruction_Wrapper(handler, new QDomProcessingInstruction(v), true);

          // JS: new QDomProcessingInstruction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomProcessingInstruction");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomProcessingInstruction is undefined. Use QDomProcessingInstruction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomProcessingInstruction('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomProcessingInstruction(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomProcessingInstruction RJSHelper::js2cpp_QDomProcessingInstruction(RJSApi& handler, const QJSValue& v) {
          /*
          QDomProcessingInstruction_Wrapper* wrapper = getWrapper<QDomProcessingInstruction_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomProcessingInstruction: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomProcessingInstruction();
          }
          //return *(QDomProcessingInstruction*)wrapper->getWrappedVoid();
          QDomProcessingInstruction* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomProcessingInstruction: wrapped pointer is NULL";
              return QDomProcessingInstruction();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomProcessingInstruction: not a QObject";
              return QDomProcessingInstruction();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomProcessingInstruction_ptr: no wrapper";
              handler.trace();
              return QDomProcessingInstruction();
          }
          //QDomProcessingInstruction* ret = getWrapped_QDomProcessingInstruction(wrapper);
          QDomProcessingInstruction* ret = QDomProcessingInstruction_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomProcessingInstruction();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomProcessingInstruction(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomProcessingInstruction: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomProcessingInstruction::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomText(RJSApi& handler, const QDomText* v) {
          QJSEngine* engine = handler.getEngine();
          QDomText_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomText_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomText object:
              ret = new QDomText_Wrapper(handler, new QDomText(*v), true);
          }

          // JS: new QDomText('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomText");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomText is undefined. Use QDomText_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomText('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomText(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomText(RJSApi& handler, const QDomText& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomText object:
          QDomText_Wrapper* ret = new QDomText_Wrapper(handler, new QDomText(v), true);

          // JS: new QDomText('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomText");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomText is undefined. Use QDomText_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomText('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomText(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomText RJSHelper::js2cpp_QDomText(RJSApi& handler, const QJSValue& v) {
          /*
          QDomText_Wrapper* wrapper = getWrapper<QDomText_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomText: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomText();
          }
          //return *(QDomText*)wrapper->getWrappedVoid();
          QDomText* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomText: wrapped pointer is NULL";
              return QDomText();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomText: not a QObject";
              return QDomText();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomText_ptr: no wrapper";
              handler.trace();
              return QDomText();
          }
          //QDomText* ret = getWrapped_QDomText(wrapper);
          QDomText* ret = QDomText_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomText();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomText(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomText: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomText::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QEasingCurve(RJSApi& handler, const QEasingCurve* v) {
          QJSEngine* engine = handler.getEngine();
          QEasingCurve_Wrapper* ret;

          if (v==nullptr) {
              ret = new QEasingCurve_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QEasingCurve object:
              ret = new QEasingCurve_Wrapper(handler, new QEasingCurve(*v), true);
          }

          // JS: new QEasingCurve('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QEasingCurve");
          if (cl.isUndefined()) {
              qWarning() << "Class QEasingCurve is undefined. Use QEasingCurve_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QEasingCurve('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QEasingCurve(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QEasingCurve(RJSApi& handler, const QEasingCurve& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QEasingCurve object:
          QEasingCurve_Wrapper* ret = new QEasingCurve_Wrapper(handler, new QEasingCurve(v), true);

          // JS: new QEasingCurve('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QEasingCurve");
          if (cl.isUndefined()) {
              qWarning() << "Class QEasingCurve is undefined. Use QEasingCurve_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QEasingCurve('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QEasingCurve(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QEasingCurve RJSHelper::js2cpp_QEasingCurve(RJSApi& handler, const QJSValue& v) {
          /*
          QEasingCurve_Wrapper* wrapper = getWrapper<QEasingCurve_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QEasingCurve: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QEasingCurve();
          }
          //return *(QEasingCurve*)wrapper->getWrappedVoid();
          QEasingCurve* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QEasingCurve: wrapped pointer is NULL";
              return QEasingCurve();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QEasingCurve: not a QObject";
              return QEasingCurve();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QEasingCurve_ptr: no wrapper";
              handler.trace();
              return QEasingCurve();
          }
          //QEasingCurve* ret = getWrapped_QEasingCurve(wrapper);
          QEasingCurve* ret = QEasingCurve_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QEasingCurve();
          }
          return *ret;
      }

      bool RJSHelper::is_QEasingCurve(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QEasingCurve: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QEasingCurve::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QEventPoint(RJSApi& handler, const QEventPoint* v) {
          QJSEngine* engine = handler.getEngine();
          QEventPoint_Wrapper* ret;

          if (v==nullptr) {
              ret = new QEventPoint_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QEventPoint object:
              ret = new QEventPoint_Wrapper(handler, new QEventPoint(*v), true);
          }

          // JS: new QEventPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QEventPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class QEventPoint is undefined. Use QEventPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QEventPoint('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QEventPoint(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QEventPoint(RJSApi& handler, const QEventPoint& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QEventPoint object:
          QEventPoint_Wrapper* ret = new QEventPoint_Wrapper(handler, new QEventPoint(v), true);

          // JS: new QEventPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QEventPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class QEventPoint is undefined. Use QEventPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QEventPoint('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QEventPoint(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QEventPoint RJSHelper::js2cpp_QEventPoint(RJSApi& handler, const QJSValue& v) {
          /*
          QEventPoint_Wrapper* wrapper = getWrapper<QEventPoint_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QEventPoint: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QEventPoint();
          }
          //return *(QEventPoint*)wrapper->getWrappedVoid();
          QEventPoint* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QEventPoint: wrapped pointer is NULL";
              return QEventPoint();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QEventPoint: not a QObject";
              return QEventPoint();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QEventPoint_ptr: no wrapper";
              handler.trace();
              return QEventPoint();
          }
          //QEventPoint* ret = getWrapped_QEventPoint(wrapper);
          QEventPoint* ret = QEventPoint_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QEventPoint();
          }
          return *ret;
      }

      bool RJSHelper::is_QEventPoint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QEventPoint: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QEventPoint::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QFileInfo(RJSApi& handler, const QFileInfo* v) {
          QJSEngine* engine = handler.getEngine();
          QFileInfo_Wrapper* ret;

          if (v==nullptr) {
              ret = new QFileInfo_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QFileInfo object:
              ret = new QFileInfo_Wrapper(handler, new QFileInfo(*v), true);
          }

          // JS: new QFileInfo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFileInfo");
          if (cl.isUndefined()) {
              qWarning() << "Class QFileInfo is undefined. Use QFileInfo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFileInfo('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFileInfo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFileInfo(RJSApi& handler, const QFileInfo& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QFileInfo object:
          QFileInfo_Wrapper* ret = new QFileInfo_Wrapper(handler, new QFileInfo(v), true);

          // JS: new QFileInfo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFileInfo");
          if (cl.isUndefined()) {
              qWarning() << "Class QFileInfo is undefined. Use QFileInfo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFileInfo('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFileInfo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QFileInfo RJSHelper::js2cpp_QFileInfo(RJSApi& handler, const QJSValue& v) {
          /*
          QFileInfo_Wrapper* wrapper = getWrapper<QFileInfo_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFileInfo: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QFileInfo();
          }
          //return *(QFileInfo*)wrapper->getWrappedVoid();
          QFileInfo* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QFileInfo: wrapped pointer is NULL";
              return QFileInfo();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFileInfo: not a QObject";
              return QFileInfo();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFileInfo_ptr: no wrapper";
              handler.trace();
              return QFileInfo();
          }
          //QFileInfo* ret = getWrapped_QFileInfo(wrapper);
          QFileInfo* ret = QFileInfo_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QFileInfo();
          }
          return *ret;
      }

      bool RJSHelper::is_QFileInfo(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFileInfo: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QFileInfo::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QFont(RJSApi& handler, const QFont* v) {
          QJSEngine* engine = handler.getEngine();
          QFont_Wrapper* ret;

          if (v==nullptr) {
              ret = new QFont_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QFont object:
              ret = new QFont_Wrapper(handler, new QFont(*v), true);
          }

          // JS: new QFont('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFont");
          if (cl.isUndefined()) {
              qWarning() << "Class QFont is undefined. Use QFont_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFont('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFont(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFont(RJSApi& handler, const QFont& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QFont object:
          QFont_Wrapper* ret = new QFont_Wrapper(handler, new QFont(v), true);

          // JS: new QFont('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFont");
          if (cl.isUndefined()) {
              qWarning() << "Class QFont is undefined. Use QFont_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFont('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFont(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QFont RJSHelper::js2cpp_QFont(RJSApi& handler, const QJSValue& v) {
          /*
          QFont_Wrapper* wrapper = getWrapper<QFont_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFont: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QFont();
          }
          //return *(QFont*)wrapper->getWrappedVoid();
          QFont* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QFont: wrapped pointer is NULL";
              return QFont();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFont: not a QObject";
              return QFont();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFont_ptr: no wrapper";
              handler.trace();
              return QFont();
          }
          //QFont* ret = getWrapped_QFont(wrapper);
          QFont* ret = QFont_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QFont();
          }
          return *ret;
      }

      bool RJSHelper::is_QFont(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFont: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QFont::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QFontDatabase(RJSApi& handler, const QFontDatabase* v) {
          QJSEngine* engine = handler.getEngine();
          QFontDatabase_Wrapper* ret;

          if (v==nullptr) {
              ret = new QFontDatabase_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QFontDatabase object:
              ret = new QFontDatabase_Wrapper(handler, new QFontDatabase(*v), true);
          }

          // JS: new QFontDatabase('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFontDatabase");
          if (cl.isUndefined()) {
              qWarning() << "Class QFontDatabase is undefined. Use QFontDatabase_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFontDatabase('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFontDatabase(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFontDatabase(RJSApi& handler, const QFontDatabase& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QFontDatabase object:
          QFontDatabase_Wrapper* ret = new QFontDatabase_Wrapper(handler, new QFontDatabase(v), true);

          // JS: new QFontDatabase('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFontDatabase");
          if (cl.isUndefined()) {
              qWarning() << "Class QFontDatabase is undefined. Use QFontDatabase_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFontDatabase('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFontDatabase(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QFontDatabase RJSHelper::js2cpp_QFontDatabase(RJSApi& handler, const QJSValue& v) {
          /*
          QFontDatabase_Wrapper* wrapper = getWrapper<QFontDatabase_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFontDatabase: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QFontDatabase();
          }
          //return *(QFontDatabase*)wrapper->getWrappedVoid();
          QFontDatabase* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QFontDatabase: wrapped pointer is NULL";
              return QFontDatabase();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFontDatabase: not a QObject";
              return QFontDatabase();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFontDatabase_ptr: no wrapper";
              handler.trace();
              return QFontDatabase();
          }
          //QFontDatabase* ret = getWrapped_QFontDatabase(wrapper);
          QFontDatabase* ret = QFontDatabase_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QFontDatabase();
          }
          return *ret;
      }

      bool RJSHelper::is_QFontDatabase(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFontDatabase: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QFontDatabase::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QGradient(RJSApi& handler, const QGradient* v) {
          QJSEngine* engine = handler.getEngine();
          QGradient_Wrapper* ret;

          if (v==nullptr) {
              ret = new QGradient_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QGradient object:
              ret = new QGradient_Wrapper(handler, new QGradient(*v), true);
          }

          // JS: new QGradient('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGradient");
          if (cl.isUndefined()) {
              qWarning() << "Class QGradient is undefined. Use QGradient_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGradient('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGradient(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGradient(RJSApi& handler, const QGradient& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QGradient object:
          QGradient_Wrapper* ret = new QGradient_Wrapper(handler, new QGradient(v), true);

          // JS: new QGradient('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGradient");
          if (cl.isUndefined()) {
              qWarning() << "Class QGradient is undefined. Use QGradient_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGradient('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGradient(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QGradient RJSHelper::js2cpp_QGradient(RJSApi& handler, const QJSValue& v) {
          /*
          QGradient_Wrapper* wrapper = getWrapper<QGradient_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGradient: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QGradient();
          }
          //return *(QGradient*)wrapper->getWrappedVoid();
          QGradient* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QGradient: wrapped pointer is NULL";
              return QGradient();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGradient: not a QObject";
              return QGradient();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGradient_ptr: no wrapper";
              handler.trace();
              return QGradient();
          }
          //QGradient* ret = getWrapped_QGradient(wrapper);
          QGradient* ret = QGradient_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QGradient();
          }
          return *ret;
      }

      bool RJSHelper::is_QGradient(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGradient: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QGradient::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QIcon(RJSApi& handler, const QIcon* v) {
          QJSEngine* engine = handler.getEngine();
          QIcon_Wrapper* ret;

          if (v==nullptr) {
              ret = new QIcon_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QIcon object:
              ret = new QIcon_Wrapper(handler, new QIcon(*v), true);
          }

          // JS: new QIcon('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QIcon");
          if (cl.isUndefined()) {
              qWarning() << "Class QIcon is undefined. Use QIcon_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QIcon('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QIcon(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QIcon(RJSApi& handler, const QIcon& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QIcon object:
          QIcon_Wrapper* ret = new QIcon_Wrapper(handler, new QIcon(v), true);

          // JS: new QIcon('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QIcon");
          if (cl.isUndefined()) {
              qWarning() << "Class QIcon is undefined. Use QIcon_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QIcon('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QIcon(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QIcon RJSHelper::js2cpp_QIcon(RJSApi& handler, const QJSValue& v) {
          /*
          QIcon_Wrapper* wrapper = getWrapper<QIcon_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QIcon: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QIcon();
          }
          //return *(QIcon*)wrapper->getWrappedVoid();
          QIcon* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QIcon: wrapped pointer is NULL";
              return QIcon();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QIcon: not a QObject";
              return QIcon();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QIcon_ptr: no wrapper";
              handler.trace();
              return QIcon();
          }
          //QIcon* ret = getWrapped_QIcon(wrapper);
          QIcon* ret = QIcon_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QIcon();
          }
          return *ret;
      }

      bool RJSHelper::is_QIcon(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QIcon: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QIcon::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QImage(RJSApi& handler, const QImage* v) {
          QJSEngine* engine = handler.getEngine();
          QImage_Wrapper* ret;

          if (v==nullptr) {
              ret = new QImage_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QImage object:
              ret = new QImage_Wrapper(handler, new QImage(*v), true);
          }

          // JS: new QImage('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QImage");
          if (cl.isUndefined()) {
              qWarning() << "Class QImage is undefined. Use QImage_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QImage('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QImage(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QImage(RJSApi& handler, const QImage& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QImage object:
          QImage_Wrapper* ret = new QImage_Wrapper(handler, new QImage(v), true);

          // JS: new QImage('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QImage");
          if (cl.isUndefined()) {
              qWarning() << "Class QImage is undefined. Use QImage_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QImage('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QImage(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QImage RJSHelper::js2cpp_QImage(RJSApi& handler, const QJSValue& v) {
          /*
          QImage_Wrapper* wrapper = getWrapper<QImage_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QImage: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QImage();
          }
          //return *(QImage*)wrapper->getWrappedVoid();
          QImage* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QImage: wrapped pointer is NULL";
              return QImage();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QImage: not a QObject";
              return QImage();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QImage_ptr: no wrapper";
              handler.trace();
              return QImage();
          }
          //QImage* ret = getWrapped_QImage(wrapper);
          QImage* ret = QImage_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QImage();
          }
          return *ret;
      }

      bool RJSHelper::is_QImage(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QImage: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QImage::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QItemSelection(RJSApi& handler, const QItemSelection* v) {
          QJSEngine* engine = handler.getEngine();
          QItemSelection_Wrapper* ret;

          if (v==nullptr) {
              ret = new QItemSelection_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QItemSelection object:
              ret = new QItemSelection_Wrapper(handler, new QItemSelection(*v), true);
          }

          // JS: new QItemSelection('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QItemSelection");
          if (cl.isUndefined()) {
              qWarning() << "Class QItemSelection is undefined. Use QItemSelection_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QItemSelection('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QItemSelection(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QItemSelection(RJSApi& handler, const QItemSelection& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QItemSelection object:
          QItemSelection_Wrapper* ret = new QItemSelection_Wrapper(handler, new QItemSelection(v), true);

          // JS: new QItemSelection('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QItemSelection");
          if (cl.isUndefined()) {
              qWarning() << "Class QItemSelection is undefined. Use QItemSelection_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QItemSelection('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QItemSelection(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QItemSelection RJSHelper::js2cpp_QItemSelection(RJSApi& handler, const QJSValue& v) {
          /*
          QItemSelection_Wrapper* wrapper = getWrapper<QItemSelection_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QItemSelection: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QItemSelection();
          }
          //return *(QItemSelection*)wrapper->getWrappedVoid();
          QItemSelection* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QItemSelection: wrapped pointer is NULL";
              return QItemSelection();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QItemSelection: not a QObject";
              return QItemSelection();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QItemSelection_ptr: no wrapper";
              handler.trace();
              return QItemSelection();
          }
          //QItemSelection* ret = getWrapped_QItemSelection(wrapper);
          QItemSelection* ret = QItemSelection_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QItemSelection();
          }
          return *ret;
      }

      bool RJSHelper::is_QItemSelection(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QItemSelection: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QItemSelection::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QKeyCombination(RJSApi& handler, const QKeyCombination* v) {
          QJSEngine* engine = handler.getEngine();
          QKeyCombination_Wrapper* ret;

          if (v==nullptr) {
              ret = new QKeyCombination_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QKeyCombination object:
              ret = new QKeyCombination_Wrapper(handler, new QKeyCombination(*v), true);
          }

          // JS: new QKeyCombination('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QKeyCombination");
          if (cl.isUndefined()) {
              qWarning() << "Class QKeyCombination is undefined. Use QKeyCombination_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QKeyCombination('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QKeyCombination(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QKeyCombination(RJSApi& handler, const QKeyCombination& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QKeyCombination object:
          QKeyCombination_Wrapper* ret = new QKeyCombination_Wrapper(handler, new QKeyCombination(v), true);

          // JS: new QKeyCombination('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QKeyCombination");
          if (cl.isUndefined()) {
              qWarning() << "Class QKeyCombination is undefined. Use QKeyCombination_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QKeyCombination('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QKeyCombination(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QKeyCombination RJSHelper::js2cpp_QKeyCombination(RJSApi& handler, const QJSValue& v) {
          /*
          QKeyCombination_Wrapper* wrapper = getWrapper<QKeyCombination_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QKeyCombination: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QKeyCombination();
          }
          //return *(QKeyCombination*)wrapper->getWrappedVoid();
          QKeyCombination* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QKeyCombination: wrapped pointer is NULL";
              return QKeyCombination();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QKeyCombination: not a QObject";
              return QKeyCombination();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QKeyCombination_ptr: no wrapper";
              handler.trace();
              return QKeyCombination();
          }
          //QKeyCombination* ret = getWrapped_QKeyCombination(wrapper);
          QKeyCombination* ret = QKeyCombination_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QKeyCombination();
          }
          return *ret;
      }

      bool RJSHelper::is_QKeyCombination(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QKeyCombination: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QKeyCombination::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QKeySequence(RJSApi& handler, const QKeySequence* v) {
          QJSEngine* engine = handler.getEngine();
          QKeySequence_Wrapper* ret;

          if (v==nullptr) {
              ret = new QKeySequence_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QKeySequence object:
              ret = new QKeySequence_Wrapper(handler, new QKeySequence(*v), true);
          }

          // JS: new QKeySequence('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QKeySequence");
          if (cl.isUndefined()) {
              qWarning() << "Class QKeySequence is undefined. Use QKeySequence_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QKeySequence('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QKeySequence(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QKeySequence(RJSApi& handler, const QKeySequence& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QKeySequence object:
          QKeySequence_Wrapper* ret = new QKeySequence_Wrapper(handler, new QKeySequence(v), true);

          // JS: new QKeySequence('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QKeySequence");
          if (cl.isUndefined()) {
              qWarning() << "Class QKeySequence is undefined. Use QKeySequence_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QKeySequence('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QKeySequence(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QKeySequence RJSHelper::js2cpp_QKeySequence(RJSApi& handler, const QJSValue& v) {
          /*
          QKeySequence_Wrapper* wrapper = getWrapper<QKeySequence_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QKeySequence: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QKeySequence();
          }
          //return *(QKeySequence*)wrapper->getWrappedVoid();
          QKeySequence* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QKeySequence: wrapped pointer is NULL";
              return QKeySequence();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QKeySequence: not a QObject";
              return QKeySequence();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QKeySequence_ptr: no wrapper";
              handler.trace();
              return QKeySequence();
          }
          //QKeySequence* ret = getWrapped_QKeySequence(wrapper);
          QKeySequence* ret = QKeySequence_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QKeySequence();
          }
          return *ret;
      }

      bool RJSHelper::is_QKeySequence(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QKeySequence: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QKeySequence::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QLine(RJSApi& handler, const QLine* v) {
          QJSEngine* engine = handler.getEngine();
          QLine_Wrapper* ret;

          if (v==nullptr) {
              ret = new QLine_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QLine object:
              ret = new QLine_Wrapper(handler, new QLine(*v), true);
          }

          // JS: new QLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLine");
          if (cl.isUndefined()) {
              qWarning() << "Class QLine is undefined. Use QLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QLine(RJSApi& handler, const QLine& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QLine object:
          QLine_Wrapper* ret = new QLine_Wrapper(handler, new QLine(v), true);

          // JS: new QLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLine");
          if (cl.isUndefined()) {
              qWarning() << "Class QLine is undefined. Use QLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QLine RJSHelper::js2cpp_QLine(RJSApi& handler, const QJSValue& v) {
          /*
          QLine_Wrapper* wrapper = getWrapper<QLine_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLine: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QLine();
          }
          //return *(QLine*)wrapper->getWrappedVoid();
          QLine* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QLine: wrapped pointer is NULL";
              return QLine();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QLine: not a QObject";
              return QLine();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLine_ptr: no wrapper";
              handler.trace();
              return QLine();
          }
          //QLine* ret = getWrapped_QLine(wrapper);
          QLine* ret = QLine_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QLine();
          }
          return *ret;
      }

      bool RJSHelper::is_QLine(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QLine: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QLine::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QLineF(RJSApi& handler, const QLineF* v) {
          QJSEngine* engine = handler.getEngine();
          QLineF_Wrapper* ret;

          if (v==nullptr) {
              ret = new QLineF_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QLineF object:
              ret = new QLineF_Wrapper(handler, new QLineF(*v), true);
          }

          // JS: new QLineF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLineF");
          if (cl.isUndefined()) {
              qWarning() << "Class QLineF is undefined. Use QLineF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLineF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLineF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QLineF(RJSApi& handler, const QLineF& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QLineF object:
          QLineF_Wrapper* ret = new QLineF_Wrapper(handler, new QLineF(v), true);

          // JS: new QLineF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLineF");
          if (cl.isUndefined()) {
              qWarning() << "Class QLineF is undefined. Use QLineF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLineF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLineF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QLineF RJSHelper::js2cpp_QLineF(RJSApi& handler, const QJSValue& v) {
          /*
          QLineF_Wrapper* wrapper = getWrapper<QLineF_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLineF: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QLineF();
          }
          //return *(QLineF*)wrapper->getWrappedVoid();
          QLineF* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QLineF: wrapped pointer is NULL";
              return QLineF();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QLineF: not a QObject";
              return QLineF();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLineF_ptr: no wrapper";
              handler.trace();
              return QLineF();
          }
          //QLineF* ret = getWrapped_QLineF(wrapper);
          QLineF* ret = QLineF_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QLineF();
          }
          return *ret;
      }

      bool RJSHelper::is_QLineF(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QLineF: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QLineF::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QLinearGradient(RJSApi& handler, const QLinearGradient* v) {
          QJSEngine* engine = handler.getEngine();
          QLinearGradient_Wrapper* ret;

          if (v==nullptr) {
              ret = new QLinearGradient_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QLinearGradient object:
              ret = new QLinearGradient_Wrapper(handler, new QLinearGradient(*v), true);
          }

          // JS: new QLinearGradient('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLinearGradient");
          if (cl.isUndefined()) {
              qWarning() << "Class QLinearGradient is undefined. Use QLinearGradient_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLinearGradient('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLinearGradient(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QLinearGradient(RJSApi& handler, const QLinearGradient& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QLinearGradient object:
          QLinearGradient_Wrapper* ret = new QLinearGradient_Wrapper(handler, new QLinearGradient(v), true);

          // JS: new QLinearGradient('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLinearGradient");
          if (cl.isUndefined()) {
              qWarning() << "Class QLinearGradient is undefined. Use QLinearGradient_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLinearGradient('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLinearGradient(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QLinearGradient RJSHelper::js2cpp_QLinearGradient(RJSApi& handler, const QJSValue& v) {
          /*
          QLinearGradient_Wrapper* wrapper = getWrapper<QLinearGradient_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLinearGradient: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QLinearGradient();
          }
          //return *(QLinearGradient*)wrapper->getWrappedVoid();
          QLinearGradient* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QLinearGradient: wrapped pointer is NULL";
              return QLinearGradient();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QLinearGradient: not a QObject";
              return QLinearGradient();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLinearGradient_ptr: no wrapper";
              handler.trace();
              return QLinearGradient();
          }
          //QLinearGradient* ret = getWrapped_QLinearGradient(wrapper);
          QLinearGradient* ret = QLinearGradient_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QLinearGradient();
          }
          return *ret;
      }

      bool RJSHelper::is_QLinearGradient(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QLinearGradient: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QLinearGradient::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QLocale(RJSApi& handler, const QLocale* v) {
          QJSEngine* engine = handler.getEngine();
          QLocale_Wrapper* ret;

          if (v==nullptr) {
              ret = new QLocale_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QLocale object:
              ret = new QLocale_Wrapper(handler, new QLocale(*v), true);
          }

          // JS: new QLocale('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLocale");
          if (cl.isUndefined()) {
              qWarning() << "Class QLocale is undefined. Use QLocale_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLocale('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLocale(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QLocale(RJSApi& handler, const QLocale& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QLocale object:
          QLocale_Wrapper* ret = new QLocale_Wrapper(handler, new QLocale(v), true);

          // JS: new QLocale('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLocale");
          if (cl.isUndefined()) {
              qWarning() << "Class QLocale is undefined. Use QLocale_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLocale('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLocale(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QLocale RJSHelper::js2cpp_QLocale(RJSApi& handler, const QJSValue& v) {
          /*
          QLocale_Wrapper* wrapper = getWrapper<QLocale_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLocale: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QLocale();
          }
          //return *(QLocale*)wrapper->getWrappedVoid();
          QLocale* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QLocale: wrapped pointer is NULL";
              return QLocale();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QLocale: not a QObject";
              return QLocale();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLocale_ptr: no wrapper";
              handler.trace();
              return QLocale();
          }
          //QLocale* ret = getWrapped_QLocale(wrapper);
          QLocale* ret = QLocale_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QLocale();
          }
          return *ret;
      }

      bool RJSHelper::is_QLocale(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QLocale: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QLocale::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QMargins(RJSApi& handler, const QMargins* v) {
          QJSEngine* engine = handler.getEngine();
          QMargins_Wrapper* ret;

          if (v==nullptr) {
              ret = new QMargins_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QMargins object:
              ret = new QMargins_Wrapper(handler, new QMargins(*v), true);
          }

          // JS: new QMargins('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMargins");
          if (cl.isUndefined()) {
              qWarning() << "Class QMargins is undefined. Use QMargins_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMargins('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMargins(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMargins(RJSApi& handler, const QMargins& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QMargins object:
          QMargins_Wrapper* ret = new QMargins_Wrapper(handler, new QMargins(v), true);

          // JS: new QMargins('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMargins");
          if (cl.isUndefined()) {
              qWarning() << "Class QMargins is undefined. Use QMargins_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMargins('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMargins(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QMargins RJSHelper::js2cpp_QMargins(RJSApi& handler, const QJSValue& v) {
          /*
          QMargins_Wrapper* wrapper = getWrapper<QMargins_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMargins: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QMargins();
          }
          //return *(QMargins*)wrapper->getWrappedVoid();
          QMargins* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QMargins: wrapped pointer is NULL";
              return QMargins();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMargins: not a QObject";
              return QMargins();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMargins_ptr: no wrapper";
              handler.trace();
              return QMargins();
          }
          //QMargins* ret = getWrapped_QMargins(wrapper);
          QMargins* ret = QMargins_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QMargins();
          }
          return *ret;
      }

      bool RJSHelper::is_QMargins(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMargins: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QMargins::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QMarginsF(RJSApi& handler, const QMarginsF* v) {
          QJSEngine* engine = handler.getEngine();
          QMarginsF_Wrapper* ret;

          if (v==nullptr) {
              ret = new QMarginsF_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QMarginsF object:
              ret = new QMarginsF_Wrapper(handler, new QMarginsF(*v), true);
          }

          // JS: new QMarginsF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMarginsF");
          if (cl.isUndefined()) {
              qWarning() << "Class QMarginsF is undefined. Use QMarginsF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMarginsF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMarginsF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMarginsF(RJSApi& handler, const QMarginsF& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QMarginsF object:
          QMarginsF_Wrapper* ret = new QMarginsF_Wrapper(handler, new QMarginsF(v), true);

          // JS: new QMarginsF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMarginsF");
          if (cl.isUndefined()) {
              qWarning() << "Class QMarginsF is undefined. Use QMarginsF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMarginsF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMarginsF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QMarginsF RJSHelper::js2cpp_QMarginsF(RJSApi& handler, const QJSValue& v) {
          /*
          QMarginsF_Wrapper* wrapper = getWrapper<QMarginsF_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMarginsF: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QMarginsF();
          }
          //return *(QMarginsF*)wrapper->getWrappedVoid();
          QMarginsF* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QMarginsF: wrapped pointer is NULL";
              return QMarginsF();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMarginsF: not a QObject";
              return QMarginsF();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMarginsF_ptr: no wrapper";
              handler.trace();
              return QMarginsF();
          }
          //QMarginsF* ret = getWrapped_QMarginsF(wrapper);
          QMarginsF* ret = QMarginsF_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QMarginsF();
          }
          return *ret;
      }

      bool RJSHelper::is_QMarginsF(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMarginsF: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QMarginsF::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QModelIndex(RJSApi& handler, const QModelIndex* v) {
          QJSEngine* engine = handler.getEngine();
          QModelIndex_Wrapper* ret;

          if (v==nullptr) {
              ret = new QModelIndex_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QModelIndex object:
              ret = new QModelIndex_Wrapper(handler, new QModelIndex(*v), true);
          }

          // JS: new QModelIndex('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QModelIndex");
          if (cl.isUndefined()) {
              qWarning() << "Class QModelIndex is undefined. Use QModelIndex_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QModelIndex('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QModelIndex(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QModelIndex(RJSApi& handler, const QModelIndex& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QModelIndex object:
          QModelIndex_Wrapper* ret = new QModelIndex_Wrapper(handler, new QModelIndex(v), true);

          // JS: new QModelIndex('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QModelIndex");
          if (cl.isUndefined()) {
              qWarning() << "Class QModelIndex is undefined. Use QModelIndex_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QModelIndex('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QModelIndex(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QModelIndex RJSHelper::js2cpp_QModelIndex(RJSApi& handler, const QJSValue& v) {
          /*
          QModelIndex_Wrapper* wrapper = getWrapper<QModelIndex_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QModelIndex: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QModelIndex();
          }
          //return *(QModelIndex*)wrapper->getWrappedVoid();
          QModelIndex* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QModelIndex: wrapped pointer is NULL";
              return QModelIndex();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QModelIndex: not a QObject";
              return QModelIndex();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QModelIndex_ptr: no wrapper";
              handler.trace();
              return QModelIndex();
          }
          //QModelIndex* ret = getWrapped_QModelIndex(wrapper);
          QModelIndex* ret = QModelIndex_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QModelIndex();
          }
          return *ret;
      }

      bool RJSHelper::is_QModelIndex(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QModelIndex: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QModelIndex::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPageLayout(RJSApi& handler, const QPageLayout* v) {
          QJSEngine* engine = handler.getEngine();
          QPageLayout_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPageLayout_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPageLayout object:
              ret = new QPageLayout_Wrapper(handler, new QPageLayout(*v), true);
          }

          // JS: new QPageLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPageLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QPageLayout is undefined. Use QPageLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPageLayout('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPageLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPageLayout(RJSApi& handler, const QPageLayout& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPageLayout object:
          QPageLayout_Wrapper* ret = new QPageLayout_Wrapper(handler, new QPageLayout(v), true);

          // JS: new QPageLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPageLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QPageLayout is undefined. Use QPageLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPageLayout('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPageLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPageLayout RJSHelper::js2cpp_QPageLayout(RJSApi& handler, const QJSValue& v) {
          /*
          QPageLayout_Wrapper* wrapper = getWrapper<QPageLayout_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPageLayout: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPageLayout();
          }
          //return *(QPageLayout*)wrapper->getWrappedVoid();
          QPageLayout* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPageLayout: wrapped pointer is NULL";
              return QPageLayout();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPageLayout: not a QObject";
              return QPageLayout();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPageLayout_ptr: no wrapper";
              handler.trace();
              return QPageLayout();
          }
          //QPageLayout* ret = getWrapped_QPageLayout(wrapper);
          QPageLayout* ret = QPageLayout_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPageLayout();
          }
          return *ret;
      }

      bool RJSHelper::is_QPageLayout(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPageLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPageLayout::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPageRanges(RJSApi& handler, const QPageRanges* v) {
          QJSEngine* engine = handler.getEngine();
          QPageRanges_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPageRanges_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPageRanges object:
              ret = new QPageRanges_Wrapper(handler, new QPageRanges(*v), true);
          }

          // JS: new QPageRanges('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPageRanges");
          if (cl.isUndefined()) {
              qWarning() << "Class QPageRanges is undefined. Use QPageRanges_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPageRanges('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPageRanges(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPageRanges(RJSApi& handler, const QPageRanges& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPageRanges object:
          QPageRanges_Wrapper* ret = new QPageRanges_Wrapper(handler, new QPageRanges(v), true);

          // JS: new QPageRanges('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPageRanges");
          if (cl.isUndefined()) {
              qWarning() << "Class QPageRanges is undefined. Use QPageRanges_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPageRanges('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPageRanges(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPageRanges RJSHelper::js2cpp_QPageRanges(RJSApi& handler, const QJSValue& v) {
          /*
          QPageRanges_Wrapper* wrapper = getWrapper<QPageRanges_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPageRanges: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPageRanges();
          }
          //return *(QPageRanges*)wrapper->getWrappedVoid();
          QPageRanges* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPageRanges: wrapped pointer is NULL";
              return QPageRanges();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPageRanges: not a QObject";
              return QPageRanges();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPageRanges_ptr: no wrapper";
              handler.trace();
              return QPageRanges();
          }
          //QPageRanges* ret = getWrapped_QPageRanges(wrapper);
          QPageRanges* ret = QPageRanges_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPageRanges();
          }
          return *ret;
      }

      bool RJSHelper::is_QPageRanges(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPageRanges: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPageRanges::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPageSize(RJSApi& handler, const QPageSize* v) {
          QJSEngine* engine = handler.getEngine();
          QPageSize_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPageSize_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPageSize object:
              ret = new QPageSize_Wrapper(handler, new QPageSize(*v), true);
          }

          // JS: new QPageSize('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPageSize");
          if (cl.isUndefined()) {
              qWarning() << "Class QPageSize is undefined. Use QPageSize_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPageSize('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPageSize(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPageSize(RJSApi& handler, const QPageSize& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPageSize object:
          QPageSize_Wrapper* ret = new QPageSize_Wrapper(handler, new QPageSize(v), true);

          // JS: new QPageSize('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPageSize");
          if (cl.isUndefined()) {
              qWarning() << "Class QPageSize is undefined. Use QPageSize_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPageSize('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPageSize(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPageSize RJSHelper::js2cpp_QPageSize(RJSApi& handler, const QJSValue& v) {
          /*
          QPageSize_Wrapper* wrapper = getWrapper<QPageSize_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPageSize: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPageSize();
          }
          //return *(QPageSize*)wrapper->getWrappedVoid();
          QPageSize* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPageSize: wrapped pointer is NULL";
              return QPageSize();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPageSize: not a QObject";
              return QPageSize();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPageSize_ptr: no wrapper";
              handler.trace();
              return QPageSize();
          }
          //QPageSize* ret = getWrapped_QPageSize(wrapper);
          QPageSize* ret = QPageSize_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPageSize();
          }
          return *ret;
      }

      bool RJSHelper::is_QPageSize(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPageSize: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPageSize::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPainterPath(RJSApi& handler, const QPainterPath* v) {
          QJSEngine* engine = handler.getEngine();
          QPainterPath_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPainterPath_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPainterPath object:
              ret = new QPainterPath_Wrapper(handler, new QPainterPath(*v), true);
          }

          // JS: new QPainterPath('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPainterPath");
          if (cl.isUndefined()) {
              qWarning() << "Class QPainterPath is undefined. Use QPainterPath_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPainterPath('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPainterPath(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPainterPath(RJSApi& handler, const QPainterPath& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPainterPath object:
          QPainterPath_Wrapper* ret = new QPainterPath_Wrapper(handler, new QPainterPath(v), true);

          // JS: new QPainterPath('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPainterPath");
          if (cl.isUndefined()) {
              qWarning() << "Class QPainterPath is undefined. Use QPainterPath_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPainterPath('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPainterPath(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPainterPath RJSHelper::js2cpp_QPainterPath(RJSApi& handler, const QJSValue& v) {
          /*
          QPainterPath_Wrapper* wrapper = getWrapper<QPainterPath_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPainterPath: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPainterPath();
          }
          //return *(QPainterPath*)wrapper->getWrappedVoid();
          QPainterPath* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPainterPath: wrapped pointer is NULL";
              return QPainterPath();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPainterPath: not a QObject";
              return QPainterPath();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPainterPath_ptr: no wrapper";
              handler.trace();
              return QPainterPath();
          }
          //QPainterPath* ret = getWrapped_QPainterPath(wrapper);
          QPainterPath* ret = QPainterPath_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPainterPath();
          }
          return *ret;
      }

      bool RJSHelper::is_QPainterPath(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPainterPath: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPainterPath::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPalette(RJSApi& handler, const QPalette* v) {
          QJSEngine* engine = handler.getEngine();
          QPalette_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPalette_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPalette object:
              ret = new QPalette_Wrapper(handler, new QPalette(*v), true);
          }

          // JS: new QPalette('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPalette");
          if (cl.isUndefined()) {
              qWarning() << "Class QPalette is undefined. Use QPalette_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPalette('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPalette(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPalette(RJSApi& handler, const QPalette& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPalette object:
          QPalette_Wrapper* ret = new QPalette_Wrapper(handler, new QPalette(v), true);

          // JS: new QPalette('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPalette");
          if (cl.isUndefined()) {
              qWarning() << "Class QPalette is undefined. Use QPalette_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPalette('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPalette(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPalette RJSHelper::js2cpp_QPalette(RJSApi& handler, const QJSValue& v) {
          /*
          QPalette_Wrapper* wrapper = getWrapper<QPalette_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPalette: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPalette();
          }
          //return *(QPalette*)wrapper->getWrappedVoid();
          QPalette* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPalette: wrapped pointer is NULL";
              return QPalette();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPalette: not a QObject";
              return QPalette();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPalette_ptr: no wrapper";
              handler.trace();
              return QPalette();
          }
          //QPalette* ret = getWrapped_QPalette(wrapper);
          QPalette* ret = QPalette_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPalette();
          }
          return *ret;
      }

      bool RJSHelper::is_QPalette(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPalette: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPalette::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPen(RJSApi& handler, const QPen* v) {
          QJSEngine* engine = handler.getEngine();
          QPen_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPen_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPen object:
              ret = new QPen_Wrapper(handler, new QPen(*v), true);
          }

          // JS: new QPen('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPen");
          if (cl.isUndefined()) {
              qWarning() << "Class QPen is undefined. Use QPen_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPen('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPen(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPen(RJSApi& handler, const QPen& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPen object:
          QPen_Wrapper* ret = new QPen_Wrapper(handler, new QPen(v), true);

          // JS: new QPen('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPen");
          if (cl.isUndefined()) {
              qWarning() << "Class QPen is undefined. Use QPen_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPen('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPen(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPen RJSHelper::js2cpp_QPen(RJSApi& handler, const QJSValue& v) {
          /*
          QPen_Wrapper* wrapper = getWrapper<QPen_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPen: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPen();
          }
          //return *(QPen*)wrapper->getWrappedVoid();
          QPen* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPen: wrapped pointer is NULL";
              return QPen();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPen: not a QObject";
              return QPen();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPen_ptr: no wrapper";
              handler.trace();
              return QPen();
          }
          //QPen* ret = getWrapped_QPen(wrapper);
          QPen* ret = QPen_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPen();
          }
          return *ret;
      }

      bool RJSHelper::is_QPen(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPen: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPen::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPicture(RJSApi& handler, const QPicture* v) {
          QJSEngine* engine = handler.getEngine();
          QPicture_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPicture_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPicture object:
              ret = new QPicture_Wrapper(handler, new QPicture(*v), true);
          }

          // JS: new QPicture('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPicture");
          if (cl.isUndefined()) {
              qWarning() << "Class QPicture is undefined. Use QPicture_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPicture('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPicture(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPicture(RJSApi& handler, const QPicture& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPicture object:
          QPicture_Wrapper* ret = new QPicture_Wrapper(handler, new QPicture(v), true);

          // JS: new QPicture('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPicture");
          if (cl.isUndefined()) {
              qWarning() << "Class QPicture is undefined. Use QPicture_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPicture('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPicture(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPicture RJSHelper::js2cpp_QPicture(RJSApi& handler, const QJSValue& v) {
          /*
          QPicture_Wrapper* wrapper = getWrapper<QPicture_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPicture: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPicture();
          }
          //return *(QPicture*)wrapper->getWrappedVoid();
          QPicture* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPicture: wrapped pointer is NULL";
              return QPicture();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPicture: not a QObject";
              return QPicture();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPicture_ptr: no wrapper";
              handler.trace();
              return QPicture();
          }
          //QPicture* ret = getWrapped_QPicture(wrapper);
          QPicture* ret = QPicture_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPicture();
          }
          return *ret;
      }

      bool RJSHelper::is_QPicture(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPicture: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPicture::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPixmap(RJSApi& handler, const QPixmap* v) {
          QJSEngine* engine = handler.getEngine();
          QPixmap_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPixmap_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPixmap object:
              ret = new QPixmap_Wrapper(handler, new QPixmap(*v), true);
          }

          // JS: new QPixmap('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPixmap");
          if (cl.isUndefined()) {
              qWarning() << "Class QPixmap is undefined. Use QPixmap_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPixmap('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPixmap(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPixmap(RJSApi& handler, const QPixmap& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPixmap object:
          QPixmap_Wrapper* ret = new QPixmap_Wrapper(handler, new QPixmap(v), true);

          // JS: new QPixmap('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPixmap");
          if (cl.isUndefined()) {
              qWarning() << "Class QPixmap is undefined. Use QPixmap_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPixmap('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPixmap(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPixmap RJSHelper::js2cpp_QPixmap(RJSApi& handler, const QJSValue& v) {
          /*
          QPixmap_Wrapper* wrapper = getWrapper<QPixmap_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPixmap: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPixmap();
          }
          //return *(QPixmap*)wrapper->getWrappedVoid();
          QPixmap* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPixmap: wrapped pointer is NULL";
              return QPixmap();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPixmap: not a QObject";
              return QPixmap();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPixmap_ptr: no wrapper";
              handler.trace();
              return QPixmap();
          }
          //QPixmap* ret = getWrapped_QPixmap(wrapper);
          QPixmap* ret = QPixmap_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPixmap();
          }
          return *ret;
      }

      bool RJSHelper::is_QPixmap(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPixmap: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPixmap::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPoint(RJSApi& handler, const QPoint* v) {
          QJSEngine* engine = handler.getEngine();
          QPoint_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPoint_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPoint object:
              ret = new QPoint_Wrapper(handler, new QPoint(*v), true);
          }

          // JS: new QPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class QPoint is undefined. Use QPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPoint('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPoint(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPoint(RJSApi& handler, const QPoint& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPoint object:
          QPoint_Wrapper* ret = new QPoint_Wrapper(handler, new QPoint(v), true);

          // JS: new QPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class QPoint is undefined. Use QPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPoint('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPoint(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPoint RJSHelper::js2cpp_QPoint(RJSApi& handler, const QJSValue& v) {
          /*
          QPoint_Wrapper* wrapper = getWrapper<QPoint_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPoint: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPoint();
          }
          //return *(QPoint*)wrapper->getWrappedVoid();
          QPoint* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPoint: wrapped pointer is NULL";
              return QPoint();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPoint: not a QObject";
              return QPoint();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPoint_ptr: no wrapper";
              handler.trace();
              return QPoint();
          }
          //QPoint* ret = getWrapped_QPoint(wrapper);
          QPoint* ret = QPoint_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPoint();
          }
          return *ret;
      }

      bool RJSHelper::is_QPoint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPoint: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPoint::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPointF(RJSApi& handler, const QPointF* v) {
          QJSEngine* engine = handler.getEngine();
          QPointF_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPointF_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPointF object:
              ret = new QPointF_Wrapper(handler, new QPointF(*v), true);
          }

          // JS: new QPointF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPointF");
          if (cl.isUndefined()) {
              qWarning() << "Class QPointF is undefined. Use QPointF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPointF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPointF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPointF(RJSApi& handler, const QPointF& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPointF object:
          QPointF_Wrapper* ret = new QPointF_Wrapper(handler, new QPointF(v), true);

          // JS: new QPointF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPointF");
          if (cl.isUndefined()) {
              qWarning() << "Class QPointF is undefined. Use QPointF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPointF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPointF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPointF RJSHelper::js2cpp_QPointF(RJSApi& handler, const QJSValue& v) {
          /*
          QPointF_Wrapper* wrapper = getWrapper<QPointF_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPointF: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPointF();
          }
          //return *(QPointF*)wrapper->getWrappedVoid();
          QPointF* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPointF: wrapped pointer is NULL";
              return QPointF();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPointF: not a QObject";
              return QPointF();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPointF_ptr: no wrapper";
              handler.trace();
              return QPointF();
          }
          //QPointF* ret = getWrapped_QPointF(wrapper);
          QPointF* ret = QPointF_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPointF();
          }
          return *ret;
      }

      bool RJSHelper::is_QPointF(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPointF: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPointF::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPolygon(RJSApi& handler, const QPolygon* v) {
          QJSEngine* engine = handler.getEngine();
          QPolygon_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPolygon_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPolygon object:
              ret = new QPolygon_Wrapper(handler, new QPolygon(*v), true);
          }

          // JS: new QPolygon('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPolygon");
          if (cl.isUndefined()) {
              qWarning() << "Class QPolygon is undefined. Use QPolygon_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPolygon('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPolygon(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPolygon(RJSApi& handler, const QPolygon& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPolygon object:
          QPolygon_Wrapper* ret = new QPolygon_Wrapper(handler, new QPolygon(v), true);

          // JS: new QPolygon('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPolygon");
          if (cl.isUndefined()) {
              qWarning() << "Class QPolygon is undefined. Use QPolygon_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPolygon('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPolygon(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPolygon RJSHelper::js2cpp_QPolygon(RJSApi& handler, const QJSValue& v) {
          /*
          QPolygon_Wrapper* wrapper = getWrapper<QPolygon_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPolygon: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPolygon();
          }
          //return *(QPolygon*)wrapper->getWrappedVoid();
          QPolygon* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPolygon: wrapped pointer is NULL";
              return QPolygon();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPolygon: not a QObject";
              return QPolygon();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPolygon_ptr: no wrapper";
              handler.trace();
              return QPolygon();
          }
          //QPolygon* ret = getWrapped_QPolygon(wrapper);
          QPolygon* ret = QPolygon_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPolygon();
          }
          return *ret;
      }

      bool RJSHelper::is_QPolygon(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPolygon: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPolygon::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPolygonF(RJSApi& handler, const QPolygonF* v) {
          QJSEngine* engine = handler.getEngine();
          QPolygonF_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPolygonF_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPolygonF object:
              ret = new QPolygonF_Wrapper(handler, new QPolygonF(*v), true);
          }

          // JS: new QPolygonF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPolygonF");
          if (cl.isUndefined()) {
              qWarning() << "Class QPolygonF is undefined. Use QPolygonF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPolygonF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPolygonF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPolygonF(RJSApi& handler, const QPolygonF& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPolygonF object:
          QPolygonF_Wrapper* ret = new QPolygonF_Wrapper(handler, new QPolygonF(v), true);

          // JS: new QPolygonF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPolygonF");
          if (cl.isUndefined()) {
              qWarning() << "Class QPolygonF is undefined. Use QPolygonF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPolygonF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPolygonF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPolygonF RJSHelper::js2cpp_QPolygonF(RJSApi& handler, const QJSValue& v) {
          /*
          QPolygonF_Wrapper* wrapper = getWrapper<QPolygonF_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPolygonF: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPolygonF();
          }
          //return *(QPolygonF*)wrapper->getWrappedVoid();
          QPolygonF* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPolygonF: wrapped pointer is NULL";
              return QPolygonF();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPolygonF: not a QObject";
              return QPolygonF();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPolygonF_ptr: no wrapper";
              handler.trace();
              return QPolygonF();
          }
          //QPolygonF* ret = getWrapped_QPolygonF(wrapper);
          QPolygonF* ret = QPolygonF_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPolygonF();
          }
          return *ret;
      }

      bool RJSHelper::is_QPolygonF(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPolygonF: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPolygonF::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPrinterInfo(RJSApi& handler, const QPrinterInfo* v) {
          QJSEngine* engine = handler.getEngine();
          QPrinterInfo_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPrinterInfo_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPrinterInfo object:
              ret = new QPrinterInfo_Wrapper(handler, new QPrinterInfo(*v), true);
          }

          // JS: new QPrinterInfo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPrinterInfo");
          if (cl.isUndefined()) {
              qWarning() << "Class QPrinterInfo is undefined. Use QPrinterInfo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPrinterInfo('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPrinterInfo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPrinterInfo(RJSApi& handler, const QPrinterInfo& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPrinterInfo object:
          QPrinterInfo_Wrapper* ret = new QPrinterInfo_Wrapper(handler, new QPrinterInfo(v), true);

          // JS: new QPrinterInfo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPrinterInfo");
          if (cl.isUndefined()) {
              qWarning() << "Class QPrinterInfo is undefined. Use QPrinterInfo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPrinterInfo('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPrinterInfo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPrinterInfo RJSHelper::js2cpp_QPrinterInfo(RJSApi& handler, const QJSValue& v) {
          /*
          QPrinterInfo_Wrapper* wrapper = getWrapper<QPrinterInfo_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPrinterInfo: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPrinterInfo();
          }
          //return *(QPrinterInfo*)wrapper->getWrappedVoid();
          QPrinterInfo* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPrinterInfo: wrapped pointer is NULL";
              return QPrinterInfo();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPrinterInfo: not a QObject";
              return QPrinterInfo();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPrinterInfo_ptr: no wrapper";
              handler.trace();
              return QPrinterInfo();
          }
          //QPrinterInfo* ret = getWrapped_QPrinterInfo(wrapper);
          QPrinterInfo* ret = QPrinterInfo_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPrinterInfo();
          }
          return *ret;
      }

      bool RJSHelper::is_QPrinterInfo(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPrinterInfo: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPrinterInfo::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QProcessEnvironment(RJSApi& handler, const QProcessEnvironment* v) {
          QJSEngine* engine = handler.getEngine();
          QProcessEnvironment_Wrapper* ret;

          if (v==nullptr) {
              ret = new QProcessEnvironment_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QProcessEnvironment object:
              ret = new QProcessEnvironment_Wrapper(handler, new QProcessEnvironment(*v), true);
          }

          // JS: new QProcessEnvironment('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QProcessEnvironment");
          if (cl.isUndefined()) {
              qWarning() << "Class QProcessEnvironment is undefined. Use QProcessEnvironment_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QProcessEnvironment('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QProcessEnvironment(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QProcessEnvironment(RJSApi& handler, const QProcessEnvironment& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QProcessEnvironment object:
          QProcessEnvironment_Wrapper* ret = new QProcessEnvironment_Wrapper(handler, new QProcessEnvironment(v), true);

          // JS: new QProcessEnvironment('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QProcessEnvironment");
          if (cl.isUndefined()) {
              qWarning() << "Class QProcessEnvironment is undefined. Use QProcessEnvironment_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QProcessEnvironment('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QProcessEnvironment(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QProcessEnvironment RJSHelper::js2cpp_QProcessEnvironment(RJSApi& handler, const QJSValue& v) {
          /*
          QProcessEnvironment_Wrapper* wrapper = getWrapper<QProcessEnvironment_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QProcessEnvironment: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QProcessEnvironment();
          }
          //return *(QProcessEnvironment*)wrapper->getWrappedVoid();
          QProcessEnvironment* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QProcessEnvironment: wrapped pointer is NULL";
              return QProcessEnvironment();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QProcessEnvironment: not a QObject";
              return QProcessEnvironment();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QProcessEnvironment_ptr: no wrapper";
              handler.trace();
              return QProcessEnvironment();
          }
          //QProcessEnvironment* ret = getWrapped_QProcessEnvironment(wrapper);
          QProcessEnvironment* ret = QProcessEnvironment_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QProcessEnvironment();
          }
          return *ret;
      }

      bool RJSHelper::is_QProcessEnvironment(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QProcessEnvironment: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QProcessEnvironment::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QRadialGradient(RJSApi& handler, const QRadialGradient* v) {
          QJSEngine* engine = handler.getEngine();
          QRadialGradient_Wrapper* ret;

          if (v==nullptr) {
              ret = new QRadialGradient_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QRadialGradient object:
              ret = new QRadialGradient_Wrapper(handler, new QRadialGradient(*v), true);
          }

          // JS: new QRadialGradient('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRadialGradient");
          if (cl.isUndefined()) {
              qWarning() << "Class QRadialGradient is undefined. Use QRadialGradient_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRadialGradient('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRadialGradient(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QRadialGradient(RJSApi& handler, const QRadialGradient& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QRadialGradient object:
          QRadialGradient_Wrapper* ret = new QRadialGradient_Wrapper(handler, new QRadialGradient(v), true);

          // JS: new QRadialGradient('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRadialGradient");
          if (cl.isUndefined()) {
              qWarning() << "Class QRadialGradient is undefined. Use QRadialGradient_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRadialGradient('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRadialGradient(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QRadialGradient RJSHelper::js2cpp_QRadialGradient(RJSApi& handler, const QJSValue& v) {
          /*
          QRadialGradient_Wrapper* wrapper = getWrapper<QRadialGradient_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRadialGradient: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QRadialGradient();
          }
          //return *(QRadialGradient*)wrapper->getWrappedVoid();
          QRadialGradient* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QRadialGradient: wrapped pointer is NULL";
              return QRadialGradient();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QRadialGradient: not a QObject";
              return QRadialGradient();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRadialGradient_ptr: no wrapper";
              handler.trace();
              return QRadialGradient();
          }
          //QRadialGradient* ret = getWrapped_QRadialGradient(wrapper);
          QRadialGradient* ret = QRadialGradient_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QRadialGradient();
          }
          return *ret;
      }

      bool RJSHelper::is_QRadialGradient(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QRadialGradient: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QRadialGradient::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QRect(RJSApi& handler, const QRect* v) {
          QJSEngine* engine = handler.getEngine();
          QRect_Wrapper* ret;

          if (v==nullptr) {
              ret = new QRect_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QRect object:
              ret = new QRect_Wrapper(handler, new QRect(*v), true);
          }

          // JS: new QRect('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRect");
          if (cl.isUndefined()) {
              qWarning() << "Class QRect is undefined. Use QRect_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRect('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRect(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QRect(RJSApi& handler, const QRect& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QRect object:
          QRect_Wrapper* ret = new QRect_Wrapper(handler, new QRect(v), true);

          // JS: new QRect('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRect");
          if (cl.isUndefined()) {
              qWarning() << "Class QRect is undefined. Use QRect_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRect('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRect(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QRect RJSHelper::js2cpp_QRect(RJSApi& handler, const QJSValue& v) {
          /*
          QRect_Wrapper* wrapper = getWrapper<QRect_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRect: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QRect();
          }
          //return *(QRect*)wrapper->getWrappedVoid();
          QRect* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QRect: wrapped pointer is NULL";
              return QRect();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QRect: not a QObject";
              return QRect();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRect_ptr: no wrapper";
              handler.trace();
              return QRect();
          }
          //QRect* ret = getWrapped_QRect(wrapper);
          QRect* ret = QRect_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QRect();
          }
          return *ret;
      }

      bool RJSHelper::is_QRect(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QRect: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QRect::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QRectF(RJSApi& handler, const QRectF* v) {
          QJSEngine* engine = handler.getEngine();
          QRectF_Wrapper* ret;

          if (v==nullptr) {
              ret = new QRectF_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QRectF object:
              ret = new QRectF_Wrapper(handler, new QRectF(*v), true);
          }

          // JS: new QRectF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRectF");
          if (cl.isUndefined()) {
              qWarning() << "Class QRectF is undefined. Use QRectF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRectF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRectF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QRectF(RJSApi& handler, const QRectF& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QRectF object:
          QRectF_Wrapper* ret = new QRectF_Wrapper(handler, new QRectF(v), true);

          // JS: new QRectF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRectF");
          if (cl.isUndefined()) {
              qWarning() << "Class QRectF is undefined. Use QRectF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRectF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRectF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QRectF RJSHelper::js2cpp_QRectF(RJSApi& handler, const QJSValue& v) {
          /*
          QRectF_Wrapper* wrapper = getWrapper<QRectF_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRectF: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QRectF();
          }
          //return *(QRectF*)wrapper->getWrappedVoid();
          QRectF* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QRectF: wrapped pointer is NULL";
              return QRectF();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QRectF: not a QObject";
              return QRectF();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRectF_ptr: no wrapper";
              handler.trace();
              return QRectF();
          }
          //QRectF* ret = getWrapped_QRectF(wrapper);
          QRectF* ret = QRectF_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QRectF();
          }
          return *ret;
      }

      bool RJSHelper::is_QRectF(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QRectF: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QRectF::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QRegion(RJSApi& handler, const QRegion* v) {
          QJSEngine* engine = handler.getEngine();
          QRegion_Wrapper* ret;

          if (v==nullptr) {
              ret = new QRegion_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QRegion object:
              ret = new QRegion_Wrapper(handler, new QRegion(*v), true);
          }

          // JS: new QRegion('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRegion");
          if (cl.isUndefined()) {
              qWarning() << "Class QRegion is undefined. Use QRegion_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRegion('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRegion(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QRegion(RJSApi& handler, const QRegion& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QRegion object:
          QRegion_Wrapper* ret = new QRegion_Wrapper(handler, new QRegion(v), true);

          // JS: new QRegion('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRegion");
          if (cl.isUndefined()) {
              qWarning() << "Class QRegion is undefined. Use QRegion_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRegion('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRegion(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QRegion RJSHelper::js2cpp_QRegion(RJSApi& handler, const QJSValue& v) {
          /*
          QRegion_Wrapper* wrapper = getWrapper<QRegion_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRegion: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QRegion();
          }
          //return *(QRegion*)wrapper->getWrappedVoid();
          QRegion* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QRegion: wrapped pointer is NULL";
              return QRegion();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QRegion: not a QObject";
              return QRegion();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRegion_ptr: no wrapper";
              handler.trace();
              return QRegion();
          }
          //QRegion* ret = getWrapped_QRegion(wrapper);
          QRegion* ret = QRegion_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QRegion();
          }
          return *ret;
      }

      bool RJSHelper::is_QRegion(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QRegion: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QRegion::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QRegularExpression(RJSApi& handler, const QRegularExpression* v) {
          QJSEngine* engine = handler.getEngine();
          QRegularExpression_Wrapper* ret;

          if (v==nullptr) {
              ret = new QRegularExpression_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QRegularExpression object:
              ret = new QRegularExpression_Wrapper(handler, new QRegularExpression(*v), true);
          }

          // JS: new QRegularExpression('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRegularExpression");
          if (cl.isUndefined()) {
              qWarning() << "Class QRegularExpression is undefined. Use QRegularExpression_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRegularExpression('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRegularExpression(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QRegularExpression(RJSApi& handler, const QRegularExpression& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QRegularExpression object:
          QRegularExpression_Wrapper* ret = new QRegularExpression_Wrapper(handler, new QRegularExpression(v), true);

          // JS: new QRegularExpression('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRegularExpression");
          if (cl.isUndefined()) {
              qWarning() << "Class QRegularExpression is undefined. Use QRegularExpression_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRegularExpression('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRegularExpression(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QRegularExpression RJSHelper::js2cpp_QRegularExpression(RJSApi& handler, const QJSValue& v) {
          /*
          QRegularExpression_Wrapper* wrapper = getWrapper<QRegularExpression_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRegularExpression: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QRegularExpression();
          }
          //return *(QRegularExpression*)wrapper->getWrappedVoid();
          QRegularExpression* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QRegularExpression: wrapped pointer is NULL";
              return QRegularExpression();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QRegularExpression: not a QObject";
              return QRegularExpression();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRegularExpression_ptr: no wrapper";
              handler.trace();
              return QRegularExpression();
          }
          //QRegularExpression* ret = getWrapped_QRegularExpression(wrapper);
          QRegularExpression* ret = QRegularExpression_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QRegularExpression();
          }
          return *ret;
      }

      bool RJSHelper::is_QRegularExpression(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QRegularExpression: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QRegularExpression::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QRegularExpressionMatch(RJSApi& handler, const QRegularExpressionMatch* v) {
          QJSEngine* engine = handler.getEngine();
          QRegularExpressionMatch_Wrapper* ret;

          if (v==nullptr) {
              ret = new QRegularExpressionMatch_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QRegularExpressionMatch object:
              ret = new QRegularExpressionMatch_Wrapper(handler, new QRegularExpressionMatch(*v), true);
          }

          // JS: new QRegularExpressionMatch('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRegularExpressionMatch");
          if (cl.isUndefined()) {
              qWarning() << "Class QRegularExpressionMatch is undefined. Use QRegularExpressionMatch_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRegularExpressionMatch('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRegularExpressionMatch(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QRegularExpressionMatch(RJSApi& handler, const QRegularExpressionMatch& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QRegularExpressionMatch object:
          QRegularExpressionMatch_Wrapper* ret = new QRegularExpressionMatch_Wrapper(handler, new QRegularExpressionMatch(v), true);

          // JS: new QRegularExpressionMatch('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRegularExpressionMatch");
          if (cl.isUndefined()) {
              qWarning() << "Class QRegularExpressionMatch is undefined. Use QRegularExpressionMatch_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRegularExpressionMatch('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRegularExpressionMatch(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QRegularExpressionMatch RJSHelper::js2cpp_QRegularExpressionMatch(RJSApi& handler, const QJSValue& v) {
          /*
          QRegularExpressionMatch_Wrapper* wrapper = getWrapper<QRegularExpressionMatch_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRegularExpressionMatch: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QRegularExpressionMatch();
          }
          //return *(QRegularExpressionMatch*)wrapper->getWrappedVoid();
          QRegularExpressionMatch* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QRegularExpressionMatch: wrapped pointer is NULL";
              return QRegularExpressionMatch();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QRegularExpressionMatch: not a QObject";
              return QRegularExpressionMatch();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRegularExpressionMatch_ptr: no wrapper";
              handler.trace();
              return QRegularExpressionMatch();
          }
          //QRegularExpressionMatch* ret = getWrapped_QRegularExpressionMatch(wrapper);
          QRegularExpressionMatch* ret = QRegularExpressionMatch_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QRegularExpressionMatch();
          }
          return *ret;
      }

      bool RJSHelper::is_QRegularExpressionMatch(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QRegularExpressionMatch: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QRegularExpressionMatch::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QSize(RJSApi& handler, const QSize* v) {
          QJSEngine* engine = handler.getEngine();
          QSize_Wrapper* ret;

          if (v==nullptr) {
              ret = new QSize_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QSize object:
              ret = new QSize_Wrapper(handler, new QSize(*v), true);
          }

          // JS: new QSize('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSize");
          if (cl.isUndefined()) {
              qWarning() << "Class QSize is undefined. Use QSize_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSize('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSize(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSize(RJSApi& handler, const QSize& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QSize object:
          QSize_Wrapper* ret = new QSize_Wrapper(handler, new QSize(v), true);

          // JS: new QSize('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSize");
          if (cl.isUndefined()) {
              qWarning() << "Class QSize is undefined. Use QSize_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSize('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSize(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QSize RJSHelper::js2cpp_QSize(RJSApi& handler, const QJSValue& v) {
          /*
          QSize_Wrapper* wrapper = getWrapper<QSize_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSize: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QSize();
          }
          //return *(QSize*)wrapper->getWrappedVoid();
          QSize* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QSize: wrapped pointer is NULL";
              return QSize();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSize: not a QObject";
              return QSize();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSize_ptr: no wrapper";
              handler.trace();
              return QSize();
          }
          //QSize* ret = getWrapped_QSize(wrapper);
          QSize* ret = QSize_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QSize();
          }
          return *ret;
      }

      bool RJSHelper::is_QSize(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSize: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QSize::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QSizeF(RJSApi& handler, const QSizeF* v) {
          QJSEngine* engine = handler.getEngine();
          QSizeF_Wrapper* ret;

          if (v==nullptr) {
              ret = new QSizeF_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QSizeF object:
              ret = new QSizeF_Wrapper(handler, new QSizeF(*v), true);
          }

          // JS: new QSizeF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSizeF");
          if (cl.isUndefined()) {
              qWarning() << "Class QSizeF is undefined. Use QSizeF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSizeF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSizeF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSizeF(RJSApi& handler, const QSizeF& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QSizeF object:
          QSizeF_Wrapper* ret = new QSizeF_Wrapper(handler, new QSizeF(v), true);

          // JS: new QSizeF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSizeF");
          if (cl.isUndefined()) {
              qWarning() << "Class QSizeF is undefined. Use QSizeF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSizeF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSizeF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QSizeF RJSHelper::js2cpp_QSizeF(RJSApi& handler, const QJSValue& v) {
          /*
          QSizeF_Wrapper* wrapper = getWrapper<QSizeF_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSizeF: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QSizeF();
          }
          //return *(QSizeF*)wrapper->getWrappedVoid();
          QSizeF* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QSizeF: wrapped pointer is NULL";
              return QSizeF();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSizeF: not a QObject";
              return QSizeF();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSizeF_ptr: no wrapper";
              handler.trace();
              return QSizeF();
          }
          //QSizeF* ret = getWrapped_QSizeF(wrapper);
          QSizeF* ret = QSizeF_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QSizeF();
          }
          return *ret;
      }

      bool RJSHelper::is_QSizeF(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSizeF: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QSizeF::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QSizePolicy(RJSApi& handler, const QSizePolicy* v) {
          QJSEngine* engine = handler.getEngine();
          QSizePolicy_Wrapper* ret;

          if (v==nullptr) {
              ret = new QSizePolicy_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QSizePolicy object:
              ret = new QSizePolicy_Wrapper(handler, new QSizePolicy(*v), true);
          }

          // JS: new QSizePolicy('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSizePolicy");
          if (cl.isUndefined()) {
              qWarning() << "Class QSizePolicy is undefined. Use QSizePolicy_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSizePolicy('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSizePolicy(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSizePolicy(RJSApi& handler, const QSizePolicy& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QSizePolicy object:
          QSizePolicy_Wrapper* ret = new QSizePolicy_Wrapper(handler, new QSizePolicy(v), true);

          // JS: new QSizePolicy('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSizePolicy");
          if (cl.isUndefined()) {
              qWarning() << "Class QSizePolicy is undefined. Use QSizePolicy_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSizePolicy('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSizePolicy(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QSizePolicy RJSHelper::js2cpp_QSizePolicy(RJSApi& handler, const QJSValue& v) {
          /*
          QSizePolicy_Wrapper* wrapper = getWrapper<QSizePolicy_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSizePolicy: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QSizePolicy();
          }
          //return *(QSizePolicy*)wrapper->getWrappedVoid();
          QSizePolicy* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QSizePolicy: wrapped pointer is NULL";
              return QSizePolicy();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSizePolicy: not a QObject";
              return QSizePolicy();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSizePolicy_ptr: no wrapper";
              handler.trace();
              return QSizePolicy();
          }
          //QSizePolicy* ret = getWrapped_QSizePolicy(wrapper);
          QSizePolicy* ret = QSizePolicy_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QSizePolicy();
          }
          return *ret;
      }

      bool RJSHelper::is_QSizePolicy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSizePolicy: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QSizePolicy::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QSurfaceFormat(RJSApi& handler, const QSurfaceFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QSurfaceFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QSurfaceFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QSurfaceFormat object:
              ret = new QSurfaceFormat_Wrapper(handler, new QSurfaceFormat(*v), true);
          }

          // JS: new QSurfaceFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSurfaceFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QSurfaceFormat is undefined. Use QSurfaceFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSurfaceFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSurfaceFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSurfaceFormat(RJSApi& handler, const QSurfaceFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QSurfaceFormat object:
          QSurfaceFormat_Wrapper* ret = new QSurfaceFormat_Wrapper(handler, new QSurfaceFormat(v), true);

          // JS: new QSurfaceFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSurfaceFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QSurfaceFormat is undefined. Use QSurfaceFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSurfaceFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSurfaceFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QSurfaceFormat RJSHelper::js2cpp_QSurfaceFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QSurfaceFormat_Wrapper* wrapper = getWrapper<QSurfaceFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSurfaceFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QSurfaceFormat();
          }
          //return *(QSurfaceFormat*)wrapper->getWrappedVoid();
          QSurfaceFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QSurfaceFormat: wrapped pointer is NULL";
              return QSurfaceFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSurfaceFormat: not a QObject";
              return QSurfaceFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSurfaceFormat_ptr: no wrapper";
              handler.trace();
              return QSurfaceFormat();
          }
          //QSurfaceFormat* ret = getWrapped_QSurfaceFormat(wrapper);
          QSurfaceFormat* ret = QSurfaceFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QSurfaceFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QSurfaceFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSurfaceFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QSurfaceFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextBlockFormat(RJSApi& handler, const QTextBlockFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QTextBlockFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextBlockFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextBlockFormat object:
              ret = new QTextBlockFormat_Wrapper(handler, new QTextBlockFormat(*v), true);
          }

          // JS: new QTextBlockFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextBlockFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextBlockFormat is undefined. Use QTextBlockFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextBlockFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextBlockFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextBlockFormat(RJSApi& handler, const QTextBlockFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextBlockFormat object:
          QTextBlockFormat_Wrapper* ret = new QTextBlockFormat_Wrapper(handler, new QTextBlockFormat(v), true);

          // JS: new QTextBlockFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextBlockFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextBlockFormat is undefined. Use QTextBlockFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextBlockFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextBlockFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextBlockFormat RJSHelper::js2cpp_QTextBlockFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QTextBlockFormat_Wrapper* wrapper = getWrapper<QTextBlockFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextBlockFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextBlockFormat();
          }
          //return *(QTextBlockFormat*)wrapper->getWrappedVoid();
          QTextBlockFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextBlockFormat: wrapped pointer is NULL";
              return QTextBlockFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextBlockFormat: not a QObject";
              return QTextBlockFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextBlockFormat_ptr: no wrapper";
              handler.trace();
              return QTextBlockFormat();
          }
          //QTextBlockFormat* ret = getWrapped_QTextBlockFormat(wrapper);
          QTextBlockFormat* ret = QTextBlockFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextBlockFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextBlockFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextBlockFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextBlockFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextCharFormat(RJSApi& handler, const QTextCharFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QTextCharFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextCharFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextCharFormat object:
              ret = new QTextCharFormat_Wrapper(handler, new QTextCharFormat(*v), true);
          }

          // JS: new QTextCharFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextCharFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextCharFormat is undefined. Use QTextCharFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextCharFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextCharFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextCharFormat(RJSApi& handler, const QTextCharFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextCharFormat object:
          QTextCharFormat_Wrapper* ret = new QTextCharFormat_Wrapper(handler, new QTextCharFormat(v), true);

          // JS: new QTextCharFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextCharFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextCharFormat is undefined. Use QTextCharFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextCharFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextCharFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextCharFormat RJSHelper::js2cpp_QTextCharFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QTextCharFormat_Wrapper* wrapper = getWrapper<QTextCharFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextCharFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextCharFormat();
          }
          //return *(QTextCharFormat*)wrapper->getWrappedVoid();
          QTextCharFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextCharFormat: wrapped pointer is NULL";
              return QTextCharFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextCharFormat: not a QObject";
              return QTextCharFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextCharFormat_ptr: no wrapper";
              handler.trace();
              return QTextCharFormat();
          }
          //QTextCharFormat* ret = getWrapped_QTextCharFormat(wrapper);
          QTextCharFormat* ret = QTextCharFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextCharFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextCharFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextCharFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextCharFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextCursor(RJSApi& handler, const QTextCursor* v) {
          QJSEngine* engine = handler.getEngine();
          QTextCursor_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextCursor_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextCursor object:
              ret = new QTextCursor_Wrapper(handler, new QTextCursor(*v), true);
          }

          // JS: new QTextCursor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextCursor");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextCursor is undefined. Use QTextCursor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextCursor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextCursor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextCursor(RJSApi& handler, const QTextCursor& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextCursor object:
          QTextCursor_Wrapper* ret = new QTextCursor_Wrapper(handler, new QTextCursor(v), true);

          // JS: new QTextCursor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextCursor");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextCursor is undefined. Use QTextCursor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextCursor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextCursor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextCursor RJSHelper::js2cpp_QTextCursor(RJSApi& handler, const QJSValue& v) {
          /*
          QTextCursor_Wrapper* wrapper = getWrapper<QTextCursor_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextCursor: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextCursor();
          }
          //return *(QTextCursor*)wrapper->getWrappedVoid();
          QTextCursor* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextCursor: wrapped pointer is NULL";
              return QTextCursor();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextCursor: not a QObject";
              return QTextCursor();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextCursor_ptr: no wrapper";
              handler.trace();
              return QTextCursor();
          }
          //QTextCursor* ret = getWrapped_QTextCursor(wrapper);
          QTextCursor* ret = QTextCursor_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextCursor();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextCursor(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextCursor: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextCursor::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextFormat(RJSApi& handler, const QTextFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QTextFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextFormat object:
              ret = new QTextFormat_Wrapper(handler, new QTextFormat(*v), true);
          }

          // JS: new QTextFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextFormat is undefined. Use QTextFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextFormat(RJSApi& handler, const QTextFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextFormat object:
          QTextFormat_Wrapper* ret = new QTextFormat_Wrapper(handler, new QTextFormat(v), true);

          // JS: new QTextFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextFormat is undefined. Use QTextFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextFormat RJSHelper::js2cpp_QTextFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QTextFormat_Wrapper* wrapper = getWrapper<QTextFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextFormat();
          }
          //return *(QTextFormat*)wrapper->getWrappedVoid();
          QTextFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextFormat: wrapped pointer is NULL";
              return QTextFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextFormat: not a QObject";
              return QTextFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextFormat_ptr: no wrapper";
              handler.trace();
              return QTextFormat();
          }
          //QTextFormat* ret = getWrapped_QTextFormat(wrapper);
          QTextFormat* ret = QTextFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextFrameFormat(RJSApi& handler, const QTextFrameFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QTextFrameFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextFrameFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextFrameFormat object:
              ret = new QTextFrameFormat_Wrapper(handler, new QTextFrameFormat(*v), true);
          }

          // JS: new QTextFrameFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextFrameFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextFrameFormat is undefined. Use QTextFrameFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextFrameFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextFrameFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextFrameFormat(RJSApi& handler, const QTextFrameFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextFrameFormat object:
          QTextFrameFormat_Wrapper* ret = new QTextFrameFormat_Wrapper(handler, new QTextFrameFormat(v), true);

          // JS: new QTextFrameFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextFrameFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextFrameFormat is undefined. Use QTextFrameFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextFrameFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextFrameFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextFrameFormat RJSHelper::js2cpp_QTextFrameFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QTextFrameFormat_Wrapper* wrapper = getWrapper<QTextFrameFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextFrameFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextFrameFormat();
          }
          //return *(QTextFrameFormat*)wrapper->getWrappedVoid();
          QTextFrameFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextFrameFormat: wrapped pointer is NULL";
              return QTextFrameFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextFrameFormat: not a QObject";
              return QTextFrameFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextFrameFormat_ptr: no wrapper";
              handler.trace();
              return QTextFrameFormat();
          }
          //QTextFrameFormat* ret = getWrapped_QTextFrameFormat(wrapper);
          QTextFrameFormat* ret = QTextFrameFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextFrameFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextFrameFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextFrameFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextFrameFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextImageFormat(RJSApi& handler, const QTextImageFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QTextImageFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextImageFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextImageFormat object:
              ret = new QTextImageFormat_Wrapper(handler, new QTextImageFormat(*v), true);
          }

          // JS: new QTextImageFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextImageFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextImageFormat is undefined. Use QTextImageFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextImageFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextImageFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextImageFormat(RJSApi& handler, const QTextImageFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextImageFormat object:
          QTextImageFormat_Wrapper* ret = new QTextImageFormat_Wrapper(handler, new QTextImageFormat(v), true);

          // JS: new QTextImageFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextImageFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextImageFormat is undefined. Use QTextImageFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextImageFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextImageFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextImageFormat RJSHelper::js2cpp_QTextImageFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QTextImageFormat_Wrapper* wrapper = getWrapper<QTextImageFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextImageFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextImageFormat();
          }
          //return *(QTextImageFormat*)wrapper->getWrappedVoid();
          QTextImageFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextImageFormat: wrapped pointer is NULL";
              return QTextImageFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextImageFormat: not a QObject";
              return QTextImageFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextImageFormat_ptr: no wrapper";
              handler.trace();
              return QTextImageFormat();
          }
          //QTextImageFormat* ret = getWrapped_QTextImageFormat(wrapper);
          QTextImageFormat* ret = QTextImageFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextImageFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextImageFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextImageFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextImageFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextLength(RJSApi& handler, const QTextLength* v) {
          QJSEngine* engine = handler.getEngine();
          QTextLength_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextLength_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextLength object:
              ret = new QTextLength_Wrapper(handler, new QTextLength(*v), true);
          }

          // JS: new QTextLength('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextLength");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextLength is undefined. Use QTextLength_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextLength('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextLength(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextLength(RJSApi& handler, const QTextLength& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextLength object:
          QTextLength_Wrapper* ret = new QTextLength_Wrapper(handler, new QTextLength(v), true);

          // JS: new QTextLength('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextLength");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextLength is undefined. Use QTextLength_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextLength('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextLength(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextLength RJSHelper::js2cpp_QTextLength(RJSApi& handler, const QJSValue& v) {
          /*
          QTextLength_Wrapper* wrapper = getWrapper<QTextLength_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextLength: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextLength();
          }
          //return *(QTextLength*)wrapper->getWrappedVoid();
          QTextLength* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextLength: wrapped pointer is NULL";
              return QTextLength();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextLength: not a QObject";
              return QTextLength();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextLength_ptr: no wrapper";
              handler.trace();
              return QTextLength();
          }
          //QTextLength* ret = getWrapped_QTextLength(wrapper);
          QTextLength* ret = QTextLength_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextLength();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextLength(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextLength: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextLength::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextListFormat(RJSApi& handler, const QTextListFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QTextListFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextListFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextListFormat object:
              ret = new QTextListFormat_Wrapper(handler, new QTextListFormat(*v), true);
          }

          // JS: new QTextListFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextListFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextListFormat is undefined. Use QTextListFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextListFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextListFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextListFormat(RJSApi& handler, const QTextListFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextListFormat object:
          QTextListFormat_Wrapper* ret = new QTextListFormat_Wrapper(handler, new QTextListFormat(v), true);

          // JS: new QTextListFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextListFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextListFormat is undefined. Use QTextListFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextListFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextListFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextListFormat RJSHelper::js2cpp_QTextListFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QTextListFormat_Wrapper* wrapper = getWrapper<QTextListFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextListFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextListFormat();
          }
          //return *(QTextListFormat*)wrapper->getWrappedVoid();
          QTextListFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextListFormat: wrapped pointer is NULL";
              return QTextListFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextListFormat: not a QObject";
              return QTextListFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextListFormat_ptr: no wrapper";
              handler.trace();
              return QTextListFormat();
          }
          //QTextListFormat* ret = getWrapped_QTextListFormat(wrapper);
          QTextListFormat* ret = QTextListFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextListFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextListFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextListFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextListFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextTableCellFormat(RJSApi& handler, const QTextTableCellFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QTextTableCellFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextTableCellFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextTableCellFormat object:
              ret = new QTextTableCellFormat_Wrapper(handler, new QTextTableCellFormat(*v), true);
          }

          // JS: new QTextTableCellFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextTableCellFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextTableCellFormat is undefined. Use QTextTableCellFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextTableCellFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextTableCellFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextTableCellFormat(RJSApi& handler, const QTextTableCellFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextTableCellFormat object:
          QTextTableCellFormat_Wrapper* ret = new QTextTableCellFormat_Wrapper(handler, new QTextTableCellFormat(v), true);

          // JS: new QTextTableCellFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextTableCellFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextTableCellFormat is undefined. Use QTextTableCellFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextTableCellFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextTableCellFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextTableCellFormat RJSHelper::js2cpp_QTextTableCellFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QTextTableCellFormat_Wrapper* wrapper = getWrapper<QTextTableCellFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextTableCellFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextTableCellFormat();
          }
          //return *(QTextTableCellFormat*)wrapper->getWrappedVoid();
          QTextTableCellFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextTableCellFormat: wrapped pointer is NULL";
              return QTextTableCellFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextTableCellFormat: not a QObject";
              return QTextTableCellFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextTableCellFormat_ptr: no wrapper";
              handler.trace();
              return QTextTableCellFormat();
          }
          //QTextTableCellFormat* ret = getWrapped_QTextTableCellFormat(wrapper);
          QTextTableCellFormat* ret = QTextTableCellFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextTableCellFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextTableCellFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextTableCellFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextTableCellFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextTableFormat(RJSApi& handler, const QTextTableFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QTextTableFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextTableFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextTableFormat object:
              ret = new QTextTableFormat_Wrapper(handler, new QTextTableFormat(*v), true);
          }

          // JS: new QTextTableFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextTableFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextTableFormat is undefined. Use QTextTableFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextTableFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextTableFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextTableFormat(RJSApi& handler, const QTextTableFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextTableFormat object:
          QTextTableFormat_Wrapper* ret = new QTextTableFormat_Wrapper(handler, new QTextTableFormat(v), true);

          // JS: new QTextTableFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextTableFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextTableFormat is undefined. Use QTextTableFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextTableFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextTableFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextTableFormat RJSHelper::js2cpp_QTextTableFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QTextTableFormat_Wrapper* wrapper = getWrapper<QTextTableFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextTableFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextTableFormat();
          }
          //return *(QTextTableFormat*)wrapper->getWrappedVoid();
          QTextTableFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextTableFormat: wrapped pointer is NULL";
              return QTextTableFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextTableFormat: not a QObject";
              return QTextTableFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextTableFormat_ptr: no wrapper";
              handler.trace();
              return QTextTableFormat();
          }
          //QTextTableFormat* ret = getWrapped_QTextTableFormat(wrapper);
          QTextTableFormat* ret = QTextTableFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextTableFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextTableFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextTableFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextTableFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTime(RJSApi& handler, const QTime* v) {
          QJSEngine* engine = handler.getEngine();
          QTime_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTime_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTime object:
              ret = new QTime_Wrapper(handler, new QTime(*v), true);
          }

          // JS: new QTime('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTime");
          if (cl.isUndefined()) {
              qWarning() << "Class QTime is undefined. Use QTime_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTime('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTime(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTime(RJSApi& handler, const QTime& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTime object:
          QTime_Wrapper* ret = new QTime_Wrapper(handler, new QTime(v), true);

          // JS: new QTime('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTime");
          if (cl.isUndefined()) {
              qWarning() << "Class QTime is undefined. Use QTime_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTime('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTime(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTime RJSHelper::js2cpp_QTime(RJSApi& handler, const QJSValue& v) {
          /*
          QTime_Wrapper* wrapper = getWrapper<QTime_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTime: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTime();
          }
          //return *(QTime*)wrapper->getWrappedVoid();
          QTime* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTime: wrapped pointer is NULL";
              return QTime();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTime: not a QObject";
              return QTime();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTime_ptr: no wrapper";
              handler.trace();
              return QTime();
          }
          //QTime* ret = getWrapped_QTime(wrapper);
          QTime* ret = QTime_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTime();
          }
          return *ret;
      }

      bool RJSHelper::is_QTime(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTime: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTime::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTransform(RJSApi& handler, const QTransform* v) {
          QJSEngine* engine = handler.getEngine();
          QTransform_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTransform_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTransform object:
              ret = new QTransform_Wrapper(handler, new QTransform(*v), true);
          }

          // JS: new QTransform('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTransform");
          if (cl.isUndefined()) {
              qWarning() << "Class QTransform is undefined. Use QTransform_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTransform('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTransform(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTransform(RJSApi& handler, const QTransform& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTransform object:
          QTransform_Wrapper* ret = new QTransform_Wrapper(handler, new QTransform(v), true);

          // JS: new QTransform('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTransform");
          if (cl.isUndefined()) {
              qWarning() << "Class QTransform is undefined. Use QTransform_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTransform('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTransform(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTransform RJSHelper::js2cpp_QTransform(RJSApi& handler, const QJSValue& v) {
          /*
          QTransform_Wrapper* wrapper = getWrapper<QTransform_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTransform: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTransform();
          }
          //return *(QTransform*)wrapper->getWrappedVoid();
          QTransform* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTransform: wrapped pointer is NULL";
              return QTransform();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTransform: not a QObject";
              return QTransform();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTransform_ptr: no wrapper";
              handler.trace();
              return QTransform();
          }
          //QTransform* ret = getWrapped_QTransform(wrapper);
          QTransform* ret = QTransform_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTransform();
          }
          return *ret;
      }

      bool RJSHelper::is_QTransform(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTransform: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTransform::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QUrl(RJSApi& handler, const QUrl* v) {
          QJSEngine* engine = handler.getEngine();
          QUrl_Wrapper* ret;

          if (v==nullptr) {
              ret = new QUrl_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QUrl object:
              ret = new QUrl_Wrapper(handler, new QUrl(*v), true);
          }

          // JS: new QUrl('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QUrl");
          if (cl.isUndefined()) {
              qWarning() << "Class QUrl is undefined. Use QUrl_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QUrl('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QUrl(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QUrl(RJSApi& handler, const QUrl& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QUrl object:
          QUrl_Wrapper* ret = new QUrl_Wrapper(handler, new QUrl(v), true);

          // JS: new QUrl('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QUrl");
          if (cl.isUndefined()) {
              qWarning() << "Class QUrl is undefined. Use QUrl_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QUrl('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QUrl(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QUrl RJSHelper::js2cpp_QUrl(RJSApi& handler, const QJSValue& v) {
          /*
          QUrl_Wrapper* wrapper = getWrapper<QUrl_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QUrl: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QUrl();
          }
          //return *(QUrl*)wrapper->getWrappedVoid();
          QUrl* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QUrl: wrapped pointer is NULL";
              return QUrl();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QUrl: not a QObject";
              return QUrl();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QUrl_ptr: no wrapper";
              handler.trace();
              return QUrl();
          }
          //QUrl* ret = getWrapped_QUrl(wrapper);
          QUrl* ret = QUrl_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QUrl();
          }
          return *ret;
      }

      bool RJSHelper::is_QUrl(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QUrl: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QUrl::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QUrlQuery(RJSApi& handler, const QUrlQuery* v) {
          QJSEngine* engine = handler.getEngine();
          QUrlQuery_Wrapper* ret;

          if (v==nullptr) {
              ret = new QUrlQuery_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QUrlQuery object:
              ret = new QUrlQuery_Wrapper(handler, new QUrlQuery(*v), true);
          }

          // JS: new QUrlQuery('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QUrlQuery");
          if (cl.isUndefined()) {
              qWarning() << "Class QUrlQuery is undefined. Use QUrlQuery_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QUrlQuery('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QUrlQuery(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QUrlQuery(RJSApi& handler, const QUrlQuery& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QUrlQuery object:
          QUrlQuery_Wrapper* ret = new QUrlQuery_Wrapper(handler, new QUrlQuery(v), true);

          // JS: new QUrlQuery('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QUrlQuery");
          if (cl.isUndefined()) {
              qWarning() << "Class QUrlQuery is undefined. Use QUrlQuery_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QUrlQuery('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QUrlQuery(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QUrlQuery RJSHelper::js2cpp_QUrlQuery(RJSApi& handler, const QJSValue& v) {
          /*
          QUrlQuery_Wrapper* wrapper = getWrapper<QUrlQuery_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QUrlQuery: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QUrlQuery();
          }
          //return *(QUrlQuery*)wrapper->getWrappedVoid();
          QUrlQuery* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QUrlQuery: wrapped pointer is NULL";
              return QUrlQuery();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QUrlQuery: not a QObject";
              return QUrlQuery();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QUrlQuery_ptr: no wrapper";
              handler.trace();
              return QUrlQuery();
          }
          //QUrlQuery* ret = getWrapped_QUrlQuery(wrapper);
          QUrlQuery* ret = QUrlQuery_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QUrlQuery();
          }
          return *ret;
      }

      bool RJSHelper::is_QUrlQuery(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QUrlQuery: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QUrlQuery::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlAttributes(RJSApi& handler, const QXmlAttributes* v) {
          QJSEngine* engine = handler.getEngine();
          QXmlAttributes_Wrapper* ret;

          if (v==nullptr) {
              ret = new QXmlAttributes_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QXmlAttributes object:
              ret = new QXmlAttributes_Wrapper(handler, new QXmlAttributes(*v), true);
          }

          // JS: new QXmlAttributes('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlAttributes");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlAttributes is undefined. Use QXmlAttributes_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlAttributes('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlAttributes(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QXmlAttributes(RJSApi& handler, const QXmlAttributes& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QXmlAttributes object:
          QXmlAttributes_Wrapper* ret = new QXmlAttributes_Wrapper(handler, new QXmlAttributes(v), true);

          // JS: new QXmlAttributes('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlAttributes");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlAttributes is undefined. Use QXmlAttributes_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlAttributes('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlAttributes(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QXmlAttributes RJSHelper::js2cpp_QXmlAttributes(RJSApi& handler, const QJSValue& v) {
          /*
          QXmlAttributes_Wrapper* wrapper = getWrapper<QXmlAttributes_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlAttributes: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QXmlAttributes();
          }
          //return *(QXmlAttributes*)wrapper->getWrappedVoid();
          QXmlAttributes* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QXmlAttributes: wrapped pointer is NULL";
              return QXmlAttributes();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlAttributes: not a QObject";
              return QXmlAttributes();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlAttributes_ptr: no wrapper";
              handler.trace();
              return QXmlAttributes();
          }
          //QXmlAttributes* ret = getWrapped_QXmlAttributes(wrapper);
          QXmlAttributes* ret = QXmlAttributes_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QXmlAttributes();
          }
          return *ret;
      }

      bool RJSHelper::is_QXmlAttributes(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlAttributes: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlAttributes::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlStreamAttributes(RJSApi& handler, const QXmlStreamAttributes* v) {
          QJSEngine* engine = handler.getEngine();
          QXmlStreamAttributes_Wrapper* ret;

          if (v==nullptr) {
              ret = new QXmlStreamAttributes_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QXmlStreamAttributes object:
              ret = new QXmlStreamAttributes_Wrapper(handler, new QXmlStreamAttributes(*v), true);
          }

          // JS: new QXmlStreamAttributes('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlStreamAttributes");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlStreamAttributes is undefined. Use QXmlStreamAttributes_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlStreamAttributes('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlStreamAttributes(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QXmlStreamAttributes(RJSApi& handler, const QXmlStreamAttributes& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QXmlStreamAttributes object:
          QXmlStreamAttributes_Wrapper* ret = new QXmlStreamAttributes_Wrapper(handler, new QXmlStreamAttributes(v), true);

          // JS: new QXmlStreamAttributes('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlStreamAttributes");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlStreamAttributes is undefined. Use QXmlStreamAttributes_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlStreamAttributes('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlStreamAttributes(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QXmlStreamAttributes RJSHelper::js2cpp_QXmlStreamAttributes(RJSApi& handler, const QJSValue& v) {
          /*
          QXmlStreamAttributes_Wrapper* wrapper = getWrapper<QXmlStreamAttributes_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlStreamAttributes: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QXmlStreamAttributes();
          }
          //return *(QXmlStreamAttributes*)wrapper->getWrappedVoid();
          QXmlStreamAttributes* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QXmlStreamAttributes: wrapped pointer is NULL";
              return QXmlStreamAttributes();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlStreamAttributes: not a QObject";
              return QXmlStreamAttributes();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlStreamAttributes_ptr: no wrapper";
              handler.trace();
              return QXmlStreamAttributes();
          }
          //QXmlStreamAttributes* ret = getWrapped_QXmlStreamAttributes(wrapper);
          QXmlStreamAttributes* ret = QXmlStreamAttributes_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QXmlStreamAttributes();
          }
          return *ret;
      }

      bool RJSHelper::is_QXmlStreamAttributes(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlStreamAttributes: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlStreamAttributes::getIdStatic())).toBool();
      }
    
  // ----------------------
  // wrapped pointer types:
  // ----------------------
  
      QJSValue RJSHelper::cpp2js_QAbstractFileIconProvider(RJSApi& handler, QAbstractFileIconProvider* v) {

          
            // downcast to QFileIconProvider:
            {
                QFileIconProvider* o = dynamic_cast<QFileIconProvider*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QFileIconProvider(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QAbstractFileIconProvider_Wrapper* ret = new QAbstractFileIconProvider_Wrapper(handler, v, false);

          // JS: new QAbstractFileIconProvider('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractFileIconProvider");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractFileIconProvider is undefined. Use QAbstractFileIconProvider_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractFileIconProvider('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractFileIconProvider(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QAbstractFileIconProvider* RJSHelper::js2cpp_QAbstractFileIconProvider_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractFileIconProvider: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractFileIconProvider_Wrapper* wrapper = qobject_cast<QAbstractFileIconProvider_Wrapper*>(obj);
          //QAbstractFileIconProvider_Wrapper* wrapper = dynamic_cast<QAbstractFileIconProvider_Wrapper*>(obj);
          //QAbstractFileIconProvider_Wrapper* wrapper = (QAbstractFileIconProvider_Wrapper*)(obj);
          //QAbstractFileIconProvider_Wrapper* wrapper = getWrapper<QAbstractFileIconProvider_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractFileIconProvider_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QAbstractFileIconProvider(wrapper);
          return QAbstractFileIconProvider_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractFileIconProvider_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractFileIconProvider: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractFileIconProvider::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractListModel(RJSApi& handler, QAbstractListModel* v) {

          

          QJSEngine* engine = handler.getEngine();
          QAbstractListModel_Wrapper* ret = new QAbstractListModel_Wrapper(handler, v, false);

          // JS: new QAbstractListModel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractListModel");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractListModel is undefined. Use QAbstractListModel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractListModel('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractListModel(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QAbstractListModel* RJSHelper::js2cpp_QAbstractListModel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractListModel: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractListModel_Wrapper* wrapper = qobject_cast<QAbstractListModel_Wrapper*>(obj);
          //QAbstractListModel_Wrapper* wrapper = dynamic_cast<QAbstractListModel_Wrapper*>(obj);
          //QAbstractListModel_Wrapper* wrapper = (QAbstractListModel_Wrapper*)(obj);
          //QAbstractListModel_Wrapper* wrapper = getWrapper<QAbstractListModel_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractListModel_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QAbstractListModel(wrapper);
          return QAbstractListModel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractListModel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractListModel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractListModel::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractTableModel(RJSApi& handler, QAbstractTableModel* v) {

          

          QJSEngine* engine = handler.getEngine();
          QAbstractTableModel_Wrapper* ret = new QAbstractTableModel_Wrapper(handler, v, false);

          // JS: new QAbstractTableModel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractTableModel");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractTableModel is undefined. Use QAbstractTableModel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractTableModel('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractTableModel(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QAbstractTableModel* RJSHelper::js2cpp_QAbstractTableModel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractTableModel: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractTableModel_Wrapper* wrapper = qobject_cast<QAbstractTableModel_Wrapper*>(obj);
          //QAbstractTableModel_Wrapper* wrapper = dynamic_cast<QAbstractTableModel_Wrapper*>(obj);
          //QAbstractTableModel_Wrapper* wrapper = (QAbstractTableModel_Wrapper*)(obj);
          //QAbstractTableModel_Wrapper* wrapper = getWrapper<QAbstractTableModel_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractTableModel_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QAbstractTableModel(wrapper);
          return QAbstractTableModel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractTableModel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractTableModel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractTableModel::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QActionEvent(RJSApi& handler, QActionEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QActionEvent_Wrapper* ret = new QActionEvent_Wrapper(handler, v, false);

          // JS: new QActionEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QActionEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QActionEvent is undefined. Use QActionEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QActionEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QActionEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QActionEvent* RJSHelper::js2cpp_QActionEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QActionEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QActionEvent_Wrapper* wrapper = qobject_cast<QActionEvent_Wrapper*>(obj);
          //QActionEvent_Wrapper* wrapper = dynamic_cast<QActionEvent_Wrapper*>(obj);
          //QActionEvent_Wrapper* wrapper = (QActionEvent_Wrapper*)(obj);
          //QActionEvent_Wrapper* wrapper = getWrapper<QActionEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QActionEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QActionEvent(wrapper);
          return QActionEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QActionEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QActionEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QActionEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QCompleter(RJSApi& handler, QCompleter* v) {

          

          QJSEngine* engine = handler.getEngine();
          QCompleter_Wrapper* ret = new QCompleter_Wrapper(handler, v, false);

          // JS: new QCompleter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QCompleter");
          if (cl.isUndefined()) {
              qWarning() << "Class QCompleter is undefined. Use QCompleter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QCompleter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QCompleter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QCompleter* RJSHelper::js2cpp_QCompleter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QCompleter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QCompleter_Wrapper* wrapper = qobject_cast<QCompleter_Wrapper*>(obj);
          //QCompleter_Wrapper* wrapper = dynamic_cast<QCompleter_Wrapper*>(obj);
          //QCompleter_Wrapper* wrapper = (QCompleter_Wrapper*)(obj);
          //QCompleter_Wrapper* wrapper = getWrapper<QCompleter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QCompleter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QCompleter(wrapper);
          return QCompleter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QCompleter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QCompleter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QCompleter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QContextMenuEvent(RJSApi& handler, QContextMenuEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QContextMenuEvent_Wrapper* ret = new QContextMenuEvent_Wrapper(handler, v, false);

          // JS: new QContextMenuEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QContextMenuEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QContextMenuEvent is undefined. Use QContextMenuEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QContextMenuEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QContextMenuEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QContextMenuEvent* RJSHelper::js2cpp_QContextMenuEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QContextMenuEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QContextMenuEvent_Wrapper* wrapper = qobject_cast<QContextMenuEvent_Wrapper*>(obj);
          //QContextMenuEvent_Wrapper* wrapper = dynamic_cast<QContextMenuEvent_Wrapper*>(obj);
          //QContextMenuEvent_Wrapper* wrapper = (QContextMenuEvent_Wrapper*)(obj);
          //QContextMenuEvent_Wrapper* wrapper = getWrapper<QContextMenuEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QContextMenuEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QContextMenuEvent(wrapper);
          return QContextMenuEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QContextMenuEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QContextMenuEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QContextMenuEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDirIterator(RJSApi& handler, QDirIterator* v) {

          

          QJSEngine* engine = handler.getEngine();
          QDirIterator_Wrapper* ret = new QDirIterator_Wrapper(handler, v, false);

          // JS: new QDirIterator('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDirIterator");
          if (cl.isUndefined()) {
              qWarning() << "Class QDirIterator is undefined. Use QDirIterator_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDirIterator('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDirIterator(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QDirIterator* RJSHelper::js2cpp_QDirIterator_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDirIterator: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDirIterator_Wrapper* wrapper = qobject_cast<QDirIterator_Wrapper*>(obj);
          //QDirIterator_Wrapper* wrapper = dynamic_cast<QDirIterator_Wrapper*>(obj);
          //QDirIterator_Wrapper* wrapper = (QDirIterator_Wrapper*)(obj);
          //QDirIterator_Wrapper* wrapper = getWrapper<QDirIterator_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDirIterator_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QDirIterator(wrapper);
          return QDirIterator_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDirIterator_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDirIterator: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QDirIterator::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDragEnterEvent(RJSApi& handler, QDragEnterEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QDragEnterEvent_Wrapper* ret = new QDragEnterEvent_Wrapper(handler, v, false);

          // JS: new QDragEnterEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDragEnterEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QDragEnterEvent is undefined. Use QDragEnterEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDragEnterEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDragEnterEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QDragEnterEvent* RJSHelper::js2cpp_QDragEnterEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDragEnterEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDragEnterEvent_Wrapper* wrapper = qobject_cast<QDragEnterEvent_Wrapper*>(obj);
          //QDragEnterEvent_Wrapper* wrapper = dynamic_cast<QDragEnterEvent_Wrapper*>(obj);
          //QDragEnterEvent_Wrapper* wrapper = (QDragEnterEvent_Wrapper*)(obj);
          //QDragEnterEvent_Wrapper* wrapper = getWrapper<QDragEnterEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDragEnterEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QDragEnterEvent(wrapper);
          return QDragEnterEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDragEnterEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDragEnterEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QDragEnterEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDragLeaveEvent(RJSApi& handler, QDragLeaveEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QDragLeaveEvent_Wrapper* ret = new QDragLeaveEvent_Wrapper(handler, v, false);

          // JS: new QDragLeaveEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDragLeaveEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QDragLeaveEvent is undefined. Use QDragLeaveEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDragLeaveEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDragLeaveEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QDragLeaveEvent* RJSHelper::js2cpp_QDragLeaveEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDragLeaveEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDragLeaveEvent_Wrapper* wrapper = qobject_cast<QDragLeaveEvent_Wrapper*>(obj);
          //QDragLeaveEvent_Wrapper* wrapper = dynamic_cast<QDragLeaveEvent_Wrapper*>(obj);
          //QDragLeaveEvent_Wrapper* wrapper = (QDragLeaveEvent_Wrapper*)(obj);
          //QDragLeaveEvent_Wrapper* wrapper = getWrapper<QDragLeaveEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDragLeaveEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QDragLeaveEvent(wrapper);
          return QDragLeaveEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDragLeaveEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDragLeaveEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QDragLeaveEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDragMoveEvent(RJSApi& handler, QDragMoveEvent* v) {

          
            // downcast to QDragEnterEvent:
            {
                QDragEnterEvent* o = dynamic_cast<QDragEnterEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QDragEnterEvent(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QDragMoveEvent_Wrapper* ret = new QDragMoveEvent_Wrapper(handler, v, false);

          // JS: new QDragMoveEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDragMoveEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QDragMoveEvent is undefined. Use QDragMoveEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDragMoveEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDragMoveEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QDragMoveEvent* RJSHelper::js2cpp_QDragMoveEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDragMoveEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDragMoveEvent_Wrapper* wrapper = qobject_cast<QDragMoveEvent_Wrapper*>(obj);
          //QDragMoveEvent_Wrapper* wrapper = dynamic_cast<QDragMoveEvent_Wrapper*>(obj);
          //QDragMoveEvent_Wrapper* wrapper = (QDragMoveEvent_Wrapper*)(obj);
          //QDragMoveEvent_Wrapper* wrapper = getWrapper<QDragMoveEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDragMoveEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QDragMoveEvent(wrapper);
          return QDragMoveEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDragMoveEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDragMoveEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QDragMoveEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDropEvent(RJSApi& handler, QDropEvent* v) {

          
            // downcast to QDragMoveEvent:
            {
                QDragMoveEvent* o = dynamic_cast<QDragMoveEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QDragMoveEvent(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QDropEvent_Wrapper* ret = new QDropEvent_Wrapper(handler, v, false);

          // JS: new QDropEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDropEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QDropEvent is undefined. Use QDropEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDropEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDropEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QDropEvent* RJSHelper::js2cpp_QDropEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDropEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDropEvent_Wrapper* wrapper = qobject_cast<QDropEvent_Wrapper*>(obj);
          //QDropEvent_Wrapper* wrapper = dynamic_cast<QDropEvent_Wrapper*>(obj);
          //QDropEvent_Wrapper* wrapper = (QDropEvent_Wrapper*)(obj);
          //QDropEvent_Wrapper* wrapper = getWrapper<QDropEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDropEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QDropEvent(wrapper);
          return QDropEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDropEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDropEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QDropEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QEvent(RJSApi& handler, QEvent* v) {

          
            // downcast to QInputEvent:
            {
                QInputEvent* o = dynamic_cast<QInputEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QInputEvent(handler, o);
                }
            }
          
            // downcast to QFocusEvent:
            {
                QFocusEvent* o = dynamic_cast<QFocusEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QFocusEvent(handler, o);
                }
            }
          
            // downcast to QPaintEvent:
            {
                QPaintEvent* o = dynamic_cast<QPaintEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPaintEvent(handler, o);
                }
            }
          
            // downcast to QResizeEvent:
            {
                QResizeEvent* o = dynamic_cast<QResizeEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QResizeEvent(handler, o);
                }
            }
          
            // downcast to QDropEvent:
            {
                QDropEvent* o = dynamic_cast<QDropEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QDropEvent(handler, o);
                }
            }
          
            // downcast to QDragLeaveEvent:
            {
                QDragLeaveEvent* o = dynamic_cast<QDragLeaveEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QDragLeaveEvent(handler, o);
                }
            }
          
            // downcast to QHelpEvent:
            {
                QHelpEvent* o = dynamic_cast<QHelpEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QHelpEvent(handler, o);
                }
            }
          
            // downcast to QActionEvent:
            {
                QActionEvent* o = dynamic_cast<QActionEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QActionEvent(handler, o);
                }
            }
          
            // downcast to types derrived from QEvent but defined in other modules:
            for (int i=0; i<downcasters_QEvent.length(); i++) {
                QJSValue dc = downcasters_QEvent[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QEvent_Wrapper* ret = new QEvent_Wrapper(handler, v, false);

          // JS: new QEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QEvent is undefined. Use QEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QEvent* RJSHelper::js2cpp_QEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QEvent_Wrapper* wrapper = qobject_cast<QEvent_Wrapper*>(obj);
          //QEvent_Wrapper* wrapper = dynamic_cast<QEvent_Wrapper*>(obj);
          //QEvent_Wrapper* wrapper = (QEvent_Wrapper*)(obj);
          //QEvent_Wrapper* wrapper = getWrapper<QEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QEvent(wrapper);
          return QEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QFileIconProvider(RJSApi& handler, QFileIconProvider* v) {

          

          QJSEngine* engine = handler.getEngine();
          QFileIconProvider_Wrapper* ret = new QFileIconProvider_Wrapper(handler, v, false);

          // JS: new QFileIconProvider('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFileIconProvider");
          if (cl.isUndefined()) {
              qWarning() << "Class QFileIconProvider is undefined. Use QFileIconProvider_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFileIconProvider('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFileIconProvider(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QFileIconProvider* RJSHelper::js2cpp_QFileIconProvider_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFileIconProvider: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFileIconProvider_Wrapper* wrapper = qobject_cast<QFileIconProvider_Wrapper*>(obj);
          //QFileIconProvider_Wrapper* wrapper = dynamic_cast<QFileIconProvider_Wrapper*>(obj);
          //QFileIconProvider_Wrapper* wrapper = (QFileIconProvider_Wrapper*)(obj);
          //QFileIconProvider_Wrapper* wrapper = getWrapper<QFileIconProvider_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFileIconProvider_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QFileIconProvider(wrapper);
          return QFileIconProvider_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFileIconProvider_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFileIconProvider: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QFileIconProvider::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QFocusEvent(RJSApi& handler, QFocusEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QFocusEvent_Wrapper* ret = new QFocusEvent_Wrapper(handler, v, false);

          // JS: new QFocusEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFocusEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QFocusEvent is undefined. Use QFocusEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFocusEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFocusEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QFocusEvent* RJSHelper::js2cpp_QFocusEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFocusEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFocusEvent_Wrapper* wrapper = qobject_cast<QFocusEvent_Wrapper*>(obj);
          //QFocusEvent_Wrapper* wrapper = dynamic_cast<QFocusEvent_Wrapper*>(obj);
          //QFocusEvent_Wrapper* wrapper = (QFocusEvent_Wrapper*)(obj);
          //QFocusEvent_Wrapper* wrapper = getWrapper<QFocusEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFocusEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QFocusEvent(wrapper);
          return QFocusEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFocusEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFocusEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QFocusEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QFontMetrics(RJSApi& handler, QFontMetrics* v) {

          

          QJSEngine* engine = handler.getEngine();
          QFontMetrics_Wrapper* ret = new QFontMetrics_Wrapper(handler, v, false);

          // JS: new QFontMetrics('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFontMetrics");
          if (cl.isUndefined()) {
              qWarning() << "Class QFontMetrics is undefined. Use QFontMetrics_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFontMetrics('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFontMetrics(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QFontMetrics* RJSHelper::js2cpp_QFontMetrics_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFontMetrics: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFontMetrics_Wrapper* wrapper = qobject_cast<QFontMetrics_Wrapper*>(obj);
          //QFontMetrics_Wrapper* wrapper = dynamic_cast<QFontMetrics_Wrapper*>(obj);
          //QFontMetrics_Wrapper* wrapper = (QFontMetrics_Wrapper*)(obj);
          //QFontMetrics_Wrapper* wrapper = getWrapper<QFontMetrics_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFontMetrics_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QFontMetrics(wrapper);
          return QFontMetrics_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFontMetrics_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFontMetrics: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QFontMetrics::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QFontMetricsF(RJSApi& handler, QFontMetricsF* v) {

          

          QJSEngine* engine = handler.getEngine();
          QFontMetricsF_Wrapper* ret = new QFontMetricsF_Wrapper(handler, v, false);

          // JS: new QFontMetricsF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFontMetricsF");
          if (cl.isUndefined()) {
              qWarning() << "Class QFontMetricsF is undefined. Use QFontMetricsF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFontMetricsF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFontMetricsF(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QFontMetricsF* RJSHelper::js2cpp_QFontMetricsF_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFontMetricsF: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFontMetricsF_Wrapper* wrapper = qobject_cast<QFontMetricsF_Wrapper*>(obj);
          //QFontMetricsF_Wrapper* wrapper = dynamic_cast<QFontMetricsF_Wrapper*>(obj);
          //QFontMetricsF_Wrapper* wrapper = (QFontMetricsF_Wrapper*)(obj);
          //QFontMetricsF_Wrapper* wrapper = getWrapper<QFontMetricsF_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFontMetricsF_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QFontMetricsF(wrapper);
          return QFontMetricsF_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFontMetricsF_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFontMetricsF: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QFontMetricsF::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QHelpEvent(RJSApi& handler, QHelpEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QHelpEvent_Wrapper* ret = new QHelpEvent_Wrapper(handler, v, false);

          // JS: new QHelpEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QHelpEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QHelpEvent is undefined. Use QHelpEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QHelpEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QHelpEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QHelpEvent* RJSHelper::js2cpp_QHelpEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QHelpEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QHelpEvent_Wrapper* wrapper = qobject_cast<QHelpEvent_Wrapper*>(obj);
          //QHelpEvent_Wrapper* wrapper = dynamic_cast<QHelpEvent_Wrapper*>(obj);
          //QHelpEvent_Wrapper* wrapper = (QHelpEvent_Wrapper*)(obj);
          //QHelpEvent_Wrapper* wrapper = getWrapper<QHelpEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QHelpEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QHelpEvent(wrapper);
          return QHelpEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QHelpEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QHelpEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QHelpEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QIODeviceBase(RJSApi& handler, QIODeviceBase* v) {

          

          QJSEngine* engine = handler.getEngine();
          QIODeviceBase_Wrapper* ret = new QIODeviceBase_Wrapper(handler, v, false);

          // JS: new QIODeviceBase('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QIODeviceBase");
          if (cl.isUndefined()) {
              qWarning() << "Class QIODeviceBase is undefined. Use QIODeviceBase_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QIODeviceBase('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QIODeviceBase(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QIODeviceBase* RJSHelper::js2cpp_QIODeviceBase_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QIODeviceBase: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QIODeviceBase_Wrapper* wrapper = qobject_cast<QIODeviceBase_Wrapper*>(obj);
          //QIODeviceBase_Wrapper* wrapper = dynamic_cast<QIODeviceBase_Wrapper*>(obj);
          //QIODeviceBase_Wrapper* wrapper = (QIODeviceBase_Wrapper*)(obj);
          //QIODeviceBase_Wrapper* wrapper = getWrapper<QIODeviceBase_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QIODeviceBase_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QIODeviceBase(wrapper);
          return QIODeviceBase_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QIODeviceBase_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QIODeviceBase: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QIODeviceBase::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QImageReader(RJSApi& handler, QImageReader* v) {

          

          QJSEngine* engine = handler.getEngine();
          QImageReader_Wrapper* ret = new QImageReader_Wrapper(handler, v, false);

          // JS: new QImageReader('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QImageReader");
          if (cl.isUndefined()) {
              qWarning() << "Class QImageReader is undefined. Use QImageReader_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QImageReader('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QImageReader(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QImageReader* RJSHelper::js2cpp_QImageReader_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QImageReader: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QImageReader_Wrapper* wrapper = qobject_cast<QImageReader_Wrapper*>(obj);
          //QImageReader_Wrapper* wrapper = dynamic_cast<QImageReader_Wrapper*>(obj);
          //QImageReader_Wrapper* wrapper = (QImageReader_Wrapper*)(obj);
          //QImageReader_Wrapper* wrapper = getWrapper<QImageReader_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QImageReader_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QImageReader(wrapper);
          return QImageReader_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QImageReader_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QImageReader: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QImageReader::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QImageWriter(RJSApi& handler, QImageWriter* v) {

          

          QJSEngine* engine = handler.getEngine();
          QImageWriter_Wrapper* ret = new QImageWriter_Wrapper(handler, v, false);

          // JS: new QImageWriter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QImageWriter");
          if (cl.isUndefined()) {
              qWarning() << "Class QImageWriter is undefined. Use QImageWriter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QImageWriter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QImageWriter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QImageWriter* RJSHelper::js2cpp_QImageWriter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QImageWriter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QImageWriter_Wrapper* wrapper = qobject_cast<QImageWriter_Wrapper*>(obj);
          //QImageWriter_Wrapper* wrapper = dynamic_cast<QImageWriter_Wrapper*>(obj);
          //QImageWriter_Wrapper* wrapper = (QImageWriter_Wrapper*)(obj);
          //QImageWriter_Wrapper* wrapper = getWrapper<QImageWriter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QImageWriter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QImageWriter(wrapper);
          return QImageWriter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QImageWriter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QImageWriter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QImageWriter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QInputEvent(RJSApi& handler, QInputEvent* v) {

          
            // downcast to QPointerEvent:
            {
                QPointerEvent* o = dynamic_cast<QPointerEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPointerEvent(handler, o);
                }
            }
          
            // downcast to QKeyEvent:
            {
                QKeyEvent* o = dynamic_cast<QKeyEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QKeyEvent(handler, o);
                }
            }
          
            // downcast to QContextMenuEvent:
            {
                QContextMenuEvent* o = dynamic_cast<QContextMenuEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QContextMenuEvent(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QInputEvent_Wrapper* ret = new QInputEvent_Wrapper(handler, v, false);

          // JS: new QInputEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QInputEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QInputEvent is undefined. Use QInputEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QInputEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QInputEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QInputEvent* RJSHelper::js2cpp_QInputEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QInputEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QInputEvent_Wrapper* wrapper = qobject_cast<QInputEvent_Wrapper*>(obj);
          //QInputEvent_Wrapper* wrapper = dynamic_cast<QInputEvent_Wrapper*>(obj);
          //QInputEvent_Wrapper* wrapper = (QInputEvent_Wrapper*)(obj);
          //QInputEvent_Wrapper* wrapper = getWrapper<QInputEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QInputEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QInputEvent(wrapper);
          return QInputEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QInputEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QInputEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QInputEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QJSEngine(RJSApi& handler, QJSEngine* v) {

          
            // downcast to QQmlEngine:
            {
                QQmlEngine* o = dynamic_cast<QQmlEngine*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QQmlEngine(handler, o);
                }
            }
          
            // downcast to types derrived from QJSEngine but defined in other modules:
            for (int i=0; i<downcasters_QJSEngine.length(); i++) {
                QJSValue dc = downcasters_QJSEngine[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QJSEngine_Wrapper* ret = new QJSEngine_Wrapper(handler, v, false);

          // JS: new QJSEngine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QJSEngine");
          if (cl.isUndefined()) {
              qWarning() << "Class QJSEngine is undefined. Use QJSEngine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QJSEngine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QJSEngine(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QJSEngine* RJSHelper::js2cpp_QJSEngine_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QJSEngine: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QJSEngine_Wrapper* wrapper = qobject_cast<QJSEngine_Wrapper*>(obj);
          //QJSEngine_Wrapper* wrapper = dynamic_cast<QJSEngine_Wrapper*>(obj);
          //QJSEngine_Wrapper* wrapper = (QJSEngine_Wrapper*)(obj);
          //QJSEngine_Wrapper* wrapper = getWrapper<QJSEngine_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QJSEngine_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QJSEngine(wrapper);
          return QJSEngine_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QJSEngine_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QJSEngine: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QJSEngine::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QKeyEvent(RJSApi& handler, QKeyEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QKeyEvent_Wrapper* ret = new QKeyEvent_Wrapper(handler, v, false);

          // JS: new QKeyEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QKeyEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QKeyEvent is undefined. Use QKeyEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QKeyEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QKeyEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QKeyEvent* RJSHelper::js2cpp_QKeyEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QKeyEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QKeyEvent_Wrapper* wrapper = qobject_cast<QKeyEvent_Wrapper*>(obj);
          //QKeyEvent_Wrapper* wrapper = dynamic_cast<QKeyEvent_Wrapper*>(obj);
          //QKeyEvent_Wrapper* wrapper = (QKeyEvent_Wrapper*)(obj);
          //QKeyEvent_Wrapper* wrapper = getWrapper<QKeyEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QKeyEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QKeyEvent(wrapper);
          return QKeyEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QKeyEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QKeyEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QKeyEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QLayoutItem(RJSApi& handler, QLayoutItem* v) {

          
            // downcast to QLayout:
            {
                QLayout* o = dynamic_cast<QLayout*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QLayout(handler, o);
                }
            }
          
            // downcast to QSpacerItem:
            {
                QSpacerItem* o = dynamic_cast<QSpacerItem*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QSpacerItem(handler, o);
                }
            }
          
            // downcast to QWidgetItem:
            {
                QWidgetItem* o = dynamic_cast<QWidgetItem*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QWidgetItem(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QLayoutItem_Wrapper* ret = new QLayoutItem_Wrapper(handler, v, false);

          // JS: new QLayoutItem('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLayoutItem");
          if (cl.isUndefined()) {
              qWarning() << "Class QLayoutItem is undefined. Use QLayoutItem_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLayoutItem('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLayoutItem(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QLayoutItem* RJSHelper::js2cpp_QLayoutItem_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QLayoutItem: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QLayoutItem_Wrapper* wrapper = qobject_cast<QLayoutItem_Wrapper*>(obj);
          //QLayoutItem_Wrapper* wrapper = dynamic_cast<QLayoutItem_Wrapper*>(obj);
          //QLayoutItem_Wrapper* wrapper = (QLayoutItem_Wrapper*)(obj);
          //QLayoutItem_Wrapper* wrapper = getWrapper<QLayoutItem_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLayoutItem_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QLayoutItem(wrapper);
          return QLayoutItem_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QLayoutItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QLayoutItem: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QLayoutItem::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QListWidgetItem(RJSApi& handler, QListWidgetItem* v) {

          

          QJSEngine* engine = handler.getEngine();
          QListWidgetItem_Wrapper* ret = new QListWidgetItem_Wrapper(handler, v, false);

          // JS: new QListWidgetItem('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QListWidgetItem");
          if (cl.isUndefined()) {
              qWarning() << "Class QListWidgetItem is undefined. Use QListWidgetItem_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QListWidgetItem('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QListWidgetItem(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QListWidgetItem* RJSHelper::js2cpp_QListWidgetItem_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QListWidgetItem: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QListWidgetItem_Wrapper* wrapper = qobject_cast<QListWidgetItem_Wrapper*>(obj);
          //QListWidgetItem_Wrapper* wrapper = dynamic_cast<QListWidgetItem_Wrapper*>(obj);
          //QListWidgetItem_Wrapper* wrapper = (QListWidgetItem_Wrapper*)(obj);
          //QListWidgetItem_Wrapper* wrapper = getWrapper<QListWidgetItem_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QListWidgetItem_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QListWidgetItem(wrapper);
          return QListWidgetItem_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QListWidgetItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QListWidgetItem: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QListWidgetItem::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QMouseEvent(RJSApi& handler, QMouseEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QMouseEvent_Wrapper* ret = new QMouseEvent_Wrapper(handler, v, false);

          // JS: new QMouseEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMouseEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QMouseEvent is undefined. Use QMouseEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMouseEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMouseEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QMouseEvent* RJSHelper::js2cpp_QMouseEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMouseEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QMouseEvent_Wrapper* wrapper = qobject_cast<QMouseEvent_Wrapper*>(obj);
          //QMouseEvent_Wrapper* wrapper = dynamic_cast<QMouseEvent_Wrapper*>(obj);
          //QMouseEvent_Wrapper* wrapper = (QMouseEvent_Wrapper*)(obj);
          //QMouseEvent_Wrapper* wrapper = getWrapper<QMouseEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMouseEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QMouseEvent(wrapper);
          return QMouseEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QMouseEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMouseEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QMouseEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPagedPaintDevice(RJSApi& handler, QPagedPaintDevice* v) {

          
            // downcast to QPrinter:
            {
                QPrinter* o = dynamic_cast<QPrinter*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPrinter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QPagedPaintDevice_Wrapper* ret = new QPagedPaintDevice_Wrapper(handler, v, false);

          // JS: new QPagedPaintDevice('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPagedPaintDevice");
          if (cl.isUndefined()) {
              qWarning() << "Class QPagedPaintDevice is undefined. Use QPagedPaintDevice_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPagedPaintDevice('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPagedPaintDevice(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QPagedPaintDevice* RJSHelper::js2cpp_QPagedPaintDevice_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPagedPaintDevice: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPagedPaintDevice_Wrapper* wrapper = qobject_cast<QPagedPaintDevice_Wrapper*>(obj);
          //QPagedPaintDevice_Wrapper* wrapper = dynamic_cast<QPagedPaintDevice_Wrapper*>(obj);
          //QPagedPaintDevice_Wrapper* wrapper = (QPagedPaintDevice_Wrapper*)(obj);
          //QPagedPaintDevice_Wrapper* wrapper = getWrapper<QPagedPaintDevice_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPagedPaintDevice_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QPagedPaintDevice(wrapper);
          return QPagedPaintDevice_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPagedPaintDevice_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPagedPaintDevice: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QPagedPaintDevice::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPaintDevice(RJSApi& handler, QPaintDevice* v) {

          
            // downcast to QImage:
            {
                QImage* o = dynamic_cast<QImage*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QImage(handler, o);
                }
            }
          
            // downcast to QPagedPaintDevice:
            {
                QPagedPaintDevice* o = dynamic_cast<QPagedPaintDevice*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPagedPaintDevice(handler, o);
                }
            }
          
            // downcast to QPicture:
            {
                QPicture* o = dynamic_cast<QPicture*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPicture(handler, o);
                }
            }
          
            // downcast to QPixmap:
            {
                QPixmap* o = dynamic_cast<QPixmap*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPixmap(handler, o);
                }
            }
          
            // downcast to QWidget:
            {
                QWidget* o = dynamic_cast<QWidget*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QWidget(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QPaintDevice_Wrapper* ret = new QPaintDevice_Wrapper(handler, v, false);

          // JS: new QPaintDevice('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPaintDevice");
          if (cl.isUndefined()) {
              qWarning() << "Class QPaintDevice is undefined. Use QPaintDevice_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPaintDevice('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPaintDevice(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QPaintDevice* RJSHelper::js2cpp_QPaintDevice_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPaintDevice: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPaintDevice_Wrapper* wrapper = qobject_cast<QPaintDevice_Wrapper*>(obj);
          //QPaintDevice_Wrapper* wrapper = dynamic_cast<QPaintDevice_Wrapper*>(obj);
          //QPaintDevice_Wrapper* wrapper = (QPaintDevice_Wrapper*)(obj);
          //QPaintDevice_Wrapper* wrapper = getWrapper<QPaintDevice_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPaintDevice_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QPaintDevice(wrapper);
          return QPaintDevice_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPaintDevice_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPaintDevice: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QPaintDevice::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPaintEvent(RJSApi& handler, QPaintEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QPaintEvent_Wrapper* ret = new QPaintEvent_Wrapper(handler, v, false);

          // JS: new QPaintEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPaintEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QPaintEvent is undefined. Use QPaintEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPaintEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPaintEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QPaintEvent* RJSHelper::js2cpp_QPaintEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPaintEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPaintEvent_Wrapper* wrapper = qobject_cast<QPaintEvent_Wrapper*>(obj);
          //QPaintEvent_Wrapper* wrapper = dynamic_cast<QPaintEvent_Wrapper*>(obj);
          //QPaintEvent_Wrapper* wrapper = (QPaintEvent_Wrapper*)(obj);
          //QPaintEvent_Wrapper* wrapper = getWrapper<QPaintEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPaintEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QPaintEvent(wrapper);
          return QPaintEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPaintEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPaintEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QPaintEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPainter(RJSApi& handler, QPainter* v) {

          

          QJSEngine* engine = handler.getEngine();
          QPainter_Wrapper* ret = new QPainter_Wrapper(handler, v, false);

          // JS: new QPainter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPainter");
          if (cl.isUndefined()) {
              qWarning() << "Class QPainter is undefined. Use QPainter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPainter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPainter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QPainter* RJSHelper::js2cpp_QPainter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPainter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPainter_Wrapper* wrapper = qobject_cast<QPainter_Wrapper*>(obj);
          //QPainter_Wrapper* wrapper = dynamic_cast<QPainter_Wrapper*>(obj);
          //QPainter_Wrapper* wrapper = (QPainter_Wrapper*)(obj);
          //QPainter_Wrapper* wrapper = getWrapper<QPainter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPainter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QPainter(wrapper);
          return QPainter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPainter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPainter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QPainter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPanGesture(RJSApi& handler, QPanGesture* v) {

          

          QJSEngine* engine = handler.getEngine();
          QPanGesture_Wrapper* ret = new QPanGesture_Wrapper(handler, v, false);

          // JS: new QPanGesture('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPanGesture");
          if (cl.isUndefined()) {
              qWarning() << "Class QPanGesture is undefined. Use QPanGesture_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPanGesture('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPanGesture(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QPanGesture* RJSHelper::js2cpp_QPanGesture_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPanGesture: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPanGesture_Wrapper* wrapper = qobject_cast<QPanGesture_Wrapper*>(obj);
          //QPanGesture_Wrapper* wrapper = dynamic_cast<QPanGesture_Wrapper*>(obj);
          //QPanGesture_Wrapper* wrapper = (QPanGesture_Wrapper*)(obj);
          //QPanGesture_Wrapper* wrapper = getWrapper<QPanGesture_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPanGesture_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QPanGesture(wrapper);
          return QPanGesture_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPanGesture_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPanGesture: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QPanGesture::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPinchGesture(RJSApi& handler, QPinchGesture* v) {

          

          QJSEngine* engine = handler.getEngine();
          QPinchGesture_Wrapper* ret = new QPinchGesture_Wrapper(handler, v, false);

          // JS: new QPinchGesture('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPinchGesture");
          if (cl.isUndefined()) {
              qWarning() << "Class QPinchGesture is undefined. Use QPinchGesture_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPinchGesture('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPinchGesture(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QPinchGesture* RJSHelper::js2cpp_QPinchGesture_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPinchGesture: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPinchGesture_Wrapper* wrapper = qobject_cast<QPinchGesture_Wrapper*>(obj);
          //QPinchGesture_Wrapper* wrapper = dynamic_cast<QPinchGesture_Wrapper*>(obj);
          //QPinchGesture_Wrapper* wrapper = (QPinchGesture_Wrapper*)(obj);
          //QPinchGesture_Wrapper* wrapper = getWrapper<QPinchGesture_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPinchGesture_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QPinchGesture(wrapper);
          return QPinchGesture_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPinchGesture_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPinchGesture: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QPinchGesture::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPointerEvent(RJSApi& handler, QPointerEvent* v) {

          
            // downcast to QSinglePointEvent:
            {
                QSinglePointEvent* o = dynamic_cast<QSinglePointEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QSinglePointEvent(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QPointerEvent_Wrapper* ret = new QPointerEvent_Wrapper(handler, v, false);

          // JS: new QPointerEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPointerEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QPointerEvent is undefined. Use QPointerEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPointerEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPointerEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QPointerEvent* RJSHelper::js2cpp_QPointerEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPointerEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPointerEvent_Wrapper* wrapper = qobject_cast<QPointerEvent_Wrapper*>(obj);
          //QPointerEvent_Wrapper* wrapper = dynamic_cast<QPointerEvent_Wrapper*>(obj);
          //QPointerEvent_Wrapper* wrapper = (QPointerEvent_Wrapper*)(obj);
          //QPointerEvent_Wrapper* wrapper = getWrapper<QPointerEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPointerEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QPointerEvent(wrapper);
          return QPointerEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPointerEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPointerEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QPointerEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPrinter(RJSApi& handler, QPrinter* v) {

          

          QJSEngine* engine = handler.getEngine();
          QPrinter_Wrapper* ret = new QPrinter_Wrapper(handler, v, false);

          // JS: new QPrinter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPrinter");
          if (cl.isUndefined()) {
              qWarning() << "Class QPrinter is undefined. Use QPrinter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPrinter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPrinter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QPrinter* RJSHelper::js2cpp_QPrinter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPrinter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPrinter_Wrapper* wrapper = qobject_cast<QPrinter_Wrapper*>(obj);
          //QPrinter_Wrapper* wrapper = dynamic_cast<QPrinter_Wrapper*>(obj);
          //QPrinter_Wrapper* wrapper = (QPrinter_Wrapper*)(obj);
          //QPrinter_Wrapper* wrapper = getWrapper<QPrinter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPrinter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QPrinter(wrapper);
          return QPrinter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPrinter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPrinter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QPrinter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QProcess(RJSApi& handler, QProcess* v) {

          

          QJSEngine* engine = handler.getEngine();
          QProcess_Wrapper* ret = new QProcess_Wrapper(handler, v, false);

          // JS: new QProcess('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QProcess");
          if (cl.isUndefined()) {
              qWarning() << "Class QProcess is undefined. Use QProcess_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QProcess('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QProcess(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QProcess* RJSHelper::js2cpp_QProcess_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QProcess: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QProcess_Wrapper* wrapper = qobject_cast<QProcess_Wrapper*>(obj);
          //QProcess_Wrapper* wrapper = dynamic_cast<QProcess_Wrapper*>(obj);
          //QProcess_Wrapper* wrapper = (QProcess_Wrapper*)(obj);
          //QProcess_Wrapper* wrapper = getWrapper<QProcess_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QProcess_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QProcess(wrapper);
          return QProcess_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QProcess_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QProcess: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QProcess::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QQmlEngine(RJSApi& handler, QQmlEngine* v) {

          
            // downcast to QQmlApplicationEngine:
            {
                QQmlApplicationEngine* o = dynamic_cast<QQmlApplicationEngine*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QQmlApplicationEngine(handler, o);
                }
            }
          
            // downcast to types derrived from QQmlEngine but defined in other modules:
            for (int i=0; i<downcasters_QQmlEngine.length(); i++) {
                QJSValue dc = downcasters_QQmlEngine[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QQmlEngine_Wrapper* ret = new QQmlEngine_Wrapper(handler, v, false);

          // JS: new QQmlEngine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QQmlEngine");
          if (cl.isUndefined()) {
              qWarning() << "Class QQmlEngine is undefined. Use QQmlEngine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QQmlEngine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QQmlEngine(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QQmlEngine* RJSHelper::js2cpp_QQmlEngine_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QQmlEngine: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QQmlEngine_Wrapper* wrapper = qobject_cast<QQmlEngine_Wrapper*>(obj);
          //QQmlEngine_Wrapper* wrapper = dynamic_cast<QQmlEngine_Wrapper*>(obj);
          //QQmlEngine_Wrapper* wrapper = (QQmlEngine_Wrapper*)(obj);
          //QQmlEngine_Wrapper* wrapper = getWrapper<QQmlEngine_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QQmlEngine_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QQmlEngine(wrapper);
          return QQmlEngine_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QQmlEngine_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QQmlEngine: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QQmlEngine::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QQmlContext(RJSApi& handler, QQmlContext* v) {

          

          QJSEngine* engine = handler.getEngine();
          QQmlContext_Wrapper* ret = new QQmlContext_Wrapper(handler, v, false);

          // JS: new QQmlContext('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QQmlContext");
          if (cl.isUndefined()) {
              qWarning() << "Class QQmlContext is undefined. Use QQmlContext_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QQmlContext('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QQmlContext(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QQmlContext* RJSHelper::js2cpp_QQmlContext_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QQmlContext: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QQmlContext_Wrapper* wrapper = qobject_cast<QQmlContext_Wrapper*>(obj);
          //QQmlContext_Wrapper* wrapper = dynamic_cast<QQmlContext_Wrapper*>(obj);
          //QQmlContext_Wrapper* wrapper = (QQmlContext_Wrapper*)(obj);
          //QQmlContext_Wrapper* wrapper = getWrapper<QQmlContext_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QQmlContext_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QQmlContext(wrapper);
          return QQmlContext_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QQmlContext_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QQmlContext: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QQmlContext::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QQmlApplicationEngine(RJSApi& handler, QQmlApplicationEngine* v) {

          

          QJSEngine* engine = handler.getEngine();
          QQmlApplicationEngine_Wrapper* ret = new QQmlApplicationEngine_Wrapper(handler, v, false);

          // JS: new QQmlApplicationEngine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QQmlApplicationEngine");
          if (cl.isUndefined()) {
              qWarning() << "Class QQmlApplicationEngine is undefined. Use QQmlApplicationEngine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QQmlApplicationEngine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QQmlApplicationEngine(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QQmlApplicationEngine* RJSHelper::js2cpp_QQmlApplicationEngine_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QQmlApplicationEngine: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QQmlApplicationEngine_Wrapper* wrapper = qobject_cast<QQmlApplicationEngine_Wrapper*>(obj);
          //QQmlApplicationEngine_Wrapper* wrapper = dynamic_cast<QQmlApplicationEngine_Wrapper*>(obj);
          //QQmlApplicationEngine_Wrapper* wrapper = (QQmlApplicationEngine_Wrapper*)(obj);
          //QQmlApplicationEngine_Wrapper* wrapper = getWrapper<QQmlApplicationEngine_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QQmlApplicationEngine_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QQmlApplicationEngine(wrapper);
          return QQmlApplicationEngine_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QQmlApplicationEngine_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QQmlApplicationEngine: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QQmlApplicationEngine::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QResizeEvent(RJSApi& handler, QResizeEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QResizeEvent_Wrapper* ret = new QResizeEvent_Wrapper(handler, v, false);

          // JS: new QResizeEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QResizeEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QResizeEvent is undefined. Use QResizeEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QResizeEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QResizeEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QResizeEvent* RJSHelper::js2cpp_QResizeEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QResizeEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QResizeEvent_Wrapper* wrapper = qobject_cast<QResizeEvent_Wrapper*>(obj);
          //QResizeEvent_Wrapper* wrapper = dynamic_cast<QResizeEvent_Wrapper*>(obj);
          //QResizeEvent_Wrapper* wrapper = (QResizeEvent_Wrapper*)(obj);
          //QResizeEvent_Wrapper* wrapper = getWrapper<QResizeEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QResizeEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QResizeEvent(wrapper);
          return QResizeEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QResizeEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QResizeEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QResizeEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QSinglePointEvent(RJSApi& handler, QSinglePointEvent* v) {

          
            // downcast to QMouseEvent:
            {
                QMouseEvent* o = dynamic_cast<QMouseEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QMouseEvent(handler, o);
                }
            }
          
            // downcast to QWheelEvent:
            {
                QWheelEvent* o = dynamic_cast<QWheelEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QWheelEvent(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QSinglePointEvent_Wrapper* ret = new QSinglePointEvent_Wrapper(handler, v, false);

          // JS: new QSinglePointEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSinglePointEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QSinglePointEvent is undefined. Use QSinglePointEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSinglePointEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSinglePointEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QSinglePointEvent* RJSHelper::js2cpp_QSinglePointEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSinglePointEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSinglePointEvent_Wrapper* wrapper = qobject_cast<QSinglePointEvent_Wrapper*>(obj);
          //QSinglePointEvent_Wrapper* wrapper = dynamic_cast<QSinglePointEvent_Wrapper*>(obj);
          //QSinglePointEvent_Wrapper* wrapper = (QSinglePointEvent_Wrapper*)(obj);
          //QSinglePointEvent_Wrapper* wrapper = getWrapper<QSinglePointEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSinglePointEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QSinglePointEvent(wrapper);
          return QSinglePointEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSinglePointEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSinglePointEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QSinglePointEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QSpacerItem(RJSApi& handler, QSpacerItem* v) {

          

          QJSEngine* engine = handler.getEngine();
          QSpacerItem_Wrapper* ret = new QSpacerItem_Wrapper(handler, v, false);

          // JS: new QSpacerItem('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSpacerItem");
          if (cl.isUndefined()) {
              qWarning() << "Class QSpacerItem is undefined. Use QSpacerItem_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSpacerItem('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSpacerItem(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QSpacerItem* RJSHelper::js2cpp_QSpacerItem_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSpacerItem: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSpacerItem_Wrapper* wrapper = qobject_cast<QSpacerItem_Wrapper*>(obj);
          //QSpacerItem_Wrapper* wrapper = dynamic_cast<QSpacerItem_Wrapper*>(obj);
          //QSpacerItem_Wrapper* wrapper = (QSpacerItem_Wrapper*)(obj);
          //QSpacerItem_Wrapper* wrapper = getWrapper<QSpacerItem_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSpacerItem_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QSpacerItem(wrapper);
          return QSpacerItem_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSpacerItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSpacerItem: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QSpacerItem::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QStandardItem(RJSApi& handler, QStandardItem* v) {

          

          QJSEngine* engine = handler.getEngine();
          QStandardItem_Wrapper* ret = new QStandardItem_Wrapper(handler, v, false);

          // JS: new QStandardItem('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QStandardItem");
          if (cl.isUndefined()) {
              qWarning() << "Class QStandardItem is undefined. Use QStandardItem_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QStandardItem('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QStandardItem(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QStandardItem* RJSHelper::js2cpp_QStandardItem_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QStandardItem: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QStandardItem_Wrapper* wrapper = qobject_cast<QStandardItem_Wrapper*>(obj);
          //QStandardItem_Wrapper* wrapper = dynamic_cast<QStandardItem_Wrapper*>(obj);
          //QStandardItem_Wrapper* wrapper = (QStandardItem_Wrapper*)(obj);
          //QStandardItem_Wrapper* wrapper = getWrapper<QStandardItem_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QStandardItem_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QStandardItem(wrapper);
          return QStandardItem_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QStandardItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QStandardItem: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QStandardItem::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QStringConverter(RJSApi& handler, QStringConverter* v) {

          

          QJSEngine* engine = handler.getEngine();
          QStringConverter_Wrapper* ret = new QStringConverter_Wrapper(handler, v, false);

          // JS: new QStringConverter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QStringConverter");
          if (cl.isUndefined()) {
              qWarning() << "Class QStringConverter is undefined. Use QStringConverter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QStringConverter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QStringConverter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QStringConverter* RJSHelper::js2cpp_QStringConverter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QStringConverter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QStringConverter_Wrapper* wrapper = qobject_cast<QStringConverter_Wrapper*>(obj);
          //QStringConverter_Wrapper* wrapper = dynamic_cast<QStringConverter_Wrapper*>(obj);
          //QStringConverter_Wrapper* wrapper = (QStringConverter_Wrapper*)(obj);
          //QStringConverter_Wrapper* wrapper = getWrapper<QStringConverter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QStringConverter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QStringConverter(wrapper);
          return QStringConverter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QStringConverter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QStringConverter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QStringConverter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QStringDecoder(RJSApi& handler, QStringDecoder* v) {

          

          QJSEngine* engine = handler.getEngine();
          QStringDecoder_Wrapper* ret = new QStringDecoder_Wrapper(handler, v, false);

          // JS: new QStringDecoder('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QStringDecoder");
          if (cl.isUndefined()) {
              qWarning() << "Class QStringDecoder is undefined. Use QStringDecoder_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QStringDecoder('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QStringDecoder(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QStringDecoder* RJSHelper::js2cpp_QStringDecoder_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QStringDecoder: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QStringDecoder_Wrapper* wrapper = qobject_cast<QStringDecoder_Wrapper*>(obj);
          //QStringDecoder_Wrapper* wrapper = dynamic_cast<QStringDecoder_Wrapper*>(obj);
          //QStringDecoder_Wrapper* wrapper = (QStringDecoder_Wrapper*)(obj);
          //QStringDecoder_Wrapper* wrapper = getWrapper<QStringDecoder_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QStringDecoder_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QStringDecoder(wrapper);
          return QStringDecoder_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QStringDecoder_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QStringDecoder: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QStringDecoder::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QStringEncoder(RJSApi& handler, QStringEncoder* v) {

          

          QJSEngine* engine = handler.getEngine();
          QStringEncoder_Wrapper* ret = new QStringEncoder_Wrapper(handler, v, false);

          // JS: new QStringEncoder('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QStringEncoder");
          if (cl.isUndefined()) {
              qWarning() << "Class QStringEncoder is undefined. Use QStringEncoder_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QStringEncoder('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QStringEncoder(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QStringEncoder* RJSHelper::js2cpp_QStringEncoder_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QStringEncoder: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QStringEncoder_Wrapper* wrapper = qobject_cast<QStringEncoder_Wrapper*>(obj);
          //QStringEncoder_Wrapper* wrapper = dynamic_cast<QStringEncoder_Wrapper*>(obj);
          //QStringEncoder_Wrapper* wrapper = (QStringEncoder_Wrapper*)(obj);
          //QStringEncoder_Wrapper* wrapper = getWrapper<QStringEncoder_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QStringEncoder_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QStringEncoder(wrapper);
          return QStringEncoder_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QStringEncoder_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QStringEncoder: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QStringEncoder::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QSwipeGesture(RJSApi& handler, QSwipeGesture* v) {

          

          QJSEngine* engine = handler.getEngine();
          QSwipeGesture_Wrapper* ret = new QSwipeGesture_Wrapper(handler, v, false);

          // JS: new QSwipeGesture('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSwipeGesture");
          if (cl.isUndefined()) {
              qWarning() << "Class QSwipeGesture is undefined. Use QSwipeGesture_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSwipeGesture('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSwipeGesture(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QSwipeGesture* RJSHelper::js2cpp_QSwipeGesture_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSwipeGesture: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSwipeGesture_Wrapper* wrapper = qobject_cast<QSwipeGesture_Wrapper*>(obj);
          //QSwipeGesture_Wrapper* wrapper = dynamic_cast<QSwipeGesture_Wrapper*>(obj);
          //QSwipeGesture_Wrapper* wrapper = (QSwipeGesture_Wrapper*)(obj);
          //QSwipeGesture_Wrapper* wrapper = getWrapper<QSwipeGesture_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSwipeGesture_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QSwipeGesture(wrapper);
          return QSwipeGesture_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSwipeGesture_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSwipeGesture: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QSwipeGesture::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTableWidgetItem(RJSApi& handler, QTableWidgetItem* v) {

          

          QJSEngine* engine = handler.getEngine();
          QTableWidgetItem_Wrapper* ret = new QTableWidgetItem_Wrapper(handler, v, false);

          // JS: new QTableWidgetItem('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTableWidgetItem");
          if (cl.isUndefined()) {
              qWarning() << "Class QTableWidgetItem is undefined. Use QTableWidgetItem_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTableWidgetItem('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTableWidgetItem(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QTableWidgetItem* RJSHelper::js2cpp_QTableWidgetItem_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTableWidgetItem: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTableWidgetItem_Wrapper* wrapper = qobject_cast<QTableWidgetItem_Wrapper*>(obj);
          //QTableWidgetItem_Wrapper* wrapper = dynamic_cast<QTableWidgetItem_Wrapper*>(obj);
          //QTableWidgetItem_Wrapper* wrapper = (QTableWidgetItem_Wrapper*)(obj);
          //QTableWidgetItem_Wrapper* wrapper = getWrapper<QTableWidgetItem_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTableWidgetItem_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QTableWidgetItem(wrapper);
          return QTableWidgetItem_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTableWidgetItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTableWidgetItem: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QTableWidgetItem::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextCursor(RJSApi& handler, QTextCursor* v) {

          

          QJSEngine* engine = handler.getEngine();
          QTextCursor_Wrapper* ret = new QTextCursor_Wrapper(handler, v, false);

          // JS: new QTextCursor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextCursor");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextCursor is undefined. Use QTextCursor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextCursor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextCursor(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QTextCursor* RJSHelper::js2cpp_QTextCursor_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextCursor: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTextCursor_Wrapper* wrapper = qobject_cast<QTextCursor_Wrapper*>(obj);
          //QTextCursor_Wrapper* wrapper = dynamic_cast<QTextCursor_Wrapper*>(obj);
          //QTextCursor_Wrapper* wrapper = (QTextCursor_Wrapper*)(obj);
          //QTextCursor_Wrapper* wrapper = getWrapper<QTextCursor_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextCursor_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QTextCursor(wrapper);
          return QTextCursor_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTextCursor_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextCursor: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QTextCursor::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextLayout(RJSApi& handler, QTextLayout* v) {

          

          QJSEngine* engine = handler.getEngine();
          QTextLayout_Wrapper* ret = new QTextLayout_Wrapper(handler, v, false);

          // JS: new QTextLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextLayout is undefined. Use QTextLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextLayout('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QTextLayout* RJSHelper::js2cpp_QTextLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextLayout: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTextLayout_Wrapper* wrapper = qobject_cast<QTextLayout_Wrapper*>(obj);
          //QTextLayout_Wrapper* wrapper = dynamic_cast<QTextLayout_Wrapper*>(obj);
          //QTextLayout_Wrapper* wrapper = (QTextLayout_Wrapper*)(obj);
          //QTextLayout_Wrapper* wrapper = getWrapper<QTextLayout_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextLayout_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QTextLayout(wrapper);
          return QTextLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTextLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QTextLayout::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextStream(RJSApi& handler, QTextStream* v) {

          

          QJSEngine* engine = handler.getEngine();
          QTextStream_Wrapper* ret = new QTextStream_Wrapper(handler, v, false);

          // JS: new QTextStream('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextStream");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextStream is undefined. Use QTextStream_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextStream('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextStream(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QTextStream* RJSHelper::js2cpp_QTextStream_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextStream: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTextStream_Wrapper* wrapper = qobject_cast<QTextStream_Wrapper*>(obj);
          //QTextStream_Wrapper* wrapper = dynamic_cast<QTextStream_Wrapper*>(obj);
          //QTextStream_Wrapper* wrapper = (QTextStream_Wrapper*)(obj);
          //QTextStream_Wrapper* wrapper = getWrapper<QTextStream_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextStream_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QTextStream(wrapper);
          return QTextStream_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTextStream_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextStream: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QTextStream::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QToolTip(RJSApi& handler, QToolTip* v) {

          

          QJSEngine* engine = handler.getEngine();
          QToolTip_Wrapper* ret = new QToolTip_Wrapper(handler, v, false);

          // JS: new QToolTip('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QToolTip");
          if (cl.isUndefined()) {
              qWarning() << "Class QToolTip is undefined. Use QToolTip_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QToolTip('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QToolTip(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QToolTip* RJSHelper::js2cpp_QToolTip_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QToolTip: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QToolTip_Wrapper* wrapper = qobject_cast<QToolTip_Wrapper*>(obj);
          //QToolTip_Wrapper* wrapper = dynamic_cast<QToolTip_Wrapper*>(obj);
          //QToolTip_Wrapper* wrapper = (QToolTip_Wrapper*)(obj);
          //QToolTip_Wrapper* wrapper = getWrapper<QToolTip_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QToolTip_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QToolTip(wrapper);
          return QToolTip_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QToolTip_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QToolTip: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QToolTip::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTreeWidgetItem(RJSApi& handler, QTreeWidgetItem* v) {

          

          QJSEngine* engine = handler.getEngine();
          QTreeWidgetItem_Wrapper* ret = new QTreeWidgetItem_Wrapper(handler, v, false);

          // JS: new QTreeWidgetItem('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTreeWidgetItem");
          if (cl.isUndefined()) {
              qWarning() << "Class QTreeWidgetItem is undefined. Use QTreeWidgetItem_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTreeWidgetItem('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTreeWidgetItem(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QTreeWidgetItem* RJSHelper::js2cpp_QTreeWidgetItem_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTreeWidgetItem: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTreeWidgetItem_Wrapper* wrapper = qobject_cast<QTreeWidgetItem_Wrapper*>(obj);
          //QTreeWidgetItem_Wrapper* wrapper = dynamic_cast<QTreeWidgetItem_Wrapper*>(obj);
          //QTreeWidgetItem_Wrapper* wrapper = (QTreeWidgetItem_Wrapper*)(obj);
          //QTreeWidgetItem_Wrapper* wrapper = getWrapper<QTreeWidgetItem_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTreeWidgetItem_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QTreeWidgetItem(wrapper);
          return QTreeWidgetItem_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTreeWidgetItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTreeWidgetItem: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QTreeWidgetItem::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QUiLoader(RJSApi& handler, QUiLoader* v) {

          

          QJSEngine* engine = handler.getEngine();
          QUiLoader_Wrapper* ret = new QUiLoader_Wrapper(handler, v, false);

          // JS: new QUiLoader('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QUiLoader");
          if (cl.isUndefined()) {
              qWarning() << "Class QUiLoader is undefined. Use QUiLoader_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QUiLoader('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QUiLoader(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QUiLoader* RJSHelper::js2cpp_QUiLoader_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QUiLoader: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QUiLoader_Wrapper* wrapper = qobject_cast<QUiLoader_Wrapper*>(obj);
          //QUiLoader_Wrapper* wrapper = dynamic_cast<QUiLoader_Wrapper*>(obj);
          //QUiLoader_Wrapper* wrapper = (QUiLoader_Wrapper*)(obj);
          //QUiLoader_Wrapper* wrapper = getWrapper<QUiLoader_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QUiLoader_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QUiLoader(wrapper);
          return QUiLoader_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QUiLoader_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QUiLoader: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QUiLoader::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QWheelEvent(RJSApi& handler, QWheelEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QWheelEvent_Wrapper* ret = new QWheelEvent_Wrapper(handler, v, false);

          // JS: new QWheelEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QWheelEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QWheelEvent is undefined. Use QWheelEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QWheelEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QWheelEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QWheelEvent* RJSHelper::js2cpp_QWheelEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QWheelEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QWheelEvent_Wrapper* wrapper = qobject_cast<QWheelEvent_Wrapper*>(obj);
          //QWheelEvent_Wrapper* wrapper = dynamic_cast<QWheelEvent_Wrapper*>(obj);
          //QWheelEvent_Wrapper* wrapper = (QWheelEvent_Wrapper*)(obj);
          //QWheelEvent_Wrapper* wrapper = getWrapper<QWheelEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QWheelEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QWheelEvent(wrapper);
          return QWheelEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QWheelEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QWheelEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QWheelEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QWidgetItem(RJSApi& handler, QWidgetItem* v) {

          

          QJSEngine* engine = handler.getEngine();
          QWidgetItem_Wrapper* ret = new QWidgetItem_Wrapper(handler, v, false);

          // JS: new QWidgetItem('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QWidgetItem");
          if (cl.isUndefined()) {
              qWarning() << "Class QWidgetItem is undefined. Use QWidgetItem_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QWidgetItem('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QWidgetItem(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QWidgetItem* RJSHelper::js2cpp_QWidgetItem_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QWidgetItem: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QWidgetItem_Wrapper* wrapper = qobject_cast<QWidgetItem_Wrapper*>(obj);
          //QWidgetItem_Wrapper* wrapper = dynamic_cast<QWidgetItem_Wrapper*>(obj);
          //QWidgetItem_Wrapper* wrapper = (QWidgetItem_Wrapper*)(obj);
          //QWidgetItem_Wrapper* wrapper = getWrapper<QWidgetItem_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QWidgetItem_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QWidgetItem(wrapper);
          return QWidgetItem_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QWidgetItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QWidgetItem: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QWidgetItem::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlContentHandler(RJSApi& handler, QXmlContentHandler* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlContentHandler_Wrapper* ret = new QXmlContentHandler_Wrapper(handler, v, false);

          // JS: new QXmlContentHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlContentHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlContentHandler is undefined. Use QXmlContentHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlContentHandler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlContentHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlContentHandler* RJSHelper::js2cpp_QXmlContentHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlContentHandler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlContentHandler_Wrapper* wrapper = qobject_cast<QXmlContentHandler_Wrapper*>(obj);
          //QXmlContentHandler_Wrapper* wrapper = dynamic_cast<QXmlContentHandler_Wrapper*>(obj);
          //QXmlContentHandler_Wrapper* wrapper = (QXmlContentHandler_Wrapper*)(obj);
          //QXmlContentHandler_Wrapper* wrapper = getWrapper<QXmlContentHandler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlContentHandler_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlContentHandler(wrapper);
          return QXmlContentHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlContentHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlContentHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlContentHandler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlDTDHandler(RJSApi& handler, QXmlDTDHandler* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlDTDHandler_Wrapper* ret = new QXmlDTDHandler_Wrapper(handler, v, false);

          // JS: new QXmlDTDHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlDTDHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlDTDHandler is undefined. Use QXmlDTDHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlDTDHandler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlDTDHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlDTDHandler* RJSHelper::js2cpp_QXmlDTDHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlDTDHandler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlDTDHandler_Wrapper* wrapper = qobject_cast<QXmlDTDHandler_Wrapper*>(obj);
          //QXmlDTDHandler_Wrapper* wrapper = dynamic_cast<QXmlDTDHandler_Wrapper*>(obj);
          //QXmlDTDHandler_Wrapper* wrapper = (QXmlDTDHandler_Wrapper*)(obj);
          //QXmlDTDHandler_Wrapper* wrapper = getWrapper<QXmlDTDHandler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlDTDHandler_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlDTDHandler(wrapper);
          return QXmlDTDHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlDTDHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlDTDHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlDTDHandler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlDeclHandler(RJSApi& handler, QXmlDeclHandler* v) {

          
            // downcast to QXmlDefaultHandler:
            {
                QXmlDefaultHandler* o = dynamic_cast<QXmlDefaultHandler*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QXmlDefaultHandler(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QXmlDeclHandler_Wrapper* ret = new QXmlDeclHandler_Wrapper(handler, v, false);

          // JS: new QXmlDeclHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlDeclHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlDeclHandler is undefined. Use QXmlDeclHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlDeclHandler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlDeclHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlDeclHandler* RJSHelper::js2cpp_QXmlDeclHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlDeclHandler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlDeclHandler_Wrapper* wrapper = qobject_cast<QXmlDeclHandler_Wrapper*>(obj);
          //QXmlDeclHandler_Wrapper* wrapper = dynamic_cast<QXmlDeclHandler_Wrapper*>(obj);
          //QXmlDeclHandler_Wrapper* wrapper = (QXmlDeclHandler_Wrapper*)(obj);
          //QXmlDeclHandler_Wrapper* wrapper = getWrapper<QXmlDeclHandler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlDeclHandler_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlDeclHandler(wrapper);
          return QXmlDeclHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlDeclHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlDeclHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlDeclHandler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlDefaultHandler(RJSApi& handler, QXmlDefaultHandler* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlDefaultHandler_Wrapper* ret = new QXmlDefaultHandler_Wrapper(handler, v, false);

          // JS: new QXmlDefaultHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlDefaultHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlDefaultHandler is undefined. Use QXmlDefaultHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlDefaultHandler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlDefaultHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlDefaultHandler* RJSHelper::js2cpp_QXmlDefaultHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlDefaultHandler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlDefaultHandler_Wrapper* wrapper = qobject_cast<QXmlDefaultHandler_Wrapper*>(obj);
          //QXmlDefaultHandler_Wrapper* wrapper = dynamic_cast<QXmlDefaultHandler_Wrapper*>(obj);
          //QXmlDefaultHandler_Wrapper* wrapper = (QXmlDefaultHandler_Wrapper*)(obj);
          //QXmlDefaultHandler_Wrapper* wrapper = getWrapper<QXmlDefaultHandler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlDefaultHandler_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlDefaultHandler(wrapper);
          return QXmlDefaultHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlDefaultHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlDefaultHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlDefaultHandler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlEntityResolver(RJSApi& handler, QXmlEntityResolver* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlEntityResolver_Wrapper* ret = new QXmlEntityResolver_Wrapper(handler, v, false);

          // JS: new QXmlEntityResolver('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlEntityResolver");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlEntityResolver is undefined. Use QXmlEntityResolver_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlEntityResolver('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlEntityResolver(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlEntityResolver* RJSHelper::js2cpp_QXmlEntityResolver_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlEntityResolver: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlEntityResolver_Wrapper* wrapper = qobject_cast<QXmlEntityResolver_Wrapper*>(obj);
          //QXmlEntityResolver_Wrapper* wrapper = dynamic_cast<QXmlEntityResolver_Wrapper*>(obj);
          //QXmlEntityResolver_Wrapper* wrapper = (QXmlEntityResolver_Wrapper*)(obj);
          //QXmlEntityResolver_Wrapper* wrapper = getWrapper<QXmlEntityResolver_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlEntityResolver_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlEntityResolver(wrapper);
          return QXmlEntityResolver_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlEntityResolver_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlEntityResolver: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlEntityResolver::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlErrorHandler(RJSApi& handler, QXmlErrorHandler* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlErrorHandler_Wrapper* ret = new QXmlErrorHandler_Wrapper(handler, v, false);

          // JS: new QXmlErrorHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlErrorHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlErrorHandler is undefined. Use QXmlErrorHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlErrorHandler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlErrorHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlErrorHandler* RJSHelper::js2cpp_QXmlErrorHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlErrorHandler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlErrorHandler_Wrapper* wrapper = qobject_cast<QXmlErrorHandler_Wrapper*>(obj);
          //QXmlErrorHandler_Wrapper* wrapper = dynamic_cast<QXmlErrorHandler_Wrapper*>(obj);
          //QXmlErrorHandler_Wrapper* wrapper = (QXmlErrorHandler_Wrapper*)(obj);
          //QXmlErrorHandler_Wrapper* wrapper = getWrapper<QXmlErrorHandler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlErrorHandler_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlErrorHandler(wrapper);
          return QXmlErrorHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlErrorHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlErrorHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlErrorHandler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlInputSource(RJSApi& handler, QXmlInputSource* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlInputSource_Wrapper* ret = new QXmlInputSource_Wrapper(handler, v, false);

          // JS: new QXmlInputSource('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlInputSource");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlInputSource is undefined. Use QXmlInputSource_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlInputSource('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlInputSource(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlInputSource* RJSHelper::js2cpp_QXmlInputSource_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlInputSource: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlInputSource_Wrapper* wrapper = qobject_cast<QXmlInputSource_Wrapper*>(obj);
          //QXmlInputSource_Wrapper* wrapper = dynamic_cast<QXmlInputSource_Wrapper*>(obj);
          //QXmlInputSource_Wrapper* wrapper = (QXmlInputSource_Wrapper*)(obj);
          //QXmlInputSource_Wrapper* wrapper = getWrapper<QXmlInputSource_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlInputSource_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlInputSource(wrapper);
          return QXmlInputSource_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlInputSource_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlInputSource: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlInputSource::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlLexicalHandler(RJSApi& handler, QXmlLexicalHandler* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlLexicalHandler_Wrapper* ret = new QXmlLexicalHandler_Wrapper(handler, v, false);

          // JS: new QXmlLexicalHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlLexicalHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlLexicalHandler is undefined. Use QXmlLexicalHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlLexicalHandler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlLexicalHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlLexicalHandler* RJSHelper::js2cpp_QXmlLexicalHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlLexicalHandler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlLexicalHandler_Wrapper* wrapper = qobject_cast<QXmlLexicalHandler_Wrapper*>(obj);
          //QXmlLexicalHandler_Wrapper* wrapper = dynamic_cast<QXmlLexicalHandler_Wrapper*>(obj);
          //QXmlLexicalHandler_Wrapper* wrapper = (QXmlLexicalHandler_Wrapper*)(obj);
          //QXmlLexicalHandler_Wrapper* wrapper = getWrapper<QXmlLexicalHandler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlLexicalHandler_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlLexicalHandler(wrapper);
          return QXmlLexicalHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlLexicalHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlLexicalHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlLexicalHandler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlLocator(RJSApi& handler, QXmlLocator* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlLocator_Wrapper* ret = new QXmlLocator_Wrapper(handler, v, false);

          // JS: new QXmlLocator('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlLocator");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlLocator is undefined. Use QXmlLocator_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlLocator('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlLocator(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlLocator* RJSHelper::js2cpp_QXmlLocator_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlLocator: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlLocator_Wrapper* wrapper = qobject_cast<QXmlLocator_Wrapper*>(obj);
          //QXmlLocator_Wrapper* wrapper = dynamic_cast<QXmlLocator_Wrapper*>(obj);
          //QXmlLocator_Wrapper* wrapper = (QXmlLocator_Wrapper*)(obj);
          //QXmlLocator_Wrapper* wrapper = getWrapper<QXmlLocator_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlLocator_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlLocator(wrapper);
          return QXmlLocator_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlLocator_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlLocator: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlLocator::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlParseException(RJSApi& handler, QXmlParseException* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlParseException_Wrapper* ret = new QXmlParseException_Wrapper(handler, v, false);

          // JS: new QXmlParseException('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlParseException");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlParseException is undefined. Use QXmlParseException_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlParseException('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlParseException(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlParseException* RJSHelper::js2cpp_QXmlParseException_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlParseException: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlParseException_Wrapper* wrapper = qobject_cast<QXmlParseException_Wrapper*>(obj);
          //QXmlParseException_Wrapper* wrapper = dynamic_cast<QXmlParseException_Wrapper*>(obj);
          //QXmlParseException_Wrapper* wrapper = (QXmlParseException_Wrapper*)(obj);
          //QXmlParseException_Wrapper* wrapper = getWrapper<QXmlParseException_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlParseException_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlParseException(wrapper);
          return QXmlParseException_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlParseException_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlParseException: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlParseException::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlReader(RJSApi& handler, QXmlReader* v) {

          
            // downcast to QXmlSimpleReader:
            {
                QXmlSimpleReader* o = dynamic_cast<QXmlSimpleReader*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QXmlSimpleReader(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QXmlReader_Wrapper* ret = new QXmlReader_Wrapper(handler, v, false);

          // JS: new QXmlReader('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlReader");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlReader is undefined. Use QXmlReader_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlReader('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlReader(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlReader* RJSHelper::js2cpp_QXmlReader_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlReader: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlReader_Wrapper* wrapper = qobject_cast<QXmlReader_Wrapper*>(obj);
          //QXmlReader_Wrapper* wrapper = dynamic_cast<QXmlReader_Wrapper*>(obj);
          //QXmlReader_Wrapper* wrapper = (QXmlReader_Wrapper*)(obj);
          //QXmlReader_Wrapper* wrapper = getWrapper<QXmlReader_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlReader_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlReader(wrapper);
          return QXmlReader_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlReader_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlReader: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlReader::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlSimpleReader(RJSApi& handler, QXmlSimpleReader* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlSimpleReader_Wrapper* ret = new QXmlSimpleReader_Wrapper(handler, v, false);

          // JS: new QXmlSimpleReader('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlSimpleReader");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlSimpleReader is undefined. Use QXmlSimpleReader_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlSimpleReader('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlSimpleReader(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlSimpleReader* RJSHelper::js2cpp_QXmlSimpleReader_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlSimpleReader: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlSimpleReader_Wrapper* wrapper = qobject_cast<QXmlSimpleReader_Wrapper*>(obj);
          //QXmlSimpleReader_Wrapper* wrapper = dynamic_cast<QXmlSimpleReader_Wrapper*>(obj);
          //QXmlSimpleReader_Wrapper* wrapper = (QXmlSimpleReader_Wrapper*)(obj);
          //QXmlSimpleReader_Wrapper* wrapper = getWrapper<QXmlSimpleReader_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlSimpleReader_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlSimpleReader(wrapper);
          return QXmlSimpleReader_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlSimpleReader_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlSimpleReader: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlSimpleReader::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlStreamAttribute(RJSApi& handler, QXmlStreamAttribute* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlStreamAttribute_Wrapper* ret = new QXmlStreamAttribute_Wrapper(handler, v, false);

          // JS: new QXmlStreamAttribute('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlStreamAttribute");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlStreamAttribute is undefined. Use QXmlStreamAttribute_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlStreamAttribute('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlStreamAttribute(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlStreamAttribute* RJSHelper::js2cpp_QXmlStreamAttribute_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlStreamAttribute: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlStreamAttribute_Wrapper* wrapper = qobject_cast<QXmlStreamAttribute_Wrapper*>(obj);
          //QXmlStreamAttribute_Wrapper* wrapper = dynamic_cast<QXmlStreamAttribute_Wrapper*>(obj);
          //QXmlStreamAttribute_Wrapper* wrapper = (QXmlStreamAttribute_Wrapper*)(obj);
          //QXmlStreamAttribute_Wrapper* wrapper = getWrapper<QXmlStreamAttribute_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlStreamAttribute_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlStreamAttribute(wrapper);
          return QXmlStreamAttribute_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlStreamAttribute_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlStreamAttribute: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlStreamAttribute::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlStreamReader(RJSApi& handler, QXmlStreamReader* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlStreamReader_Wrapper* ret = new QXmlStreamReader_Wrapper(handler, v, false);

          // JS: new QXmlStreamReader('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlStreamReader");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlStreamReader is undefined. Use QXmlStreamReader_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlStreamReader('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlStreamReader(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlStreamReader* RJSHelper::js2cpp_QXmlStreamReader_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlStreamReader: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlStreamReader_Wrapper* wrapper = qobject_cast<QXmlStreamReader_Wrapper*>(obj);
          //QXmlStreamReader_Wrapper* wrapper = dynamic_cast<QXmlStreamReader_Wrapper*>(obj);
          //QXmlStreamReader_Wrapper* wrapper = (QXmlStreamReader_Wrapper*)(obj);
          //QXmlStreamReader_Wrapper* wrapper = getWrapper<QXmlStreamReader_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlStreamReader_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlStreamReader(wrapper);
          return QXmlStreamReader_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlStreamReader_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlStreamReader: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlStreamReader::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlStreamWriter(RJSApi& handler, QXmlStreamWriter* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlStreamWriter_Wrapper* ret = new QXmlStreamWriter_Wrapper(handler, v, false);

          // JS: new QXmlStreamWriter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlStreamWriter");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlStreamWriter is undefined. Use QXmlStreamWriter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlStreamWriter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlStreamWriter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlStreamWriter* RJSHelper::js2cpp_QXmlStreamWriter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlStreamWriter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlStreamWriter_Wrapper* wrapper = qobject_cast<QXmlStreamWriter_Wrapper*>(obj);
          //QXmlStreamWriter_Wrapper* wrapper = dynamic_cast<QXmlStreamWriter_Wrapper*>(obj);
          //QXmlStreamWriter_Wrapper* wrapper = (QXmlStreamWriter_Wrapper*)(obj);
          //QXmlStreamWriter_Wrapper* wrapper = getWrapper<QXmlStreamWriter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlStreamWriter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlStreamWriter(wrapper);
          return QXmlStreamWriter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlStreamWriter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlStreamWriter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlStreamWriter::getIdStatic())).toBool();
      }
    
  // ------------------------------
  // wrapped QObject pointer types:
  // ------------------------------
  
      QJSValue RJSHelper::cpp2js_QAbstractButton(RJSApi& handler, QAbstractButton* v) {
          
            // downcast to QCheckBox:
            {
                QCheckBox* o = qobject_cast<QCheckBox*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QCheckBox(handler, o);
                }
            }
          
            // downcast to QPushButton:
            {
                QPushButton* o = qobject_cast<QPushButton*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPushButton(handler, o);
                }
            }
          
            // downcast to QRadioButton:
            {
                QRadioButton* o = qobject_cast<QRadioButton*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QRadioButton(handler, o);
                }
            }
          
            // downcast to QToolButton:
            {
                QToolButton* o = qobject_cast<QToolButton*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QToolButton(handler, o);
                }
            }
          QAbstractButton_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAbstractButton_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAbstractButton: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAbstractButton_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAbstractButton_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAbstractButton('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractButton");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractButton is undefined. Use QAbstractButton_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractButton('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractButton(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAbstractButton(RJSApi& handler, const QAbstractButton* v) {
          return RJSHelper::cpp2js_QAbstractButton(handler, const_cast<QAbstractButton*>(v));
      }

      QAbstractButton* RJSHelper::js2cpp_QAbstractButton_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractButton: not a QObject";
              return nullptr;
          }
          //QAbstractButton_Wrapper* wrapper = getWrapper<QAbstractButton_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAbstractButton_Wrapper* wrapper = qobject_cast<QAbstractButton_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractButton_Wrapper* wrapper = dynamic_cast<QAbstractButton_Wrapper*>(obj);
          //QAbstractButton_Wrapper* wrapper = (QAbstractButton_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractButton: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAbstractButton*)wrapper->getWrappedVoid();
          //return getWrapped_QAbstractButton(wrapper);
          return QAbstractButton_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractButton_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractButton: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAbstractButton_Type);
          //return fun.call().toInt()==RJSType::QAbstractButton_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractButton::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QAbstractItemDelegate(RJSApi& handler, QAbstractItemDelegate* v) {
          
            // downcast to QItemDelegate:
            {
                QItemDelegate* o = qobject_cast<QItemDelegate*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QItemDelegate(handler, o);
                }
            }
          QAbstractItemDelegate_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAbstractItemDelegate_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAbstractItemDelegate: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAbstractItemDelegate_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAbstractItemDelegate_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAbstractItemDelegate('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractItemDelegate");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractItemDelegate is undefined. Use QAbstractItemDelegate_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractItemDelegate('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractItemDelegate(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAbstractItemDelegate(RJSApi& handler, const QAbstractItemDelegate* v) {
          return RJSHelper::cpp2js_QAbstractItemDelegate(handler, const_cast<QAbstractItemDelegate*>(v));
      }

      QAbstractItemDelegate* RJSHelper::js2cpp_QAbstractItemDelegate_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractItemDelegate: not a QObject";
              return nullptr;
          }
          //QAbstractItemDelegate_Wrapper* wrapper = getWrapper<QAbstractItemDelegate_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAbstractItemDelegate_Wrapper* wrapper = qobject_cast<QAbstractItemDelegate_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractItemDelegate_Wrapper* wrapper = dynamic_cast<QAbstractItemDelegate_Wrapper*>(obj);
          //QAbstractItemDelegate_Wrapper* wrapper = (QAbstractItemDelegate_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractItemDelegate: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAbstractItemDelegate*)wrapper->getWrappedVoid();
          //return getWrapped_QAbstractItemDelegate(wrapper);
          return QAbstractItemDelegate_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractItemDelegate_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractItemDelegate: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAbstractItemDelegate_Type);
          //return fun.call().toInt()==RJSType::QAbstractItemDelegate_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractItemDelegate::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QAbstractItemModel(RJSApi& handler, QAbstractItemModel* v) {
          
            // downcast to QAbstractTableModel:
            {
                QAbstractTableModel* o = qobject_cast<QAbstractTableModel*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QAbstractTableModel(handler, o);
                }
            }
          
            // downcast to QAbstractListModel:
            {
                QAbstractListModel* o = qobject_cast<QAbstractListModel*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QAbstractListModel(handler, o);
                }
            }
          
            // downcast to QFileSystemModel:
            {
                QFileSystemModel* o = qobject_cast<QFileSystemModel*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QFileSystemModel(handler, o);
                }
            }
          
            // downcast to QStandardItemModel:
            {
                QStandardItemModel* o = qobject_cast<QStandardItemModel*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QStandardItemModel(handler, o);
                }
            }
          QAbstractItemModel_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAbstractItemModel_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAbstractItemModel: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAbstractItemModel_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAbstractItemModel_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAbstractItemModel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractItemModel");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractItemModel is undefined. Use QAbstractItemModel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractItemModel('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractItemModel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAbstractItemModel(RJSApi& handler, const QAbstractItemModel* v) {
          return RJSHelper::cpp2js_QAbstractItemModel(handler, const_cast<QAbstractItemModel*>(v));
      }

      QAbstractItemModel* RJSHelper::js2cpp_QAbstractItemModel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractItemModel: not a QObject";
              return nullptr;
          }
          //QAbstractItemModel_Wrapper* wrapper = getWrapper<QAbstractItemModel_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAbstractItemModel_Wrapper* wrapper = qobject_cast<QAbstractItemModel_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractItemModel_Wrapper* wrapper = dynamic_cast<QAbstractItemModel_Wrapper*>(obj);
          //QAbstractItemModel_Wrapper* wrapper = (QAbstractItemModel_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractItemModel: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAbstractItemModel*)wrapper->getWrappedVoid();
          //return getWrapped_QAbstractItemModel(wrapper);
          return QAbstractItemModel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractItemModel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractItemModel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAbstractItemModel_Type);
          //return fun.call().toInt()==RJSType::QAbstractItemModel_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractItemModel::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QAbstractItemView(RJSApi& handler, QAbstractItemView* v) {
          
            // downcast to QHeaderView:
            {
                QHeaderView* o = qobject_cast<QHeaderView*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QHeaderView(handler, o);
                }
            }
          
            // downcast to QListView:
            {
                QListView* o = qobject_cast<QListView*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QListView(handler, o);
                }
            }
          
            // downcast to QTableView:
            {
                QTableView* o = qobject_cast<QTableView*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QTableView(handler, o);
                }
            }
          
            // downcast to QTreeView:
            {
                QTreeView* o = qobject_cast<QTreeView*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QTreeView(handler, o);
                }
            }
          QAbstractItemView_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAbstractItemView_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAbstractItemView: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAbstractItemView_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAbstractItemView_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAbstractItemView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractItemView");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractItemView is undefined. Use QAbstractItemView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractItemView('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractItemView(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAbstractItemView(RJSApi& handler, const QAbstractItemView* v) {
          return RJSHelper::cpp2js_QAbstractItemView(handler, const_cast<QAbstractItemView*>(v));
      }

      QAbstractItemView* RJSHelper::js2cpp_QAbstractItemView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractItemView: not a QObject";
              return nullptr;
          }
          //QAbstractItemView_Wrapper* wrapper = getWrapper<QAbstractItemView_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAbstractItemView_Wrapper* wrapper = qobject_cast<QAbstractItemView_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractItemView_Wrapper* wrapper = dynamic_cast<QAbstractItemView_Wrapper*>(obj);
          //QAbstractItemView_Wrapper* wrapper = (QAbstractItemView_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractItemView: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAbstractItemView*)wrapper->getWrappedVoid();
          //return getWrapped_QAbstractItemView(wrapper);
          return QAbstractItemView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractItemView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractItemView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAbstractItemView_Type);
          //return fun.call().toInt()==RJSType::QAbstractItemView_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractItemView::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QAbstractPrintDialog(RJSApi& handler, QAbstractPrintDialog* v) {
          
            // downcast to QPrintDialog:
            {
                QPrintDialog* o = qobject_cast<QPrintDialog*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPrintDialog(handler, o);
                }
            }
          QAbstractPrintDialog_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAbstractPrintDialog_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAbstractPrintDialog: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAbstractPrintDialog_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAbstractPrintDialog_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAbstractPrintDialog('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractPrintDialog");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractPrintDialog is undefined. Use QAbstractPrintDialog_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractPrintDialog('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractPrintDialog(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAbstractPrintDialog(RJSApi& handler, const QAbstractPrintDialog* v) {
          return RJSHelper::cpp2js_QAbstractPrintDialog(handler, const_cast<QAbstractPrintDialog*>(v));
      }

      QAbstractPrintDialog* RJSHelper::js2cpp_QAbstractPrintDialog_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractPrintDialog: not a QObject";
              return nullptr;
          }
          //QAbstractPrintDialog_Wrapper* wrapper = getWrapper<QAbstractPrintDialog_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAbstractPrintDialog_Wrapper* wrapper = qobject_cast<QAbstractPrintDialog_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractPrintDialog_Wrapper* wrapper = dynamic_cast<QAbstractPrintDialog_Wrapper*>(obj);
          //QAbstractPrintDialog_Wrapper* wrapper = (QAbstractPrintDialog_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractPrintDialog: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAbstractPrintDialog*)wrapper->getWrappedVoid();
          //return getWrapped_QAbstractPrintDialog(wrapper);
          return QAbstractPrintDialog_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractPrintDialog_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractPrintDialog: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAbstractPrintDialog_Type);
          //return fun.call().toInt()==RJSType::QAbstractPrintDialog_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractPrintDialog::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QAbstractScrollArea(RJSApi& handler, QAbstractScrollArea* v) {
          
            // downcast to QAbstractItemView:
            {
                QAbstractItemView* o = qobject_cast<QAbstractItemView*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QAbstractItemView(handler, o);
                }
            }
          
            // downcast to QMdiArea:
            {
                QMdiArea* o = qobject_cast<QMdiArea*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QMdiArea(handler, o);
                }
            }
          
            // downcast to QPlainTextEdit:
            {
                QPlainTextEdit* o = qobject_cast<QPlainTextEdit*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPlainTextEdit(handler, o);
                }
            }
          
            // downcast to QScrollArea:
            {
                QScrollArea* o = qobject_cast<QScrollArea*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QScrollArea(handler, o);
                }
            }
          
            // downcast to QTextEdit:
            {
                QTextEdit* o = qobject_cast<QTextEdit*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QTextEdit(handler, o);
                }
            }
          QAbstractScrollArea_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAbstractScrollArea_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAbstractScrollArea: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAbstractScrollArea_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAbstractScrollArea_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAbstractScrollArea('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractScrollArea");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractScrollArea is undefined. Use QAbstractScrollArea_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractScrollArea('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractScrollArea(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAbstractScrollArea(RJSApi& handler, const QAbstractScrollArea* v) {
          return RJSHelper::cpp2js_QAbstractScrollArea(handler, const_cast<QAbstractScrollArea*>(v));
      }

      QAbstractScrollArea* RJSHelper::js2cpp_QAbstractScrollArea_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractScrollArea: not a QObject";
              return nullptr;
          }
          //QAbstractScrollArea_Wrapper* wrapper = getWrapper<QAbstractScrollArea_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAbstractScrollArea_Wrapper* wrapper = qobject_cast<QAbstractScrollArea_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractScrollArea_Wrapper* wrapper = dynamic_cast<QAbstractScrollArea_Wrapper*>(obj);
          //QAbstractScrollArea_Wrapper* wrapper = (QAbstractScrollArea_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractScrollArea: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAbstractScrollArea*)wrapper->getWrappedVoid();
          //return getWrapped_QAbstractScrollArea(wrapper);
          return QAbstractScrollArea_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractScrollArea_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractScrollArea: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAbstractScrollArea_Type);
          //return fun.call().toInt()==RJSType::QAbstractScrollArea_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractScrollArea::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QAbstractSlider(RJSApi& handler, QAbstractSlider* v) {
          
            // downcast to QScrollBar:
            {
                QScrollBar* o = qobject_cast<QScrollBar*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QScrollBar(handler, o);
                }
            }
          
            // downcast to QSlider:
            {
                QSlider* o = qobject_cast<QSlider*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QSlider(handler, o);
                }
            }
          QAbstractSlider_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAbstractSlider_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAbstractSlider: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAbstractSlider_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAbstractSlider_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAbstractSlider('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractSlider");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractSlider is undefined. Use QAbstractSlider_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractSlider('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractSlider(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAbstractSlider(RJSApi& handler, const QAbstractSlider* v) {
          return RJSHelper::cpp2js_QAbstractSlider(handler, const_cast<QAbstractSlider*>(v));
      }

      QAbstractSlider* RJSHelper::js2cpp_QAbstractSlider_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractSlider: not a QObject";
              return nullptr;
          }
          //QAbstractSlider_Wrapper* wrapper = getWrapper<QAbstractSlider_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAbstractSlider_Wrapper* wrapper = qobject_cast<QAbstractSlider_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractSlider_Wrapper* wrapper = dynamic_cast<QAbstractSlider_Wrapper*>(obj);
          //QAbstractSlider_Wrapper* wrapper = (QAbstractSlider_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractSlider: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAbstractSlider*)wrapper->getWrappedVoid();
          //return getWrapped_QAbstractSlider(wrapper);
          return QAbstractSlider_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractSlider_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractSlider: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAbstractSlider_Type);
          //return fun.call().toInt()==RJSType::QAbstractSlider_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractSlider::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QAction(RJSApi& handler, QAction* v) {
          
            // downcast to QWidgetAction:
            {
                QWidgetAction* o = qobject_cast<QWidgetAction*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QWidgetAction(handler, o);
                }
            }
          
            // downcast to types derrived from QAction but defined in other modules:
            for (int i=0; i<downcasters_QAction.length(); i++) {
                QJSValue dc = downcasters_QAction[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QAction_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAction_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAction: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAction_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAction_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAction");
          if (cl.isUndefined()) {
              qWarning() << "Class QAction is undefined. Use QAction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAction('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAction(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAction(RJSApi& handler, const QAction* v) {
          return RJSHelper::cpp2js_QAction(handler, const_cast<QAction*>(v));
      }

      QAction* RJSHelper::js2cpp_QAction_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAction: not a QObject";
              return nullptr;
          }
          //QAction_Wrapper* wrapper = getWrapper<QAction_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAction_Wrapper* wrapper = qobject_cast<QAction_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAction_Wrapper* wrapper = dynamic_cast<QAction_Wrapper*>(obj);
          //QAction_Wrapper* wrapper = (QAction_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAction: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAction*)wrapper->getWrappedVoid();
          //return getWrapped_QAction(wrapper);
          return QAction_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAction_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAction: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAction_Type);
          //return fun.call().toInt()==RJSType::QAction_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAction::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QActionGroup(RJSApi& handler, QActionGroup* v) {
          QActionGroup_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QActionGroup_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QActionGroup: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QActionGroup_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QActionGroup_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QActionGroup('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QActionGroup");
          if (cl.isUndefined()) {
              qWarning() << "Class QActionGroup is undefined. Use QActionGroup_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QActionGroup('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QActionGroup(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QActionGroup(RJSApi& handler, const QActionGroup* v) {
          return RJSHelper::cpp2js_QActionGroup(handler, const_cast<QActionGroup*>(v));
      }

      QActionGroup* RJSHelper::js2cpp_QActionGroup_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QActionGroup: not a QObject";
              return nullptr;
          }
          //QActionGroup_Wrapper* wrapper = getWrapper<QActionGroup_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QActionGroup_Wrapper* wrapper = qobject_cast<QActionGroup_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QActionGroup_Wrapper* wrapper = dynamic_cast<QActionGroup_Wrapper*>(obj);
          //QActionGroup_Wrapper* wrapper = (QActionGroup_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QActionGroup: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QActionGroup*)wrapper->getWrappedVoid();
          //return getWrapped_QActionGroup(wrapper);
          return QActionGroup_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QActionGroup_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QActionGroup: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QActionGroup_Type);
          //return fun.call().toInt()==RJSType::QActionGroup_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QActionGroup::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QApplication(RJSApi& handler, QApplication* v) {
          
            // downcast to types derrived from QApplication but defined in other modules:
            for (int i=0; i<downcasters_QApplication.length(); i++) {
                QJSValue dc = downcasters_QApplication[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QApplication_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QApplication_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QApplication: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QApplication_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QApplication_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QApplication('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QApplication");
          if (cl.isUndefined()) {
              qWarning() << "Class QApplication is undefined. Use QApplication_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QApplication('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QApplication(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QApplication(RJSApi& handler, const QApplication* v) {
          return RJSHelper::cpp2js_QApplication(handler, const_cast<QApplication*>(v));
      }

      QApplication* RJSHelper::js2cpp_QApplication_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QApplication: not a QObject";
              return nullptr;
          }
          //QApplication_Wrapper* wrapper = getWrapper<QApplication_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QApplication_Wrapper* wrapper = qobject_cast<QApplication_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QApplication_Wrapper* wrapper = dynamic_cast<QApplication_Wrapper*>(obj);
          //QApplication_Wrapper* wrapper = (QApplication_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QApplication: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QApplication*)wrapper->getWrappedVoid();
          //return getWrapped_QApplication(wrapper);
          return QApplication_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QApplication_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QApplication: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QApplication_Type);
          //return fun.call().toInt()==RJSType::QApplication_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QApplication::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QBoxLayout(RJSApi& handler, QBoxLayout* v) {
          
            // downcast to QHBoxLayout:
            {
                QHBoxLayout* o = qobject_cast<QHBoxLayout*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QHBoxLayout(handler, o);
                }
            }
          
            // downcast to QVBoxLayout:
            {
                QVBoxLayout* o = qobject_cast<QVBoxLayout*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QVBoxLayout(handler, o);
                }
            }
          QBoxLayout_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QBoxLayout_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QBoxLayout: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QBoxLayout_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QBoxLayout_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QBoxLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QBoxLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QBoxLayout is undefined. Use QBoxLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QBoxLayout('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QBoxLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QBoxLayout(RJSApi& handler, const QBoxLayout* v) {
          return RJSHelper::cpp2js_QBoxLayout(handler, const_cast<QBoxLayout*>(v));
      }

      QBoxLayout* RJSHelper::js2cpp_QBoxLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QBoxLayout: not a QObject";
              return nullptr;
          }
          //QBoxLayout_Wrapper* wrapper = getWrapper<QBoxLayout_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QBoxLayout_Wrapper* wrapper = qobject_cast<QBoxLayout_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QBoxLayout_Wrapper* wrapper = dynamic_cast<QBoxLayout_Wrapper*>(obj);
          //QBoxLayout_Wrapper* wrapper = (QBoxLayout_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QBoxLayout: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QBoxLayout*)wrapper->getWrappedVoid();
          //return getWrapped_QBoxLayout(wrapper);
          return QBoxLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QBoxLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QBoxLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QBoxLayout_Type);
          //return fun.call().toInt()==RJSType::QBoxLayout_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QBoxLayout::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QBuffer(RJSApi& handler, QBuffer* v) {
          QBuffer_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QBuffer_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QBuffer: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QBuffer_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QBuffer_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QBuffer('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QBuffer");
          if (cl.isUndefined()) {
              qWarning() << "Class QBuffer is undefined. Use QBuffer_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QBuffer('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QBuffer(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QBuffer(RJSApi& handler, const QBuffer* v) {
          return RJSHelper::cpp2js_QBuffer(handler, const_cast<QBuffer*>(v));
      }

      QBuffer* RJSHelper::js2cpp_QBuffer_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QBuffer: not a QObject";
              return nullptr;
          }
          //QBuffer_Wrapper* wrapper = getWrapper<QBuffer_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QBuffer_Wrapper* wrapper = qobject_cast<QBuffer_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QBuffer_Wrapper* wrapper = dynamic_cast<QBuffer_Wrapper*>(obj);
          //QBuffer_Wrapper* wrapper = (QBuffer_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QBuffer: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QBuffer*)wrapper->getWrappedVoid();
          //return getWrapped_QBuffer(wrapper);
          return QBuffer_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QBuffer_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QBuffer: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QBuffer_Type);
          //return fun.call().toInt()==RJSType::QBuffer_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QBuffer::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QButtonGroup(RJSApi& handler, QButtonGroup* v) {
          QButtonGroup_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QButtonGroup_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QButtonGroup: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QButtonGroup_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QButtonGroup_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QButtonGroup('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QButtonGroup");
          if (cl.isUndefined()) {
              qWarning() << "Class QButtonGroup is undefined. Use QButtonGroup_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QButtonGroup('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QButtonGroup(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QButtonGroup(RJSApi& handler, const QButtonGroup* v) {
          return RJSHelper::cpp2js_QButtonGroup(handler, const_cast<QButtonGroup*>(v));
      }

      QButtonGroup* RJSHelper::js2cpp_QButtonGroup_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QButtonGroup: not a QObject";
              return nullptr;
          }
          //QButtonGroup_Wrapper* wrapper = getWrapper<QButtonGroup_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QButtonGroup_Wrapper* wrapper = qobject_cast<QButtonGroup_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QButtonGroup_Wrapper* wrapper = dynamic_cast<QButtonGroup_Wrapper*>(obj);
          //QButtonGroup_Wrapper* wrapper = (QButtonGroup_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QButtonGroup: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QButtonGroup*)wrapper->getWrappedVoid();
          //return getWrapped_QButtonGroup(wrapper);
          return QButtonGroup_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QButtonGroup_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QButtonGroup: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QButtonGroup_Type);
          //return fun.call().toInt()==RJSType::QButtonGroup_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QButtonGroup::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QCheckBox(RJSApi& handler, QCheckBox* v) {
          QCheckBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QCheckBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QCheckBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QCheckBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QCheckBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QCheckBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QCheckBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QCheckBox is undefined. Use QCheckBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QCheckBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QCheckBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QCheckBox(RJSApi& handler, const QCheckBox* v) {
          return RJSHelper::cpp2js_QCheckBox(handler, const_cast<QCheckBox*>(v));
      }

      QCheckBox* RJSHelper::js2cpp_QCheckBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QCheckBox: not a QObject";
              return nullptr;
          }
          //QCheckBox_Wrapper* wrapper = getWrapper<QCheckBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QCheckBox_Wrapper* wrapper = qobject_cast<QCheckBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QCheckBox_Wrapper* wrapper = dynamic_cast<QCheckBox_Wrapper*>(obj);
          //QCheckBox_Wrapper* wrapper = (QCheckBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QCheckBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QCheckBox*)wrapper->getWrappedVoid();
          //return getWrapped_QCheckBox(wrapper);
          return QCheckBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QCheckBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QCheckBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QCheckBox_Type);
          //return fun.call().toInt()==RJSType::QCheckBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QCheckBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QClipboard(RJSApi& handler, QClipboard* v) {
          QClipboard_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QClipboard_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QClipboard: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QClipboard_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QClipboard_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QClipboard('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QClipboard");
          if (cl.isUndefined()) {
              qWarning() << "Class QClipboard is undefined. Use QClipboard_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QClipboard('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QClipboard(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QClipboard(RJSApi& handler, const QClipboard* v) {
          return RJSHelper::cpp2js_QClipboard(handler, const_cast<QClipboard*>(v));
      }

      QClipboard* RJSHelper::js2cpp_QClipboard_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QClipboard: not a QObject";
              return nullptr;
          }
          //QClipboard_Wrapper* wrapper = getWrapper<QClipboard_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QClipboard_Wrapper* wrapper = qobject_cast<QClipboard_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QClipboard_Wrapper* wrapper = dynamic_cast<QClipboard_Wrapper*>(obj);
          //QClipboard_Wrapper* wrapper = (QClipboard_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QClipboard: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QClipboard*)wrapper->getWrappedVoid();
          //return getWrapped_QClipboard(wrapper);
          return QClipboard_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QClipboard_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QClipboard: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QClipboard_Type);
          //return fun.call().toInt()==RJSType::QClipboard_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QClipboard::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QColorDialog(RJSApi& handler, QColorDialog* v) {
          QColorDialog_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QColorDialog_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QColorDialog: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QColorDialog_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QColorDialog_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QColorDialog('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QColorDialog");
          if (cl.isUndefined()) {
              qWarning() << "Class QColorDialog is undefined. Use QColorDialog_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QColorDialog('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QColorDialog(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QColorDialog(RJSApi& handler, const QColorDialog* v) {
          return RJSHelper::cpp2js_QColorDialog(handler, const_cast<QColorDialog*>(v));
      }

      QColorDialog* RJSHelper::js2cpp_QColorDialog_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QColorDialog: not a QObject";
              return nullptr;
          }
          //QColorDialog_Wrapper* wrapper = getWrapper<QColorDialog_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QColorDialog_Wrapper* wrapper = qobject_cast<QColorDialog_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QColorDialog_Wrapper* wrapper = dynamic_cast<QColorDialog_Wrapper*>(obj);
          //QColorDialog_Wrapper* wrapper = (QColorDialog_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QColorDialog: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QColorDialog*)wrapper->getWrappedVoid();
          //return getWrapped_QColorDialog(wrapper);
          return QColorDialog_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QColorDialog_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QColorDialog: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QColorDialog_Type);
          //return fun.call().toInt()==RJSType::QColorDialog_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QColorDialog::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QComboBox(RJSApi& handler, QComboBox* v) {
          
            // downcast to QFontComboBox:
            {
                QFontComboBox* o = qobject_cast<QFontComboBox*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QFontComboBox(handler, o);
                }
            }
          
            // downcast to types derrived from QComboBox but defined in other modules:
            for (int i=0; i<downcasters_QComboBox.length(); i++) {
                QJSValue dc = downcasters_QComboBox[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QComboBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QComboBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QComboBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QComboBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QComboBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QComboBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QComboBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QComboBox is undefined. Use QComboBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QComboBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QComboBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QComboBox(RJSApi& handler, const QComboBox* v) {
          return RJSHelper::cpp2js_QComboBox(handler, const_cast<QComboBox*>(v));
      }

      QComboBox* RJSHelper::js2cpp_QComboBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QComboBox: not a QObject";
              return nullptr;
          }
          //QComboBox_Wrapper* wrapper = getWrapper<QComboBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QComboBox_Wrapper* wrapper = qobject_cast<QComboBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QComboBox_Wrapper* wrapper = dynamic_cast<QComboBox_Wrapper*>(obj);
          //QComboBox_Wrapper* wrapper = (QComboBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QComboBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QComboBox*)wrapper->getWrappedVoid();
          //return getWrapped_QComboBox(wrapper);
          return QComboBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QComboBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QComboBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QComboBox_Type);
          //return fun.call().toInt()==RJSType::QComboBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QComboBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QCoreApplication(RJSApi& handler, QCoreApplication* v) {
          
            // downcast to QGuiApplication:
            {
                QGuiApplication* o = qobject_cast<QGuiApplication*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QGuiApplication(handler, o);
                }
            }
          QCoreApplication_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QCoreApplication_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QCoreApplication: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QCoreApplication_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QCoreApplication_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QCoreApplication('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QCoreApplication");
          if (cl.isUndefined()) {
              qWarning() << "Class QCoreApplication is undefined. Use QCoreApplication_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QCoreApplication('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QCoreApplication(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QCoreApplication(RJSApi& handler, const QCoreApplication* v) {
          return RJSHelper::cpp2js_QCoreApplication(handler, const_cast<QCoreApplication*>(v));
      }

      QCoreApplication* RJSHelper::js2cpp_QCoreApplication_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QCoreApplication: not a QObject";
              return nullptr;
          }
          //QCoreApplication_Wrapper* wrapper = getWrapper<QCoreApplication_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QCoreApplication_Wrapper* wrapper = qobject_cast<QCoreApplication_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QCoreApplication_Wrapper* wrapper = dynamic_cast<QCoreApplication_Wrapper*>(obj);
          //QCoreApplication_Wrapper* wrapper = (QCoreApplication_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QCoreApplication: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QCoreApplication*)wrapper->getWrappedVoid();
          //return getWrapped_QCoreApplication(wrapper);
          return QCoreApplication_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QCoreApplication_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QCoreApplication: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QCoreApplication_Type);
          //return fun.call().toInt()==RJSType::QCoreApplication_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QCoreApplication::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QDialog(RJSApi& handler, QDialog* v) {
          
            // downcast to QAbstractPrintDialog:
            {
                QAbstractPrintDialog* o = qobject_cast<QAbstractPrintDialog*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QAbstractPrintDialog(handler, o);
                }
            }
          
            // downcast to QColorDialog:
            {
                QColorDialog* o = qobject_cast<QColorDialog*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QColorDialog(handler, o);
                }
            }
          
            // downcast to QFileDialog:
            {
                QFileDialog* o = qobject_cast<QFileDialog*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QFileDialog(handler, o);
                }
            }
          
            // downcast to QMessageBox:
            {
                QMessageBox* o = qobject_cast<QMessageBox*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QMessageBox(handler, o);
                }
            }
          
            // downcast to QProgressDialog:
            {
                QProgressDialog* o = qobject_cast<QProgressDialog*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QProgressDialog(handler, o);
                }
            }
          QDialog_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QDialog_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QDialog: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QDialog_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QDialog_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QDialog('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDialog");
          if (cl.isUndefined()) {
              qWarning() << "Class QDialog is undefined. Use QDialog_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDialog('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDialog(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDialog(RJSApi& handler, const QDialog* v) {
          return RJSHelper::cpp2js_QDialog(handler, const_cast<QDialog*>(v));
      }

      QDialog* RJSHelper::js2cpp_QDialog_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDialog: not a QObject";
              return nullptr;
          }
          //QDialog_Wrapper* wrapper = getWrapper<QDialog_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QDialog_Wrapper* wrapper = qobject_cast<QDialog_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDialog_Wrapper* wrapper = dynamic_cast<QDialog_Wrapper*>(obj);
          //QDialog_Wrapper* wrapper = (QDialog_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDialog: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QDialog*)wrapper->getWrappedVoid();
          //return getWrapped_QDialog(wrapper);
          return QDialog_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDialog_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDialog: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QDialog_Type);
          //return fun.call().toInt()==RJSType::QDialog_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QDialog::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QDialogButtonBox(RJSApi& handler, QDialogButtonBox* v) {
          QDialogButtonBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QDialogButtonBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QDialogButtonBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QDialogButtonBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QDialogButtonBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QDialogButtonBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDialogButtonBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QDialogButtonBox is undefined. Use QDialogButtonBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDialogButtonBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDialogButtonBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDialogButtonBox(RJSApi& handler, const QDialogButtonBox* v) {
          return RJSHelper::cpp2js_QDialogButtonBox(handler, const_cast<QDialogButtonBox*>(v));
      }

      QDialogButtonBox* RJSHelper::js2cpp_QDialogButtonBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDialogButtonBox: not a QObject";
              return nullptr;
          }
          //QDialogButtonBox_Wrapper* wrapper = getWrapper<QDialogButtonBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QDialogButtonBox_Wrapper* wrapper = qobject_cast<QDialogButtonBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDialogButtonBox_Wrapper* wrapper = dynamic_cast<QDialogButtonBox_Wrapper*>(obj);
          //QDialogButtonBox_Wrapper* wrapper = (QDialogButtonBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDialogButtonBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QDialogButtonBox*)wrapper->getWrappedVoid();
          //return getWrapped_QDialogButtonBox(wrapper);
          return QDialogButtonBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDialogButtonBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDialogButtonBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QDialogButtonBox_Type);
          //return fun.call().toInt()==RJSType::QDialogButtonBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QDialogButtonBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QDockWidget(RJSApi& handler, QDockWidget* v) {
          
            // downcast to types derrived from QDockWidget but defined in other modules:
            for (int i=0; i<downcasters_QDockWidget.length(); i++) {
                QJSValue dc = downcasters_QDockWidget[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QDockWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QDockWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QDockWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QDockWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QDockWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QDockWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDockWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class QDockWidget is undefined. Use QDockWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDockWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDockWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDockWidget(RJSApi& handler, const QDockWidget* v) {
          return RJSHelper::cpp2js_QDockWidget(handler, const_cast<QDockWidget*>(v));
      }

      QDockWidget* RJSHelper::js2cpp_QDockWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDockWidget: not a QObject";
              return nullptr;
          }
          //QDockWidget_Wrapper* wrapper = getWrapper<QDockWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QDockWidget_Wrapper* wrapper = qobject_cast<QDockWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDockWidget_Wrapper* wrapper = dynamic_cast<QDockWidget_Wrapper*>(obj);
          //QDockWidget_Wrapper* wrapper = (QDockWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDockWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QDockWidget*)wrapper->getWrappedVoid();
          //return getWrapped_QDockWidget(wrapper);
          return QDockWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDockWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDockWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QDockWidget_Type);
          //return fun.call().toInt()==RJSType::QDockWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QDockWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QDoubleSpinBox(RJSApi& handler, QDoubleSpinBox* v) {
          QDoubleSpinBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QDoubleSpinBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QDoubleSpinBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QDoubleSpinBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QDoubleSpinBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QDoubleSpinBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDoubleSpinBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QDoubleSpinBox is undefined. Use QDoubleSpinBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDoubleSpinBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDoubleSpinBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDoubleSpinBox(RJSApi& handler, const QDoubleSpinBox* v) {
          return RJSHelper::cpp2js_QDoubleSpinBox(handler, const_cast<QDoubleSpinBox*>(v));
      }

      QDoubleSpinBox* RJSHelper::js2cpp_QDoubleSpinBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDoubleSpinBox: not a QObject";
              return nullptr;
          }
          //QDoubleSpinBox_Wrapper* wrapper = getWrapper<QDoubleSpinBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QDoubleSpinBox_Wrapper* wrapper = qobject_cast<QDoubleSpinBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDoubleSpinBox_Wrapper* wrapper = dynamic_cast<QDoubleSpinBox_Wrapper*>(obj);
          //QDoubleSpinBox_Wrapper* wrapper = (QDoubleSpinBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDoubleSpinBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QDoubleSpinBox*)wrapper->getWrappedVoid();
          //return getWrapped_QDoubleSpinBox(wrapper);
          return QDoubleSpinBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDoubleSpinBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDoubleSpinBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QDoubleSpinBox_Type);
          //return fun.call().toInt()==RJSType::QDoubleSpinBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QDoubleSpinBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QDoubleValidator(RJSApi& handler, QDoubleValidator* v) {
          QDoubleValidator_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QDoubleValidator_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QDoubleValidator: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QDoubleValidator_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QDoubleValidator_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QDoubleValidator('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDoubleValidator");
          if (cl.isUndefined()) {
              qWarning() << "Class QDoubleValidator is undefined. Use QDoubleValidator_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDoubleValidator('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDoubleValidator(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDoubleValidator(RJSApi& handler, const QDoubleValidator* v) {
          return RJSHelper::cpp2js_QDoubleValidator(handler, const_cast<QDoubleValidator*>(v));
      }

      QDoubleValidator* RJSHelper::js2cpp_QDoubleValidator_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDoubleValidator: not a QObject";
              return nullptr;
          }
          //QDoubleValidator_Wrapper* wrapper = getWrapper<QDoubleValidator_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QDoubleValidator_Wrapper* wrapper = qobject_cast<QDoubleValidator_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDoubleValidator_Wrapper* wrapper = dynamic_cast<QDoubleValidator_Wrapper*>(obj);
          //QDoubleValidator_Wrapper* wrapper = (QDoubleValidator_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDoubleValidator: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QDoubleValidator*)wrapper->getWrappedVoid();
          //return getWrapped_QDoubleValidator(wrapper);
          return QDoubleValidator_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDoubleValidator_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDoubleValidator: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QDoubleValidator_Type);
          //return fun.call().toInt()==RJSType::QDoubleValidator_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QDoubleValidator::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QDrag(RJSApi& handler, QDrag* v) {
          QDrag_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QDrag_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QDrag: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QDrag_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QDrag_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QDrag('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDrag");
          if (cl.isUndefined()) {
              qWarning() << "Class QDrag is undefined. Use QDrag_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDrag('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDrag(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDrag(RJSApi& handler, const QDrag* v) {
          return RJSHelper::cpp2js_QDrag(handler, const_cast<QDrag*>(v));
      }

      QDrag* RJSHelper::js2cpp_QDrag_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDrag: not a QObject";
              return nullptr;
          }
          //QDrag_Wrapper* wrapper = getWrapper<QDrag_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QDrag_Wrapper* wrapper = qobject_cast<QDrag_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDrag_Wrapper* wrapper = dynamic_cast<QDrag_Wrapper*>(obj);
          //QDrag_Wrapper* wrapper = (QDrag_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDrag: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QDrag*)wrapper->getWrappedVoid();
          //return getWrapped_QDrag(wrapper);
          return QDrag_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDrag_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDrag: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QDrag_Type);
          //return fun.call().toInt()==RJSType::QDrag_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QDrag::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QEventLoop(RJSApi& handler, QEventLoop* v) {
          QEventLoop_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QEventLoop_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QEventLoop: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QEventLoop_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QEventLoop_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QEventLoop('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QEventLoop");
          if (cl.isUndefined()) {
              qWarning() << "Class QEventLoop is undefined. Use QEventLoop_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QEventLoop('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QEventLoop(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QEventLoop(RJSApi& handler, const QEventLoop* v) {
          return RJSHelper::cpp2js_QEventLoop(handler, const_cast<QEventLoop*>(v));
      }

      QEventLoop* RJSHelper::js2cpp_QEventLoop_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QEventLoop: not a QObject";
              return nullptr;
          }
          //QEventLoop_Wrapper* wrapper = getWrapper<QEventLoop_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QEventLoop_Wrapper* wrapper = qobject_cast<QEventLoop_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QEventLoop_Wrapper* wrapper = dynamic_cast<QEventLoop_Wrapper*>(obj);
          //QEventLoop_Wrapper* wrapper = (QEventLoop_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QEventLoop: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QEventLoop*)wrapper->getWrappedVoid();
          //return getWrapped_QEventLoop(wrapper);
          return QEventLoop_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QEventLoop_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QEventLoop: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QEventLoop_Type);
          //return fun.call().toInt()==RJSType::QEventLoop_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QEventLoop::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QFile(RJSApi& handler, QFile* v) {
          QFile_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QFile_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QFile: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QFile_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QFile_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QFile('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFile");
          if (cl.isUndefined()) {
              qWarning() << "Class QFile is undefined. Use QFile_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFile('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFile(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFile(RJSApi& handler, const QFile* v) {
          return RJSHelper::cpp2js_QFile(handler, const_cast<QFile*>(v));
      }

      QFile* RJSHelper::js2cpp_QFile_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFile: not a QObject";
              return nullptr;
          }
          //QFile_Wrapper* wrapper = getWrapper<QFile_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QFile_Wrapper* wrapper = qobject_cast<QFile_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFile_Wrapper* wrapper = dynamic_cast<QFile_Wrapper*>(obj);
          //QFile_Wrapper* wrapper = (QFile_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFile: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QFile*)wrapper->getWrappedVoid();
          //return getWrapped_QFile(wrapper);
          return QFile_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFile_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFile: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QFile_Type);
          //return fun.call().toInt()==RJSType::QFile_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QFile::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QFileDevice(RJSApi& handler, QFileDevice* v) {
          QFileDevice_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QFileDevice_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QFileDevice: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QFileDevice_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QFileDevice_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QFileDevice('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFileDevice");
          if (cl.isUndefined()) {
              qWarning() << "Class QFileDevice is undefined. Use QFileDevice_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFileDevice('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFileDevice(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFileDevice(RJSApi& handler, const QFileDevice* v) {
          return RJSHelper::cpp2js_QFileDevice(handler, const_cast<QFileDevice*>(v));
      }

      QFileDevice* RJSHelper::js2cpp_QFileDevice_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFileDevice: not a QObject";
              return nullptr;
          }
          //QFileDevice_Wrapper* wrapper = getWrapper<QFileDevice_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QFileDevice_Wrapper* wrapper = qobject_cast<QFileDevice_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFileDevice_Wrapper* wrapper = dynamic_cast<QFileDevice_Wrapper*>(obj);
          //QFileDevice_Wrapper* wrapper = (QFileDevice_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFileDevice: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QFileDevice*)wrapper->getWrappedVoid();
          //return getWrapped_QFileDevice(wrapper);
          return QFileDevice_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFileDevice_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFileDevice: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QFileDevice_Type);
          //return fun.call().toInt()==RJSType::QFileDevice_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QFileDevice::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QFileDialog(RJSApi& handler, QFileDialog* v) {
          QFileDialog_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QFileDialog_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QFileDialog: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QFileDialog_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QFileDialog_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QFileDialog('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFileDialog");
          if (cl.isUndefined()) {
              qWarning() << "Class QFileDialog is undefined. Use QFileDialog_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFileDialog('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFileDialog(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFileDialog(RJSApi& handler, const QFileDialog* v) {
          return RJSHelper::cpp2js_QFileDialog(handler, const_cast<QFileDialog*>(v));
      }

      QFileDialog* RJSHelper::js2cpp_QFileDialog_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFileDialog: not a QObject";
              return nullptr;
          }
          //QFileDialog_Wrapper* wrapper = getWrapper<QFileDialog_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QFileDialog_Wrapper* wrapper = qobject_cast<QFileDialog_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFileDialog_Wrapper* wrapper = dynamic_cast<QFileDialog_Wrapper*>(obj);
          //QFileDialog_Wrapper* wrapper = (QFileDialog_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFileDialog: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QFileDialog*)wrapper->getWrappedVoid();
          //return getWrapped_QFileDialog(wrapper);
          return QFileDialog_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFileDialog_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFileDialog: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QFileDialog_Type);
          //return fun.call().toInt()==RJSType::QFileDialog_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QFileDialog::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QFileSystemModel(RJSApi& handler, QFileSystemModel* v) {
          
            // downcast to types derrived from QFileSystemModel but defined in other modules:
            for (int i=0; i<downcasters_QFileSystemModel.length(); i++) {
                QJSValue dc = downcasters_QFileSystemModel[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QFileSystemModel_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QFileSystemModel_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QFileSystemModel: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QFileSystemModel_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QFileSystemModel_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QFileSystemModel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFileSystemModel");
          if (cl.isUndefined()) {
              qWarning() << "Class QFileSystemModel is undefined. Use QFileSystemModel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFileSystemModel('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFileSystemModel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFileSystemModel(RJSApi& handler, const QFileSystemModel* v) {
          return RJSHelper::cpp2js_QFileSystemModel(handler, const_cast<QFileSystemModel*>(v));
      }

      QFileSystemModel* RJSHelper::js2cpp_QFileSystemModel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFileSystemModel: not a QObject";
              return nullptr;
          }
          //QFileSystemModel_Wrapper* wrapper = getWrapper<QFileSystemModel_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QFileSystemModel_Wrapper* wrapper = qobject_cast<QFileSystemModel_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFileSystemModel_Wrapper* wrapper = dynamic_cast<QFileSystemModel_Wrapper*>(obj);
          //QFileSystemModel_Wrapper* wrapper = (QFileSystemModel_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFileSystemModel: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QFileSystemModel*)wrapper->getWrappedVoid();
          //return getWrapped_QFileSystemModel(wrapper);
          return QFileSystemModel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFileSystemModel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFileSystemModel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QFileSystemModel_Type);
          //return fun.call().toInt()==RJSType::QFileSystemModel_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QFileSystemModel::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QFileSystemWatcher(RJSApi& handler, QFileSystemWatcher* v) {
          QFileSystemWatcher_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QFileSystemWatcher_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QFileSystemWatcher: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QFileSystemWatcher_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QFileSystemWatcher_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QFileSystemWatcher('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFileSystemWatcher");
          if (cl.isUndefined()) {
              qWarning() << "Class QFileSystemWatcher is undefined. Use QFileSystemWatcher_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFileSystemWatcher('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFileSystemWatcher(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFileSystemWatcher(RJSApi& handler, const QFileSystemWatcher* v) {
          return RJSHelper::cpp2js_QFileSystemWatcher(handler, const_cast<QFileSystemWatcher*>(v));
      }

      QFileSystemWatcher* RJSHelper::js2cpp_QFileSystemWatcher_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFileSystemWatcher: not a QObject";
              return nullptr;
          }
          //QFileSystemWatcher_Wrapper* wrapper = getWrapper<QFileSystemWatcher_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QFileSystemWatcher_Wrapper* wrapper = qobject_cast<QFileSystemWatcher_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFileSystemWatcher_Wrapper* wrapper = dynamic_cast<QFileSystemWatcher_Wrapper*>(obj);
          //QFileSystemWatcher_Wrapper* wrapper = (QFileSystemWatcher_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFileSystemWatcher: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QFileSystemWatcher*)wrapper->getWrappedVoid();
          //return getWrapped_QFileSystemWatcher(wrapper);
          return QFileSystemWatcher_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFileSystemWatcher_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFileSystemWatcher: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QFileSystemWatcher_Type);
          //return fun.call().toInt()==RJSType::QFileSystemWatcher_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QFileSystemWatcher::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QFontComboBox(RJSApi& handler, QFontComboBox* v) {
          QFontComboBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QFontComboBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QFontComboBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QFontComboBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QFontComboBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QFontComboBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFontComboBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QFontComboBox is undefined. Use QFontComboBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFontComboBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFontComboBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFontComboBox(RJSApi& handler, const QFontComboBox* v) {
          return RJSHelper::cpp2js_QFontComboBox(handler, const_cast<QFontComboBox*>(v));
      }

      QFontComboBox* RJSHelper::js2cpp_QFontComboBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFontComboBox: not a QObject";
              return nullptr;
          }
          //QFontComboBox_Wrapper* wrapper = getWrapper<QFontComboBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QFontComboBox_Wrapper* wrapper = qobject_cast<QFontComboBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFontComboBox_Wrapper* wrapper = dynamic_cast<QFontComboBox_Wrapper*>(obj);
          //QFontComboBox_Wrapper* wrapper = (QFontComboBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFontComboBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QFontComboBox*)wrapper->getWrappedVoid();
          //return getWrapped_QFontComboBox(wrapper);
          return QFontComboBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFontComboBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFontComboBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QFontComboBox_Type);
          //return fun.call().toInt()==RJSType::QFontComboBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QFontComboBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QFormLayout(RJSApi& handler, QFormLayout* v) {
          QFormLayout_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QFormLayout_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QFormLayout: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QFormLayout_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QFormLayout_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QFormLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFormLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QFormLayout is undefined. Use QFormLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFormLayout('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFormLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFormLayout(RJSApi& handler, const QFormLayout* v) {
          return RJSHelper::cpp2js_QFormLayout(handler, const_cast<QFormLayout*>(v));
      }

      QFormLayout* RJSHelper::js2cpp_QFormLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFormLayout: not a QObject";
              return nullptr;
          }
          //QFormLayout_Wrapper* wrapper = getWrapper<QFormLayout_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QFormLayout_Wrapper* wrapper = qobject_cast<QFormLayout_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFormLayout_Wrapper* wrapper = dynamic_cast<QFormLayout_Wrapper*>(obj);
          //QFormLayout_Wrapper* wrapper = (QFormLayout_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFormLayout: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QFormLayout*)wrapper->getWrappedVoid();
          //return getWrapped_QFormLayout(wrapper);
          return QFormLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFormLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFormLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QFormLayout_Type);
          //return fun.call().toInt()==RJSType::QFormLayout_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QFormLayout::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QFrame(RJSApi& handler, QFrame* v) {
          
            // downcast to QAbstractScrollArea:
            {
                QAbstractScrollArea* o = qobject_cast<QAbstractScrollArea*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QAbstractScrollArea(handler, o);
                }
            }
          
            // downcast to QLabel:
            {
                QLabel* o = qobject_cast<QLabel*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QLabel(handler, o);
                }
            }
          
            // downcast to QSplitter:
            {
                QSplitter* o = qobject_cast<QSplitter*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QSplitter(handler, o);
                }
            }
          
            // downcast to QStackedWidget:
            {
                QStackedWidget* o = qobject_cast<QStackedWidget*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QStackedWidget(handler, o);
                }
            }
          
            // downcast to types derrived from QFrame but defined in other modules:
            for (int i=0; i<downcasters_QFrame.length(); i++) {
                QJSValue dc = downcasters_QFrame[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QFrame_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QFrame_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QFrame: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QFrame_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QFrame_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QFrame('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFrame");
          if (cl.isUndefined()) {
              qWarning() << "Class QFrame is undefined. Use QFrame_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFrame('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFrame(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFrame(RJSApi& handler, const QFrame* v) {
          return RJSHelper::cpp2js_QFrame(handler, const_cast<QFrame*>(v));
      }

      QFrame* RJSHelper::js2cpp_QFrame_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFrame: not a QObject";
              return nullptr;
          }
          //QFrame_Wrapper* wrapper = getWrapper<QFrame_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QFrame_Wrapper* wrapper = qobject_cast<QFrame_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFrame_Wrapper* wrapper = dynamic_cast<QFrame_Wrapper*>(obj);
          //QFrame_Wrapper* wrapper = (QFrame_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFrame: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QFrame*)wrapper->getWrappedVoid();
          //return getWrapped_QFrame(wrapper);
          return QFrame_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFrame_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFrame: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QFrame_Type);
          //return fun.call().toInt()==RJSType::QFrame_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QFrame::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QGraphicsBlurEffect(RJSApi& handler, QGraphicsBlurEffect* v) {
          QGraphicsBlurEffect_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QGraphicsBlurEffect_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QGraphicsBlurEffect: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QGraphicsBlurEffect_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QGraphicsBlurEffect_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QGraphicsBlurEffect('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGraphicsBlurEffect");
          if (cl.isUndefined()) {
              qWarning() << "Class QGraphicsBlurEffect is undefined. Use QGraphicsBlurEffect_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGraphicsBlurEffect('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGraphicsBlurEffect(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGraphicsBlurEffect(RJSApi& handler, const QGraphicsBlurEffect* v) {
          return RJSHelper::cpp2js_QGraphicsBlurEffect(handler, const_cast<QGraphicsBlurEffect*>(v));
      }

      QGraphicsBlurEffect* RJSHelper::js2cpp_QGraphicsBlurEffect_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGraphicsBlurEffect: not a QObject";
              return nullptr;
          }
          //QGraphicsBlurEffect_Wrapper* wrapper = getWrapper<QGraphicsBlurEffect_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QGraphicsBlurEffect_Wrapper* wrapper = qobject_cast<QGraphicsBlurEffect_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QGraphicsBlurEffect_Wrapper* wrapper = dynamic_cast<QGraphicsBlurEffect_Wrapper*>(obj);
          //QGraphicsBlurEffect_Wrapper* wrapper = (QGraphicsBlurEffect_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGraphicsBlurEffect: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QGraphicsBlurEffect*)wrapper->getWrappedVoid();
          //return getWrapped_QGraphicsBlurEffect(wrapper);
          return QGraphicsBlurEffect_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QGraphicsBlurEffect_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGraphicsBlurEffect: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QGraphicsBlurEffect_Type);
          //return fun.call().toInt()==RJSType::QGraphicsBlurEffect_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QGraphicsBlurEffect::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QGraphicsColorizeEffect(RJSApi& handler, QGraphicsColorizeEffect* v) {
          QGraphicsColorizeEffect_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QGraphicsColorizeEffect_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QGraphicsColorizeEffect: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QGraphicsColorizeEffect_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QGraphicsColorizeEffect_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QGraphicsColorizeEffect('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGraphicsColorizeEffect");
          if (cl.isUndefined()) {
              qWarning() << "Class QGraphicsColorizeEffect is undefined. Use QGraphicsColorizeEffect_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGraphicsColorizeEffect('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGraphicsColorizeEffect(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGraphicsColorizeEffect(RJSApi& handler, const QGraphicsColorizeEffect* v) {
          return RJSHelper::cpp2js_QGraphicsColorizeEffect(handler, const_cast<QGraphicsColorizeEffect*>(v));
      }

      QGraphicsColorizeEffect* RJSHelper::js2cpp_QGraphicsColorizeEffect_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGraphicsColorizeEffect: not a QObject";
              return nullptr;
          }
          //QGraphicsColorizeEffect_Wrapper* wrapper = getWrapper<QGraphicsColorizeEffect_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QGraphicsColorizeEffect_Wrapper* wrapper = qobject_cast<QGraphicsColorizeEffect_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QGraphicsColorizeEffect_Wrapper* wrapper = dynamic_cast<QGraphicsColorizeEffect_Wrapper*>(obj);
          //QGraphicsColorizeEffect_Wrapper* wrapper = (QGraphicsColorizeEffect_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGraphicsColorizeEffect: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QGraphicsColorizeEffect*)wrapper->getWrappedVoid();
          //return getWrapped_QGraphicsColorizeEffect(wrapper);
          return QGraphicsColorizeEffect_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QGraphicsColorizeEffect_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGraphicsColorizeEffect: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QGraphicsColorizeEffect_Type);
          //return fun.call().toInt()==RJSType::QGraphicsColorizeEffect_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QGraphicsColorizeEffect::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QGraphicsDropShadowEffect(RJSApi& handler, QGraphicsDropShadowEffect* v) {
          QGraphicsDropShadowEffect_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QGraphicsDropShadowEffect_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QGraphicsDropShadowEffect: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QGraphicsDropShadowEffect_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QGraphicsDropShadowEffect_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QGraphicsDropShadowEffect('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGraphicsDropShadowEffect");
          if (cl.isUndefined()) {
              qWarning() << "Class QGraphicsDropShadowEffect is undefined. Use QGraphicsDropShadowEffect_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGraphicsDropShadowEffect('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGraphicsDropShadowEffect(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGraphicsDropShadowEffect(RJSApi& handler, const QGraphicsDropShadowEffect* v) {
          return RJSHelper::cpp2js_QGraphicsDropShadowEffect(handler, const_cast<QGraphicsDropShadowEffect*>(v));
      }

      QGraphicsDropShadowEffect* RJSHelper::js2cpp_QGraphicsDropShadowEffect_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGraphicsDropShadowEffect: not a QObject";
              return nullptr;
          }
          //QGraphicsDropShadowEffect_Wrapper* wrapper = getWrapper<QGraphicsDropShadowEffect_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QGraphicsDropShadowEffect_Wrapper* wrapper = qobject_cast<QGraphicsDropShadowEffect_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QGraphicsDropShadowEffect_Wrapper* wrapper = dynamic_cast<QGraphicsDropShadowEffect_Wrapper*>(obj);
          //QGraphicsDropShadowEffect_Wrapper* wrapper = (QGraphicsDropShadowEffect_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGraphicsDropShadowEffect: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QGraphicsDropShadowEffect*)wrapper->getWrappedVoid();
          //return getWrapped_QGraphicsDropShadowEffect(wrapper);
          return QGraphicsDropShadowEffect_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QGraphicsDropShadowEffect_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGraphicsDropShadowEffect: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QGraphicsDropShadowEffect_Type);
          //return fun.call().toInt()==RJSType::QGraphicsDropShadowEffect_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QGraphicsDropShadowEffect::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QGraphicsEffect(RJSApi& handler, QGraphicsEffect* v) {
          
            // downcast to QGraphicsColorizeEffect:
            {
                QGraphicsColorizeEffect* o = qobject_cast<QGraphicsColorizeEffect*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QGraphicsColorizeEffect(handler, o);
                }
            }
          
            // downcast to QGraphicsBlurEffect:
            {
                QGraphicsBlurEffect* o = qobject_cast<QGraphicsBlurEffect*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QGraphicsBlurEffect(handler, o);
                }
            }
          
            // downcast to QGraphicsDropShadowEffect:
            {
                QGraphicsDropShadowEffect* o = qobject_cast<QGraphicsDropShadowEffect*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QGraphicsDropShadowEffect(handler, o);
                }
            }
          
            // downcast to QGraphicsOpacityEffect:
            {
                QGraphicsOpacityEffect* o = qobject_cast<QGraphicsOpacityEffect*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QGraphicsOpacityEffect(handler, o);
                }
            }
          QGraphicsEffect_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QGraphicsEffect_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QGraphicsEffect: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QGraphicsEffect_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QGraphicsEffect_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QGraphicsEffect('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGraphicsEffect");
          if (cl.isUndefined()) {
              qWarning() << "Class QGraphicsEffect is undefined. Use QGraphicsEffect_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGraphicsEffect('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGraphicsEffect(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGraphicsEffect(RJSApi& handler, const QGraphicsEffect* v) {
          return RJSHelper::cpp2js_QGraphicsEffect(handler, const_cast<QGraphicsEffect*>(v));
      }

      QGraphicsEffect* RJSHelper::js2cpp_QGraphicsEffect_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGraphicsEffect: not a QObject";
              return nullptr;
          }
          //QGraphicsEffect_Wrapper* wrapper = getWrapper<QGraphicsEffect_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QGraphicsEffect_Wrapper* wrapper = qobject_cast<QGraphicsEffect_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QGraphicsEffect_Wrapper* wrapper = dynamic_cast<QGraphicsEffect_Wrapper*>(obj);
          //QGraphicsEffect_Wrapper* wrapper = (QGraphicsEffect_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGraphicsEffect: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QGraphicsEffect*)wrapper->getWrappedVoid();
          //return getWrapped_QGraphicsEffect(wrapper);
          return QGraphicsEffect_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QGraphicsEffect_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGraphicsEffect: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QGraphicsEffect_Type);
          //return fun.call().toInt()==RJSType::QGraphicsEffect_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QGraphicsEffect::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QGraphicsOpacityEffect(RJSApi& handler, QGraphicsOpacityEffect* v) {
          QGraphicsOpacityEffect_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QGraphicsOpacityEffect_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QGraphicsOpacityEffect: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QGraphicsOpacityEffect_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QGraphicsOpacityEffect_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QGraphicsOpacityEffect('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGraphicsOpacityEffect");
          if (cl.isUndefined()) {
              qWarning() << "Class QGraphicsOpacityEffect is undefined. Use QGraphicsOpacityEffect_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGraphicsOpacityEffect('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGraphicsOpacityEffect(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGraphicsOpacityEffect(RJSApi& handler, const QGraphicsOpacityEffect* v) {
          return RJSHelper::cpp2js_QGraphicsOpacityEffect(handler, const_cast<QGraphicsOpacityEffect*>(v));
      }

      QGraphicsOpacityEffect* RJSHelper::js2cpp_QGraphicsOpacityEffect_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGraphicsOpacityEffect: not a QObject";
              return nullptr;
          }
          //QGraphicsOpacityEffect_Wrapper* wrapper = getWrapper<QGraphicsOpacityEffect_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QGraphicsOpacityEffect_Wrapper* wrapper = qobject_cast<QGraphicsOpacityEffect_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QGraphicsOpacityEffect_Wrapper* wrapper = dynamic_cast<QGraphicsOpacityEffect_Wrapper*>(obj);
          //QGraphicsOpacityEffect_Wrapper* wrapper = (QGraphicsOpacityEffect_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGraphicsOpacityEffect: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QGraphicsOpacityEffect*)wrapper->getWrappedVoid();
          //return getWrapped_QGraphicsOpacityEffect(wrapper);
          return QGraphicsOpacityEffect_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QGraphicsOpacityEffect_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGraphicsOpacityEffect: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QGraphicsOpacityEffect_Type);
          //return fun.call().toInt()==RJSType::QGraphicsOpacityEffect_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QGraphicsOpacityEffect::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QGridLayout(RJSApi& handler, QGridLayout* v) {
          QGridLayout_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QGridLayout_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QGridLayout: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QGridLayout_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QGridLayout_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QGridLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGridLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QGridLayout is undefined. Use QGridLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGridLayout('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGridLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGridLayout(RJSApi& handler, const QGridLayout* v) {
          return RJSHelper::cpp2js_QGridLayout(handler, const_cast<QGridLayout*>(v));
      }

      QGridLayout* RJSHelper::js2cpp_QGridLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGridLayout: not a QObject";
              return nullptr;
          }
          //QGridLayout_Wrapper* wrapper = getWrapper<QGridLayout_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QGridLayout_Wrapper* wrapper = qobject_cast<QGridLayout_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QGridLayout_Wrapper* wrapper = dynamic_cast<QGridLayout_Wrapper*>(obj);
          //QGridLayout_Wrapper* wrapper = (QGridLayout_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGridLayout: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QGridLayout*)wrapper->getWrappedVoid();
          //return getWrapped_QGridLayout(wrapper);
          return QGridLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QGridLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGridLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QGridLayout_Type);
          //return fun.call().toInt()==RJSType::QGridLayout_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QGridLayout::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QGroupBox(RJSApi& handler, QGroupBox* v) {
          QGroupBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QGroupBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QGroupBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QGroupBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QGroupBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QGroupBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGroupBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QGroupBox is undefined. Use QGroupBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGroupBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGroupBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGroupBox(RJSApi& handler, const QGroupBox* v) {
          return RJSHelper::cpp2js_QGroupBox(handler, const_cast<QGroupBox*>(v));
      }

      QGroupBox* RJSHelper::js2cpp_QGroupBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGroupBox: not a QObject";
              return nullptr;
          }
          //QGroupBox_Wrapper* wrapper = getWrapper<QGroupBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QGroupBox_Wrapper* wrapper = qobject_cast<QGroupBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QGroupBox_Wrapper* wrapper = dynamic_cast<QGroupBox_Wrapper*>(obj);
          //QGroupBox_Wrapper* wrapper = (QGroupBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGroupBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QGroupBox*)wrapper->getWrappedVoid();
          //return getWrapped_QGroupBox(wrapper);
          return QGroupBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QGroupBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGroupBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QGroupBox_Type);
          //return fun.call().toInt()==RJSType::QGroupBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QGroupBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QGuiApplication(RJSApi& handler, QGuiApplication* v) {
          
            // downcast to QApplication:
            {
                QApplication* o = qobject_cast<QApplication*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QApplication(handler, o);
                }
            }
          QGuiApplication_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QGuiApplication_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QGuiApplication: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QGuiApplication_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QGuiApplication_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QGuiApplication('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGuiApplication");
          if (cl.isUndefined()) {
              qWarning() << "Class QGuiApplication is undefined. Use QGuiApplication_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGuiApplication('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGuiApplication(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGuiApplication(RJSApi& handler, const QGuiApplication* v) {
          return RJSHelper::cpp2js_QGuiApplication(handler, const_cast<QGuiApplication*>(v));
      }

      QGuiApplication* RJSHelper::js2cpp_QGuiApplication_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGuiApplication: not a QObject";
              return nullptr;
          }
          //QGuiApplication_Wrapper* wrapper = getWrapper<QGuiApplication_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QGuiApplication_Wrapper* wrapper = qobject_cast<QGuiApplication_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QGuiApplication_Wrapper* wrapper = dynamic_cast<QGuiApplication_Wrapper*>(obj);
          //QGuiApplication_Wrapper* wrapper = (QGuiApplication_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGuiApplication: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QGuiApplication*)wrapper->getWrappedVoid();
          //return getWrapped_QGuiApplication(wrapper);
          return QGuiApplication_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QGuiApplication_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGuiApplication: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QGuiApplication_Type);
          //return fun.call().toInt()==RJSType::QGuiApplication_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QGuiApplication::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QHBoxLayout(RJSApi& handler, QHBoxLayout* v) {
          QHBoxLayout_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QHBoxLayout_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QHBoxLayout: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QHBoxLayout_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QHBoxLayout_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QHBoxLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QHBoxLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QHBoxLayout is undefined. Use QHBoxLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QHBoxLayout('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QHBoxLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QHBoxLayout(RJSApi& handler, const QHBoxLayout* v) {
          return RJSHelper::cpp2js_QHBoxLayout(handler, const_cast<QHBoxLayout*>(v));
      }

      QHBoxLayout* RJSHelper::js2cpp_QHBoxLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QHBoxLayout: not a QObject";
              return nullptr;
          }
          //QHBoxLayout_Wrapper* wrapper = getWrapper<QHBoxLayout_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QHBoxLayout_Wrapper* wrapper = qobject_cast<QHBoxLayout_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QHBoxLayout_Wrapper* wrapper = dynamic_cast<QHBoxLayout_Wrapper*>(obj);
          //QHBoxLayout_Wrapper* wrapper = (QHBoxLayout_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QHBoxLayout: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QHBoxLayout*)wrapper->getWrappedVoid();
          //return getWrapped_QHBoxLayout(wrapper);
          return QHBoxLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QHBoxLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QHBoxLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QHBoxLayout_Type);
          //return fun.call().toInt()==RJSType::QHBoxLayout_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QHBoxLayout::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QHeaderView(RJSApi& handler, QHeaderView* v) {
          QHeaderView_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QHeaderView_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QHeaderView: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QHeaderView_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QHeaderView_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QHeaderView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QHeaderView");
          if (cl.isUndefined()) {
              qWarning() << "Class QHeaderView is undefined. Use QHeaderView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QHeaderView('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QHeaderView(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QHeaderView(RJSApi& handler, const QHeaderView* v) {
          return RJSHelper::cpp2js_QHeaderView(handler, const_cast<QHeaderView*>(v));
      }

      QHeaderView* RJSHelper::js2cpp_QHeaderView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QHeaderView: not a QObject";
              return nullptr;
          }
          //QHeaderView_Wrapper* wrapper = getWrapper<QHeaderView_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QHeaderView_Wrapper* wrapper = qobject_cast<QHeaderView_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QHeaderView_Wrapper* wrapper = dynamic_cast<QHeaderView_Wrapper*>(obj);
          //QHeaderView_Wrapper* wrapper = (QHeaderView_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QHeaderView: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QHeaderView*)wrapper->getWrappedVoid();
          //return getWrapped_QHeaderView(wrapper);
          return QHeaderView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QHeaderView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QHeaderView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QHeaderView_Type);
          //return fun.call().toInt()==RJSType::QHeaderView_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QHeaderView::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QIODevice(RJSApi& handler, QIODevice* v) {
          
            // downcast to QBuffer:
            {
                QBuffer* o = qobject_cast<QBuffer*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QBuffer(handler, o);
                }
            }
          
            // downcast to QFile:
            {
                QFile* o = qobject_cast<QFile*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QFile(handler, o);
                }
            }
          
            // downcast to QFileDevice:
            {
                QFileDevice* o = qobject_cast<QFileDevice*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QFileDevice(handler, o);
                }
            }
          
            // downcast to QProcess:
            {
                QProcess* o = qobject_cast<QProcess*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QProcess(handler, o);
                }
            }
          QIODevice_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QIODevice_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QIODevice: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QIODevice_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QIODevice_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QIODevice('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QIODevice");
          if (cl.isUndefined()) {
              qWarning() << "Class QIODevice is undefined. Use QIODevice_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QIODevice('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QIODevice(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QIODevice(RJSApi& handler, const QIODevice* v) {
          return RJSHelper::cpp2js_QIODevice(handler, const_cast<QIODevice*>(v));
      }

      QIODevice* RJSHelper::js2cpp_QIODevice_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QIODevice: not a QObject";
              return nullptr;
          }
          //QIODevice_Wrapper* wrapper = getWrapper<QIODevice_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QIODevice_Wrapper* wrapper = qobject_cast<QIODevice_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QIODevice_Wrapper* wrapper = dynamic_cast<QIODevice_Wrapper*>(obj);
          //QIODevice_Wrapper* wrapper = (QIODevice_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QIODevice: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QIODevice*)wrapper->getWrappedVoid();
          //return getWrapped_QIODevice(wrapper);
          return QIODevice_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QIODevice_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QIODevice: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QIODevice_Type);
          //return fun.call().toInt()==RJSType::QIODevice_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QIODevice::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QInputDevice(RJSApi& handler, QInputDevice* v) {
          QInputDevice_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QInputDevice_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QInputDevice: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QInputDevice_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QInputDevice_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QInputDevice('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QInputDevice");
          if (cl.isUndefined()) {
              qWarning() << "Class QInputDevice is undefined. Use QInputDevice_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QInputDevice('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QInputDevice(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QInputDevice(RJSApi& handler, const QInputDevice* v) {
          return RJSHelper::cpp2js_QInputDevice(handler, const_cast<QInputDevice*>(v));
      }

      QInputDevice* RJSHelper::js2cpp_QInputDevice_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QInputDevice: not a QObject";
              return nullptr;
          }
          //QInputDevice_Wrapper* wrapper = getWrapper<QInputDevice_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QInputDevice_Wrapper* wrapper = qobject_cast<QInputDevice_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QInputDevice_Wrapper* wrapper = dynamic_cast<QInputDevice_Wrapper*>(obj);
          //QInputDevice_Wrapper* wrapper = (QInputDevice_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QInputDevice: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QInputDevice*)wrapper->getWrappedVoid();
          //return getWrapped_QInputDevice(wrapper);
          return QInputDevice_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QInputDevice_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QInputDevice: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QInputDevice_Type);
          //return fun.call().toInt()==RJSType::QInputDevice_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QInputDevice::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QIntValidator(RJSApi& handler, QIntValidator* v) {
          QIntValidator_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QIntValidator_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QIntValidator: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QIntValidator_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QIntValidator_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QIntValidator('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QIntValidator");
          if (cl.isUndefined()) {
              qWarning() << "Class QIntValidator is undefined. Use QIntValidator_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QIntValidator('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QIntValidator(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QIntValidator(RJSApi& handler, const QIntValidator* v) {
          return RJSHelper::cpp2js_QIntValidator(handler, const_cast<QIntValidator*>(v));
      }

      QIntValidator* RJSHelper::js2cpp_QIntValidator_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QIntValidator: not a QObject";
              return nullptr;
          }
          //QIntValidator_Wrapper* wrapper = getWrapper<QIntValidator_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QIntValidator_Wrapper* wrapper = qobject_cast<QIntValidator_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QIntValidator_Wrapper* wrapper = dynamic_cast<QIntValidator_Wrapper*>(obj);
          //QIntValidator_Wrapper* wrapper = (QIntValidator_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QIntValidator: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QIntValidator*)wrapper->getWrappedVoid();
          //return getWrapped_QIntValidator(wrapper);
          return QIntValidator_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QIntValidator_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QIntValidator: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QIntValidator_Type);
          //return fun.call().toInt()==RJSType::QIntValidator_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QIntValidator::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QItemDelegate(RJSApi& handler, QItemDelegate* v) {
          
            // downcast to types derrived from QItemDelegate but defined in other modules:
            for (int i=0; i<downcasters_QItemDelegate.length(); i++) {
                QJSValue dc = downcasters_QItemDelegate[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QItemDelegate_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QItemDelegate_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QItemDelegate: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QItemDelegate_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QItemDelegate_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QItemDelegate('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QItemDelegate");
          if (cl.isUndefined()) {
              qWarning() << "Class QItemDelegate is undefined. Use QItemDelegate_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QItemDelegate('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QItemDelegate(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QItemDelegate(RJSApi& handler, const QItemDelegate* v) {
          return RJSHelper::cpp2js_QItemDelegate(handler, const_cast<QItemDelegate*>(v));
      }

      QItemDelegate* RJSHelper::js2cpp_QItemDelegate_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QItemDelegate: not a QObject";
              return nullptr;
          }
          //QItemDelegate_Wrapper* wrapper = getWrapper<QItemDelegate_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QItemDelegate_Wrapper* wrapper = qobject_cast<QItemDelegate_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QItemDelegate_Wrapper* wrapper = dynamic_cast<QItemDelegate_Wrapper*>(obj);
          //QItemDelegate_Wrapper* wrapper = (QItemDelegate_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QItemDelegate: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QItemDelegate*)wrapper->getWrappedVoid();
          //return getWrapped_QItemDelegate(wrapper);
          return QItemDelegate_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QItemDelegate_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QItemDelegate: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QItemDelegate_Type);
          //return fun.call().toInt()==RJSType::QItemDelegate_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QItemDelegate::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QItemSelectionModel(RJSApi& handler, QItemSelectionModel* v) {
          QItemSelectionModel_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QItemSelectionModel_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QItemSelectionModel: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QItemSelectionModel_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QItemSelectionModel_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QItemSelectionModel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QItemSelectionModel");
          if (cl.isUndefined()) {
              qWarning() << "Class QItemSelectionModel is undefined. Use QItemSelectionModel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QItemSelectionModel('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QItemSelectionModel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QItemSelectionModel(RJSApi& handler, const QItemSelectionModel* v) {
          return RJSHelper::cpp2js_QItemSelectionModel(handler, const_cast<QItemSelectionModel*>(v));
      }

      QItemSelectionModel* RJSHelper::js2cpp_QItemSelectionModel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QItemSelectionModel: not a QObject";
              return nullptr;
          }
          //QItemSelectionModel_Wrapper* wrapper = getWrapper<QItemSelectionModel_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QItemSelectionModel_Wrapper* wrapper = qobject_cast<QItemSelectionModel_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QItemSelectionModel_Wrapper* wrapper = dynamic_cast<QItemSelectionModel_Wrapper*>(obj);
          //QItemSelectionModel_Wrapper* wrapper = (QItemSelectionModel_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QItemSelectionModel: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QItemSelectionModel*)wrapper->getWrappedVoid();
          //return getWrapped_QItemSelectionModel(wrapper);
          return QItemSelectionModel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QItemSelectionModel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QItemSelectionModel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QItemSelectionModel_Type);
          //return fun.call().toInt()==RJSType::QItemSelectionModel_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QItemSelectionModel::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QLabel(RJSApi& handler, QLabel* v) {
          QLabel_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QLabel_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QLabel: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QLabel_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QLabel_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QLabel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLabel");
          if (cl.isUndefined()) {
              qWarning() << "Class QLabel is undefined. Use QLabel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLabel('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLabel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QLabel(RJSApi& handler, const QLabel* v) {
          return RJSHelper::cpp2js_QLabel(handler, const_cast<QLabel*>(v));
      }

      QLabel* RJSHelper::js2cpp_QLabel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QLabel: not a QObject";
              return nullptr;
          }
          //QLabel_Wrapper* wrapper = getWrapper<QLabel_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QLabel_Wrapper* wrapper = qobject_cast<QLabel_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QLabel_Wrapper* wrapper = dynamic_cast<QLabel_Wrapper*>(obj);
          //QLabel_Wrapper* wrapper = (QLabel_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLabel: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QLabel*)wrapper->getWrappedVoid();
          //return getWrapped_QLabel(wrapper);
          return QLabel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QLabel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QLabel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QLabel_Type);
          //return fun.call().toInt()==RJSType::QLabel_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QLabel::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QLayout(RJSApi& handler, QLayout* v) {
          
            // downcast to QBoxLayout:
            {
                QBoxLayout* o = qobject_cast<QBoxLayout*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QBoxLayout(handler, o);
                }
            }
          
            // downcast to QFormLayout:
            {
                QFormLayout* o = qobject_cast<QFormLayout*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QFormLayout(handler, o);
                }
            }
          
            // downcast to QGridLayout:
            {
                QGridLayout* o = qobject_cast<QGridLayout*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QGridLayout(handler, o);
                }
            }
          
            // downcast to QStackedLayout:
            {
                QStackedLayout* o = qobject_cast<QStackedLayout*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QStackedLayout(handler, o);
                }
            }
          
            // downcast to types derrived from QLayout but defined in other modules:
            for (int i=0; i<downcasters_QLayout.length(); i++) {
                QJSValue dc = downcasters_QLayout[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QLayout_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QLayout_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QLayout: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QLayout_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QLayout_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QLayout is undefined. Use QLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLayout('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QLayout(RJSApi& handler, const QLayout* v) {
          return RJSHelper::cpp2js_QLayout(handler, const_cast<QLayout*>(v));
      }

      QLayout* RJSHelper::js2cpp_QLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QLayout: not a QObject";
              return nullptr;
          }
          //QLayout_Wrapper* wrapper = getWrapper<QLayout_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QLayout_Wrapper* wrapper = qobject_cast<QLayout_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QLayout_Wrapper* wrapper = dynamic_cast<QLayout_Wrapper*>(obj);
          //QLayout_Wrapper* wrapper = (QLayout_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLayout: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QLayout*)wrapper->getWrappedVoid();
          //return getWrapped_QLayout(wrapper);
          return QLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QLayout_Type);
          //return fun.call().toInt()==RJSType::QLayout_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QLayout::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QLineEdit(RJSApi& handler, QLineEdit* v) {
          
            // downcast to types derrived from QLineEdit but defined in other modules:
            for (int i=0; i<downcasters_QLineEdit.length(); i++) {
                QJSValue dc = downcasters_QLineEdit[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QLineEdit_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QLineEdit_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QLineEdit: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QLineEdit_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QLineEdit_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QLineEdit('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLineEdit");
          if (cl.isUndefined()) {
              qWarning() << "Class QLineEdit is undefined. Use QLineEdit_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLineEdit('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLineEdit(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QLineEdit(RJSApi& handler, const QLineEdit* v) {
          return RJSHelper::cpp2js_QLineEdit(handler, const_cast<QLineEdit*>(v));
      }

      QLineEdit* RJSHelper::js2cpp_QLineEdit_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QLineEdit: not a QObject";
              return nullptr;
          }
          //QLineEdit_Wrapper* wrapper = getWrapper<QLineEdit_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QLineEdit_Wrapper* wrapper = qobject_cast<QLineEdit_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QLineEdit_Wrapper* wrapper = dynamic_cast<QLineEdit_Wrapper*>(obj);
          //QLineEdit_Wrapper* wrapper = (QLineEdit_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLineEdit: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QLineEdit*)wrapper->getWrappedVoid();
          //return getWrapped_QLineEdit(wrapper);
          return QLineEdit_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QLineEdit_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QLineEdit: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QLineEdit_Type);
          //return fun.call().toInt()==RJSType::QLineEdit_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QLineEdit::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QListView(RJSApi& handler, QListView* v) {
          
            // downcast to QListWidget:
            {
                QListWidget* o = qobject_cast<QListWidget*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QListWidget(handler, o);
                }
            }
          
            // downcast to types derrived from QListView but defined in other modules:
            for (int i=0; i<downcasters_QListView.length(); i++) {
                QJSValue dc = downcasters_QListView[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QListView_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QListView_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QListView: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QListView_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QListView_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QListView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QListView");
          if (cl.isUndefined()) {
              qWarning() << "Class QListView is undefined. Use QListView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QListView('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QListView(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QListView(RJSApi& handler, const QListView* v) {
          return RJSHelper::cpp2js_QListView(handler, const_cast<QListView*>(v));
      }

      QListView* RJSHelper::js2cpp_QListView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QListView: not a QObject";
              return nullptr;
          }
          //QListView_Wrapper* wrapper = getWrapper<QListView_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QListView_Wrapper* wrapper = qobject_cast<QListView_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QListView_Wrapper* wrapper = dynamic_cast<QListView_Wrapper*>(obj);
          //QListView_Wrapper* wrapper = (QListView_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QListView: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QListView*)wrapper->getWrappedVoid();
          //return getWrapped_QListView(wrapper);
          return QListView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QListView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QListView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QListView_Type);
          //return fun.call().toInt()==RJSType::QListView_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QListView::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QListWidget(RJSApi& handler, QListWidget* v) {
          
            // downcast to types derrived from QListWidget but defined in other modules:
            for (int i=0; i<downcasters_QListWidget.length(); i++) {
                QJSValue dc = downcasters_QListWidget[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QListWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QListWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QListWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QListWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QListWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QListWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QListWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class QListWidget is undefined. Use QListWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QListWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QListWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QListWidget(RJSApi& handler, const QListWidget* v) {
          return RJSHelper::cpp2js_QListWidget(handler, const_cast<QListWidget*>(v));
      }

      QListWidget* RJSHelper::js2cpp_QListWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QListWidget: not a QObject";
              return nullptr;
          }
          //QListWidget_Wrapper* wrapper = getWrapper<QListWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QListWidget_Wrapper* wrapper = qobject_cast<QListWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QListWidget_Wrapper* wrapper = dynamic_cast<QListWidget_Wrapper*>(obj);
          //QListWidget_Wrapper* wrapper = (QListWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QListWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QListWidget*)wrapper->getWrappedVoid();
          //return getWrapped_QListWidget(wrapper);
          return QListWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QListWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QListWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QListWidget_Type);
          //return fun.call().toInt()==RJSType::QListWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QListWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QMainWindow(RJSApi& handler, QMainWindow* v) {
          
            // downcast to types derrived from QMainWindow but defined in other modules:
            for (int i=0; i<downcasters_QMainWindow.length(); i++) {
                QJSValue dc = downcasters_QMainWindow[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QMainWindow_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QMainWindow_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QMainWindow: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QMainWindow_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QMainWindow_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QMainWindow('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMainWindow");
          if (cl.isUndefined()) {
              qWarning() << "Class QMainWindow is undefined. Use QMainWindow_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMainWindow('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMainWindow(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMainWindow(RJSApi& handler, const QMainWindow* v) {
          return RJSHelper::cpp2js_QMainWindow(handler, const_cast<QMainWindow*>(v));
      }

      QMainWindow* RJSHelper::js2cpp_QMainWindow_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMainWindow: not a QObject";
              return nullptr;
          }
          //QMainWindow_Wrapper* wrapper = getWrapper<QMainWindow_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QMainWindow_Wrapper* wrapper = qobject_cast<QMainWindow_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QMainWindow_Wrapper* wrapper = dynamic_cast<QMainWindow_Wrapper*>(obj);
          //QMainWindow_Wrapper* wrapper = (QMainWindow_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMainWindow: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QMainWindow*)wrapper->getWrappedVoid();
          //return getWrapped_QMainWindow(wrapper);
          return QMainWindow_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QMainWindow_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMainWindow: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QMainWindow_Type);
          //return fun.call().toInt()==RJSType::QMainWindow_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QMainWindow::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QMdiArea(RJSApi& handler, QMdiArea* v) {
          
            // downcast to types derrived from QMdiArea but defined in other modules:
            for (int i=0; i<downcasters_QMdiArea.length(); i++) {
                QJSValue dc = downcasters_QMdiArea[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QMdiArea_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QMdiArea_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QMdiArea: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QMdiArea_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QMdiArea_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QMdiArea('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMdiArea");
          if (cl.isUndefined()) {
              qWarning() << "Class QMdiArea is undefined. Use QMdiArea_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMdiArea('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMdiArea(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMdiArea(RJSApi& handler, const QMdiArea* v) {
          return RJSHelper::cpp2js_QMdiArea(handler, const_cast<QMdiArea*>(v));
      }

      QMdiArea* RJSHelper::js2cpp_QMdiArea_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMdiArea: not a QObject";
              return nullptr;
          }
          //QMdiArea_Wrapper* wrapper = getWrapper<QMdiArea_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QMdiArea_Wrapper* wrapper = qobject_cast<QMdiArea_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QMdiArea_Wrapper* wrapper = dynamic_cast<QMdiArea_Wrapper*>(obj);
          //QMdiArea_Wrapper* wrapper = (QMdiArea_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMdiArea: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QMdiArea*)wrapper->getWrappedVoid();
          //return getWrapped_QMdiArea(wrapper);
          return QMdiArea_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QMdiArea_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMdiArea: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QMdiArea_Type);
          //return fun.call().toInt()==RJSType::QMdiArea_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QMdiArea::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QMdiSubWindow(RJSApi& handler, QMdiSubWindow* v) {
          
            // downcast to types derrived from QMdiSubWindow but defined in other modules:
            for (int i=0; i<downcasters_QMdiSubWindow.length(); i++) {
                QJSValue dc = downcasters_QMdiSubWindow[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QMdiSubWindow_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QMdiSubWindow_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QMdiSubWindow: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QMdiSubWindow_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QMdiSubWindow_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QMdiSubWindow('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMdiSubWindow");
          if (cl.isUndefined()) {
              qWarning() << "Class QMdiSubWindow is undefined. Use QMdiSubWindow_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMdiSubWindow('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMdiSubWindow(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMdiSubWindow(RJSApi& handler, const QMdiSubWindow* v) {
          return RJSHelper::cpp2js_QMdiSubWindow(handler, const_cast<QMdiSubWindow*>(v));
      }

      QMdiSubWindow* RJSHelper::js2cpp_QMdiSubWindow_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMdiSubWindow: not a QObject";
              return nullptr;
          }
          //QMdiSubWindow_Wrapper* wrapper = getWrapper<QMdiSubWindow_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QMdiSubWindow_Wrapper* wrapper = qobject_cast<QMdiSubWindow_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QMdiSubWindow_Wrapper* wrapper = dynamic_cast<QMdiSubWindow_Wrapper*>(obj);
          //QMdiSubWindow_Wrapper* wrapper = (QMdiSubWindow_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMdiSubWindow: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QMdiSubWindow*)wrapper->getWrappedVoid();
          //return getWrapped_QMdiSubWindow(wrapper);
          return QMdiSubWindow_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QMdiSubWindow_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMdiSubWindow: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QMdiSubWindow_Type);
          //return fun.call().toInt()==RJSType::QMdiSubWindow_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QMdiSubWindow::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QMenu(RJSApi& handler, QMenu* v) {
          QMenu_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QMenu_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QMenu: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QMenu_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QMenu_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QMenu('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMenu");
          if (cl.isUndefined()) {
              qWarning() << "Class QMenu is undefined. Use QMenu_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMenu('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMenu(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMenu(RJSApi& handler, const QMenu* v) {
          return RJSHelper::cpp2js_QMenu(handler, const_cast<QMenu*>(v));
      }

      QMenu* RJSHelper::js2cpp_QMenu_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMenu: not a QObject";
              return nullptr;
          }
          //QMenu_Wrapper* wrapper = getWrapper<QMenu_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QMenu_Wrapper* wrapper = qobject_cast<QMenu_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QMenu_Wrapper* wrapper = dynamic_cast<QMenu_Wrapper*>(obj);
          //QMenu_Wrapper* wrapper = (QMenu_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMenu: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QMenu*)wrapper->getWrappedVoid();
          //return getWrapped_QMenu(wrapper);
          return QMenu_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QMenu_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMenu: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QMenu_Type);
          //return fun.call().toInt()==RJSType::QMenu_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QMenu::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QMenuBar(RJSApi& handler, QMenuBar* v) {
          QMenuBar_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QMenuBar_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QMenuBar: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QMenuBar_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QMenuBar_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QMenuBar('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMenuBar");
          if (cl.isUndefined()) {
              qWarning() << "Class QMenuBar is undefined. Use QMenuBar_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMenuBar('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMenuBar(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMenuBar(RJSApi& handler, const QMenuBar* v) {
          return RJSHelper::cpp2js_QMenuBar(handler, const_cast<QMenuBar*>(v));
      }

      QMenuBar* RJSHelper::js2cpp_QMenuBar_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMenuBar: not a QObject";
              return nullptr;
          }
          //QMenuBar_Wrapper* wrapper = getWrapper<QMenuBar_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QMenuBar_Wrapper* wrapper = qobject_cast<QMenuBar_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QMenuBar_Wrapper* wrapper = dynamic_cast<QMenuBar_Wrapper*>(obj);
          //QMenuBar_Wrapper* wrapper = (QMenuBar_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMenuBar: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QMenuBar*)wrapper->getWrappedVoid();
          //return getWrapped_QMenuBar(wrapper);
          return QMenuBar_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QMenuBar_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMenuBar: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QMenuBar_Type);
          //return fun.call().toInt()==RJSType::QMenuBar_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QMenuBar::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QMessageBox(RJSApi& handler, QMessageBox* v) {
          QMessageBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QMessageBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QMessageBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QMessageBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QMessageBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QMessageBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMessageBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QMessageBox is undefined. Use QMessageBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMessageBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMessageBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMessageBox(RJSApi& handler, const QMessageBox* v) {
          return RJSHelper::cpp2js_QMessageBox(handler, const_cast<QMessageBox*>(v));
      }

      QMessageBox* RJSHelper::js2cpp_QMessageBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMessageBox: not a QObject";
              return nullptr;
          }
          //QMessageBox_Wrapper* wrapper = getWrapper<QMessageBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QMessageBox_Wrapper* wrapper = qobject_cast<QMessageBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QMessageBox_Wrapper* wrapper = dynamic_cast<QMessageBox_Wrapper*>(obj);
          //QMessageBox_Wrapper* wrapper = (QMessageBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMessageBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QMessageBox*)wrapper->getWrappedVoid();
          //return getWrapped_QMessageBox(wrapper);
          return QMessageBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QMessageBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMessageBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QMessageBox_Type);
          //return fun.call().toInt()==RJSType::QMessageBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QMessageBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QMimeData(RJSApi& handler, QMimeData* v) {
          QMimeData_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QMimeData_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QMimeData: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QMimeData_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QMimeData_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QMimeData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMimeData");
          if (cl.isUndefined()) {
              qWarning() << "Class QMimeData is undefined. Use QMimeData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMimeData('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMimeData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMimeData(RJSApi& handler, const QMimeData* v) {
          return RJSHelper::cpp2js_QMimeData(handler, const_cast<QMimeData*>(v));
      }

      QMimeData* RJSHelper::js2cpp_QMimeData_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMimeData: not a QObject";
              return nullptr;
          }
          //QMimeData_Wrapper* wrapper = getWrapper<QMimeData_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QMimeData_Wrapper* wrapper = qobject_cast<QMimeData_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QMimeData_Wrapper* wrapper = dynamic_cast<QMimeData_Wrapper*>(obj);
          //QMimeData_Wrapper* wrapper = (QMimeData_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMimeData: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QMimeData*)wrapper->getWrappedVoid();
          //return getWrapped_QMimeData(wrapper);
          return QMimeData_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QMimeData_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMimeData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QMimeData_Type);
          //return fun.call().toInt()==RJSType::QMimeData_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QMimeData::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QPlainTextEdit(RJSApi& handler, QPlainTextEdit* v) {
          QPlainTextEdit_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QPlainTextEdit_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QPlainTextEdit: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QPlainTextEdit_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QPlainTextEdit_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QPlainTextEdit('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPlainTextEdit");
          if (cl.isUndefined()) {
              qWarning() << "Class QPlainTextEdit is undefined. Use QPlainTextEdit_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPlainTextEdit('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPlainTextEdit(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPlainTextEdit(RJSApi& handler, const QPlainTextEdit* v) {
          return RJSHelper::cpp2js_QPlainTextEdit(handler, const_cast<QPlainTextEdit*>(v));
      }

      QPlainTextEdit* RJSHelper::js2cpp_QPlainTextEdit_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPlainTextEdit: not a QObject";
              return nullptr;
          }
          //QPlainTextEdit_Wrapper* wrapper = getWrapper<QPlainTextEdit_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QPlainTextEdit_Wrapper* wrapper = qobject_cast<QPlainTextEdit_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPlainTextEdit_Wrapper* wrapper = dynamic_cast<QPlainTextEdit_Wrapper*>(obj);
          //QPlainTextEdit_Wrapper* wrapper = (QPlainTextEdit_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPlainTextEdit: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QPlainTextEdit*)wrapper->getWrappedVoid();
          //return getWrapped_QPlainTextEdit(wrapper);
          return QPlainTextEdit_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPlainTextEdit_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPlainTextEdit: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QPlainTextEdit_Type);
          //return fun.call().toInt()==RJSType::QPlainTextEdit_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QPlainTextEdit::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QPrintDialog(RJSApi& handler, QPrintDialog* v) {
          QPrintDialog_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QPrintDialog_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QPrintDialog: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QPrintDialog_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QPrintDialog_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QPrintDialog('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPrintDialog");
          if (cl.isUndefined()) {
              qWarning() << "Class QPrintDialog is undefined. Use QPrintDialog_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPrintDialog('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPrintDialog(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPrintDialog(RJSApi& handler, const QPrintDialog* v) {
          return RJSHelper::cpp2js_QPrintDialog(handler, const_cast<QPrintDialog*>(v));
      }

      QPrintDialog* RJSHelper::js2cpp_QPrintDialog_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPrintDialog: not a QObject";
              return nullptr;
          }
          //QPrintDialog_Wrapper* wrapper = getWrapper<QPrintDialog_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QPrintDialog_Wrapper* wrapper = qobject_cast<QPrintDialog_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPrintDialog_Wrapper* wrapper = dynamic_cast<QPrintDialog_Wrapper*>(obj);
          //QPrintDialog_Wrapper* wrapper = (QPrintDialog_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPrintDialog: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QPrintDialog*)wrapper->getWrappedVoid();
          //return getWrapped_QPrintDialog(wrapper);
          return QPrintDialog_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPrintDialog_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPrintDialog: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QPrintDialog_Type);
          //return fun.call().toInt()==RJSType::QPrintDialog_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QPrintDialog::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QProgressBar(RJSApi& handler, QProgressBar* v) {
          QProgressBar_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QProgressBar_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QProgressBar: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QProgressBar_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QProgressBar_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QProgressBar('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QProgressBar");
          if (cl.isUndefined()) {
              qWarning() << "Class QProgressBar is undefined. Use QProgressBar_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QProgressBar('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QProgressBar(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QProgressBar(RJSApi& handler, const QProgressBar* v) {
          return RJSHelper::cpp2js_QProgressBar(handler, const_cast<QProgressBar*>(v));
      }

      QProgressBar* RJSHelper::js2cpp_QProgressBar_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QProgressBar: not a QObject";
              return nullptr;
          }
          //QProgressBar_Wrapper* wrapper = getWrapper<QProgressBar_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QProgressBar_Wrapper* wrapper = qobject_cast<QProgressBar_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QProgressBar_Wrapper* wrapper = dynamic_cast<QProgressBar_Wrapper*>(obj);
          //QProgressBar_Wrapper* wrapper = (QProgressBar_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QProgressBar: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QProgressBar*)wrapper->getWrappedVoid();
          //return getWrapped_QProgressBar(wrapper);
          return QProgressBar_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QProgressBar_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QProgressBar: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QProgressBar_Type);
          //return fun.call().toInt()==RJSType::QProgressBar_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QProgressBar::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QProgressDialog(RJSApi& handler, QProgressDialog* v) {
          QProgressDialog_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QProgressDialog_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QProgressDialog: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QProgressDialog_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QProgressDialog_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QProgressDialog('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QProgressDialog");
          if (cl.isUndefined()) {
              qWarning() << "Class QProgressDialog is undefined. Use QProgressDialog_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QProgressDialog('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QProgressDialog(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QProgressDialog(RJSApi& handler, const QProgressDialog* v) {
          return RJSHelper::cpp2js_QProgressDialog(handler, const_cast<QProgressDialog*>(v));
      }

      QProgressDialog* RJSHelper::js2cpp_QProgressDialog_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QProgressDialog: not a QObject";
              return nullptr;
          }
          //QProgressDialog_Wrapper* wrapper = getWrapper<QProgressDialog_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QProgressDialog_Wrapper* wrapper = qobject_cast<QProgressDialog_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QProgressDialog_Wrapper* wrapper = dynamic_cast<QProgressDialog_Wrapper*>(obj);
          //QProgressDialog_Wrapper* wrapper = (QProgressDialog_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QProgressDialog: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QProgressDialog*)wrapper->getWrappedVoid();
          //return getWrapped_QProgressDialog(wrapper);
          return QProgressDialog_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QProgressDialog_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QProgressDialog: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QProgressDialog_Type);
          //return fun.call().toInt()==RJSType::QProgressDialog_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QProgressDialog::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QPushButton(RJSApi& handler, QPushButton* v) {
          QPushButton_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QPushButton_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QPushButton: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QPushButton_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QPushButton_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QPushButton('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPushButton");
          if (cl.isUndefined()) {
              qWarning() << "Class QPushButton is undefined. Use QPushButton_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPushButton('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPushButton(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPushButton(RJSApi& handler, const QPushButton* v) {
          return RJSHelper::cpp2js_QPushButton(handler, const_cast<QPushButton*>(v));
      }

      QPushButton* RJSHelper::js2cpp_QPushButton_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPushButton: not a QObject";
              return nullptr;
          }
          //QPushButton_Wrapper* wrapper = getWrapper<QPushButton_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QPushButton_Wrapper* wrapper = qobject_cast<QPushButton_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPushButton_Wrapper* wrapper = dynamic_cast<QPushButton_Wrapper*>(obj);
          //QPushButton_Wrapper* wrapper = (QPushButton_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPushButton: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QPushButton*)wrapper->getWrappedVoid();
          //return getWrapped_QPushButton(wrapper);
          return QPushButton_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPushButton_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPushButton: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QPushButton_Type);
          //return fun.call().toInt()==RJSType::QPushButton_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QPushButton::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QQuickView(RJSApi& handler, QQuickView* v) {
          QQuickView_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QQuickView_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QQuickView: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QQuickView_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QQuickView_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QQuickView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QQuickView");
          if (cl.isUndefined()) {
              qWarning() << "Class QQuickView is undefined. Use QQuickView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QQuickView('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QQuickView(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QQuickView(RJSApi& handler, const QQuickView* v) {
          return RJSHelper::cpp2js_QQuickView(handler, const_cast<QQuickView*>(v));
      }

      QQuickView* RJSHelper::js2cpp_QQuickView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QQuickView: not a QObject";
              return nullptr;
          }
          //QQuickView_Wrapper* wrapper = getWrapper<QQuickView_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QQuickView_Wrapper* wrapper = qobject_cast<QQuickView_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QQuickView_Wrapper* wrapper = dynamic_cast<QQuickView_Wrapper*>(obj);
          //QQuickView_Wrapper* wrapper = (QQuickView_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QQuickView: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QQuickView*)wrapper->getWrappedVoid();
          //return getWrapped_QQuickView(wrapper);
          return QQuickView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QQuickView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QQuickView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QQuickView_Type);
          //return fun.call().toInt()==RJSType::QQuickView_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QQuickView::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QQuickWidget(RJSApi& handler, QQuickWidget* v) {
          QQuickWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QQuickWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QQuickWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QQuickWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QQuickWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QQuickWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QQuickWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class QQuickWidget is undefined. Use QQuickWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QQuickWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QQuickWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QQuickWidget(RJSApi& handler, const QQuickWidget* v) {
          return RJSHelper::cpp2js_QQuickWidget(handler, const_cast<QQuickWidget*>(v));
      }

      QQuickWidget* RJSHelper::js2cpp_QQuickWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QQuickWidget: not a QObject";
              return nullptr;
          }
          //QQuickWidget_Wrapper* wrapper = getWrapper<QQuickWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QQuickWidget_Wrapper* wrapper = qobject_cast<QQuickWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QQuickWidget_Wrapper* wrapper = dynamic_cast<QQuickWidget_Wrapper*>(obj);
          //QQuickWidget_Wrapper* wrapper = (QQuickWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QQuickWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QQuickWidget*)wrapper->getWrappedVoid();
          //return getWrapped_QQuickWidget(wrapper);
          return QQuickWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QQuickWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QQuickWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QQuickWidget_Type);
          //return fun.call().toInt()==RJSType::QQuickWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QQuickWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QRadioButton(RJSApi& handler, QRadioButton* v) {
          QRadioButton_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QRadioButton_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QRadioButton: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QRadioButton_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QRadioButton_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QRadioButton('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRadioButton");
          if (cl.isUndefined()) {
              qWarning() << "Class QRadioButton is undefined. Use QRadioButton_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRadioButton('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRadioButton(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QRadioButton(RJSApi& handler, const QRadioButton* v) {
          return RJSHelper::cpp2js_QRadioButton(handler, const_cast<QRadioButton*>(v));
      }

      QRadioButton* RJSHelper::js2cpp_QRadioButton_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QRadioButton: not a QObject";
              return nullptr;
          }
          //QRadioButton_Wrapper* wrapper = getWrapper<QRadioButton_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QRadioButton_Wrapper* wrapper = qobject_cast<QRadioButton_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QRadioButton_Wrapper* wrapper = dynamic_cast<QRadioButton_Wrapper*>(obj);
          //QRadioButton_Wrapper* wrapper = (QRadioButton_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRadioButton: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QRadioButton*)wrapper->getWrappedVoid();
          //return getWrapped_QRadioButton(wrapper);
          return QRadioButton_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QRadioButton_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QRadioButton: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QRadioButton_Type);
          //return fun.call().toInt()==RJSType::QRadioButton_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QRadioButton::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QRegularExpressionValidator(RJSApi& handler, QRegularExpressionValidator* v) {
          QRegularExpressionValidator_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QRegularExpressionValidator_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QRegularExpressionValidator: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QRegularExpressionValidator_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QRegularExpressionValidator_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QRegularExpressionValidator('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRegularExpressionValidator");
          if (cl.isUndefined()) {
              qWarning() << "Class QRegularExpressionValidator is undefined. Use QRegularExpressionValidator_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRegularExpressionValidator('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRegularExpressionValidator(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QRegularExpressionValidator(RJSApi& handler, const QRegularExpressionValidator* v) {
          return RJSHelper::cpp2js_QRegularExpressionValidator(handler, const_cast<QRegularExpressionValidator*>(v));
      }

      QRegularExpressionValidator* RJSHelper::js2cpp_QRegularExpressionValidator_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QRegularExpressionValidator: not a QObject";
              return nullptr;
          }
          //QRegularExpressionValidator_Wrapper* wrapper = getWrapper<QRegularExpressionValidator_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QRegularExpressionValidator_Wrapper* wrapper = qobject_cast<QRegularExpressionValidator_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QRegularExpressionValidator_Wrapper* wrapper = dynamic_cast<QRegularExpressionValidator_Wrapper*>(obj);
          //QRegularExpressionValidator_Wrapper* wrapper = (QRegularExpressionValidator_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRegularExpressionValidator: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QRegularExpressionValidator*)wrapper->getWrappedVoid();
          //return getWrapped_QRegularExpressionValidator(wrapper);
          return QRegularExpressionValidator_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QRegularExpressionValidator_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QRegularExpressionValidator: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QRegularExpressionValidator_Type);
          //return fun.call().toInt()==RJSType::QRegularExpressionValidator_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QRegularExpressionValidator::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QScreen(RJSApi& handler, QScreen* v) {
          QScreen_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QScreen_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QScreen: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QScreen_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QScreen_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QScreen('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QScreen");
          if (cl.isUndefined()) {
              qWarning() << "Class QScreen is undefined. Use QScreen_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QScreen('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QScreen(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QScreen(RJSApi& handler, const QScreen* v) {
          return RJSHelper::cpp2js_QScreen(handler, const_cast<QScreen*>(v));
      }

      QScreen* RJSHelper::js2cpp_QScreen_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QScreen: not a QObject";
              return nullptr;
          }
          //QScreen_Wrapper* wrapper = getWrapper<QScreen_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QScreen_Wrapper* wrapper = qobject_cast<QScreen_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QScreen_Wrapper* wrapper = dynamic_cast<QScreen_Wrapper*>(obj);
          //QScreen_Wrapper* wrapper = (QScreen_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QScreen: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QScreen*)wrapper->getWrappedVoid();
          //return getWrapped_QScreen(wrapper);
          return QScreen_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QScreen_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QScreen: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QScreen_Type);
          //return fun.call().toInt()==RJSType::QScreen_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QScreen::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QScrollArea(RJSApi& handler, QScrollArea* v) {
          QScrollArea_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QScrollArea_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QScrollArea: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QScrollArea_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QScrollArea_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QScrollArea('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QScrollArea");
          if (cl.isUndefined()) {
              qWarning() << "Class QScrollArea is undefined. Use QScrollArea_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QScrollArea('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QScrollArea(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QScrollArea(RJSApi& handler, const QScrollArea* v) {
          return RJSHelper::cpp2js_QScrollArea(handler, const_cast<QScrollArea*>(v));
      }

      QScrollArea* RJSHelper::js2cpp_QScrollArea_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QScrollArea: not a QObject";
              return nullptr;
          }
          //QScrollArea_Wrapper* wrapper = getWrapper<QScrollArea_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QScrollArea_Wrapper* wrapper = qobject_cast<QScrollArea_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QScrollArea_Wrapper* wrapper = dynamic_cast<QScrollArea_Wrapper*>(obj);
          //QScrollArea_Wrapper* wrapper = (QScrollArea_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QScrollArea: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QScrollArea*)wrapper->getWrappedVoid();
          //return getWrapped_QScrollArea(wrapper);
          return QScrollArea_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QScrollArea_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QScrollArea: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QScrollArea_Type);
          //return fun.call().toInt()==RJSType::QScrollArea_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QScrollArea::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QScrollBar(RJSApi& handler, QScrollBar* v) {
          QScrollBar_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QScrollBar_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QScrollBar: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QScrollBar_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QScrollBar_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QScrollBar('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QScrollBar");
          if (cl.isUndefined()) {
              qWarning() << "Class QScrollBar is undefined. Use QScrollBar_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QScrollBar('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QScrollBar(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QScrollBar(RJSApi& handler, const QScrollBar* v) {
          return RJSHelper::cpp2js_QScrollBar(handler, const_cast<QScrollBar*>(v));
      }

      QScrollBar* RJSHelper::js2cpp_QScrollBar_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QScrollBar: not a QObject";
              return nullptr;
          }
          //QScrollBar_Wrapper* wrapper = getWrapper<QScrollBar_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QScrollBar_Wrapper* wrapper = qobject_cast<QScrollBar_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QScrollBar_Wrapper* wrapper = dynamic_cast<QScrollBar_Wrapper*>(obj);
          //QScrollBar_Wrapper* wrapper = (QScrollBar_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QScrollBar: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QScrollBar*)wrapper->getWrappedVoid();
          //return getWrapped_QScrollBar(wrapper);
          return QScrollBar_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QScrollBar_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QScrollBar: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QScrollBar_Type);
          //return fun.call().toInt()==RJSType::QScrollBar_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QScrollBar::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QSettings(RJSApi& handler, QSettings* v) {
          QSettings_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QSettings_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QSettings: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QSettings_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QSettings_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QSettings('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSettings");
          if (cl.isUndefined()) {
              qWarning() << "Class QSettings is undefined. Use QSettings_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSettings('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSettings(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSettings(RJSApi& handler, const QSettings* v) {
          return RJSHelper::cpp2js_QSettings(handler, const_cast<QSettings*>(v));
      }

      QSettings* RJSHelper::js2cpp_QSettings_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSettings: not a QObject";
              return nullptr;
          }
          //QSettings_Wrapper* wrapper = getWrapper<QSettings_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QSettings_Wrapper* wrapper = qobject_cast<QSettings_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSettings_Wrapper* wrapper = dynamic_cast<QSettings_Wrapper*>(obj);
          //QSettings_Wrapper* wrapper = (QSettings_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSettings: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QSettings*)wrapper->getWrappedVoid();
          //return getWrapped_QSettings(wrapper);
          return QSettings_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSettings_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSettings: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QSettings_Type);
          //return fun.call().toInt()==RJSType::QSettings_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QSettings::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QShortcut(RJSApi& handler, QShortcut* v) {
          QShortcut_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QShortcut_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QShortcut: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QShortcut_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QShortcut_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QShortcut('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QShortcut");
          if (cl.isUndefined()) {
              qWarning() << "Class QShortcut is undefined. Use QShortcut_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QShortcut('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QShortcut(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QShortcut(RJSApi& handler, const QShortcut* v) {
          return RJSHelper::cpp2js_QShortcut(handler, const_cast<QShortcut*>(v));
      }

      QShortcut* RJSHelper::js2cpp_QShortcut_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QShortcut: not a QObject";
              return nullptr;
          }
          //QShortcut_Wrapper* wrapper = getWrapper<QShortcut_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QShortcut_Wrapper* wrapper = qobject_cast<QShortcut_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QShortcut_Wrapper* wrapper = dynamic_cast<QShortcut_Wrapper*>(obj);
          //QShortcut_Wrapper* wrapper = (QShortcut_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QShortcut: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QShortcut*)wrapper->getWrappedVoid();
          //return getWrapped_QShortcut(wrapper);
          return QShortcut_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QShortcut_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QShortcut: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QShortcut_Type);
          //return fun.call().toInt()==RJSType::QShortcut_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QShortcut::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QSlider(RJSApi& handler, QSlider* v) {
          QSlider_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QSlider_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QSlider: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QSlider_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QSlider_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QSlider('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSlider");
          if (cl.isUndefined()) {
              qWarning() << "Class QSlider is undefined. Use QSlider_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSlider('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSlider(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSlider(RJSApi& handler, const QSlider* v) {
          return RJSHelper::cpp2js_QSlider(handler, const_cast<QSlider*>(v));
      }

      QSlider* RJSHelper::js2cpp_QSlider_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSlider: not a QObject";
              return nullptr;
          }
          //QSlider_Wrapper* wrapper = getWrapper<QSlider_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QSlider_Wrapper* wrapper = qobject_cast<QSlider_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSlider_Wrapper* wrapper = dynamic_cast<QSlider_Wrapper*>(obj);
          //QSlider_Wrapper* wrapper = (QSlider_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSlider: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QSlider*)wrapper->getWrappedVoid();
          //return getWrapped_QSlider(wrapper);
          return QSlider_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSlider_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSlider: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QSlider_Type);
          //return fun.call().toInt()==RJSType::QSlider_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QSlider::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QSortFilterProxyModel(RJSApi& handler, QSortFilterProxyModel* v) {
          QSortFilterProxyModel_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QSortFilterProxyModel_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QSortFilterProxyModel: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QSortFilterProxyModel_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QSortFilterProxyModel_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QSortFilterProxyModel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSortFilterProxyModel");
          if (cl.isUndefined()) {
              qWarning() << "Class QSortFilterProxyModel is undefined. Use QSortFilterProxyModel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSortFilterProxyModel('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSortFilterProxyModel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSortFilterProxyModel(RJSApi& handler, const QSortFilterProxyModel* v) {
          return RJSHelper::cpp2js_QSortFilterProxyModel(handler, const_cast<QSortFilterProxyModel*>(v));
      }

      QSortFilterProxyModel* RJSHelper::js2cpp_QSortFilterProxyModel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSortFilterProxyModel: not a QObject";
              return nullptr;
          }
          //QSortFilterProxyModel_Wrapper* wrapper = getWrapper<QSortFilterProxyModel_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QSortFilterProxyModel_Wrapper* wrapper = qobject_cast<QSortFilterProxyModel_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSortFilterProxyModel_Wrapper* wrapper = dynamic_cast<QSortFilterProxyModel_Wrapper*>(obj);
          //QSortFilterProxyModel_Wrapper* wrapper = (QSortFilterProxyModel_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSortFilterProxyModel: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QSortFilterProxyModel*)wrapper->getWrappedVoid();
          //return getWrapped_QSortFilterProxyModel(wrapper);
          return QSortFilterProxyModel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSortFilterProxyModel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSortFilterProxyModel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QSortFilterProxyModel_Type);
          //return fun.call().toInt()==RJSType::QSortFilterProxyModel_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QSortFilterProxyModel::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QSpinBox(RJSApi& handler, QSpinBox* v) {
          QSpinBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QSpinBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QSpinBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QSpinBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QSpinBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QSpinBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSpinBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QSpinBox is undefined. Use QSpinBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSpinBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSpinBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSpinBox(RJSApi& handler, const QSpinBox* v) {
          return RJSHelper::cpp2js_QSpinBox(handler, const_cast<QSpinBox*>(v));
      }

      QSpinBox* RJSHelper::js2cpp_QSpinBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSpinBox: not a QObject";
              return nullptr;
          }
          //QSpinBox_Wrapper* wrapper = getWrapper<QSpinBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QSpinBox_Wrapper* wrapper = qobject_cast<QSpinBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSpinBox_Wrapper* wrapper = dynamic_cast<QSpinBox_Wrapper*>(obj);
          //QSpinBox_Wrapper* wrapper = (QSpinBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSpinBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QSpinBox*)wrapper->getWrappedVoid();
          //return getWrapped_QSpinBox(wrapper);
          return QSpinBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSpinBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSpinBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QSpinBox_Type);
          //return fun.call().toInt()==RJSType::QSpinBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QSpinBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QSplashScreen(RJSApi& handler, QSplashScreen* v) {
          QSplashScreen_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QSplashScreen_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QSplashScreen: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QSplashScreen_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QSplashScreen_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QSplashScreen('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSplashScreen");
          if (cl.isUndefined()) {
              qWarning() << "Class QSplashScreen is undefined. Use QSplashScreen_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSplashScreen('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSplashScreen(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSplashScreen(RJSApi& handler, const QSplashScreen* v) {
          return RJSHelper::cpp2js_QSplashScreen(handler, const_cast<QSplashScreen*>(v));
      }

      QSplashScreen* RJSHelper::js2cpp_QSplashScreen_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSplashScreen: not a QObject";
              return nullptr;
          }
          //QSplashScreen_Wrapper* wrapper = getWrapper<QSplashScreen_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QSplashScreen_Wrapper* wrapper = qobject_cast<QSplashScreen_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSplashScreen_Wrapper* wrapper = dynamic_cast<QSplashScreen_Wrapper*>(obj);
          //QSplashScreen_Wrapper* wrapper = (QSplashScreen_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSplashScreen: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QSplashScreen*)wrapper->getWrappedVoid();
          //return getWrapped_QSplashScreen(wrapper);
          return QSplashScreen_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSplashScreen_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSplashScreen: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QSplashScreen_Type);
          //return fun.call().toInt()==RJSType::QSplashScreen_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QSplashScreen::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QSplitter(RJSApi& handler, QSplitter* v) {
          QSplitter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QSplitter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QSplitter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QSplitter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QSplitter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QSplitter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSplitter");
          if (cl.isUndefined()) {
              qWarning() << "Class QSplitter is undefined. Use QSplitter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSplitter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSplitter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSplitter(RJSApi& handler, const QSplitter* v) {
          return RJSHelper::cpp2js_QSplitter(handler, const_cast<QSplitter*>(v));
      }

      QSplitter* RJSHelper::js2cpp_QSplitter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSplitter: not a QObject";
              return nullptr;
          }
          //QSplitter_Wrapper* wrapper = getWrapper<QSplitter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QSplitter_Wrapper* wrapper = qobject_cast<QSplitter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSplitter_Wrapper* wrapper = dynamic_cast<QSplitter_Wrapper*>(obj);
          //QSplitter_Wrapper* wrapper = (QSplitter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSplitter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QSplitter*)wrapper->getWrappedVoid();
          //return getWrapped_QSplitter(wrapper);
          return QSplitter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSplitter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSplitter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QSplitter_Type);
          //return fun.call().toInt()==RJSType::QSplitter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QSplitter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QSplitterHandle(RJSApi& handler, QSplitterHandle* v) {
          QSplitterHandle_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QSplitterHandle_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QSplitterHandle: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QSplitterHandle_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QSplitterHandle_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QSplitterHandle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSplitterHandle");
          if (cl.isUndefined()) {
              qWarning() << "Class QSplitterHandle is undefined. Use QSplitterHandle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSplitterHandle('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSplitterHandle(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSplitterHandle(RJSApi& handler, const QSplitterHandle* v) {
          return RJSHelper::cpp2js_QSplitterHandle(handler, const_cast<QSplitterHandle*>(v));
      }

      QSplitterHandle* RJSHelper::js2cpp_QSplitterHandle_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSplitterHandle: not a QObject";
              return nullptr;
          }
          //QSplitterHandle_Wrapper* wrapper = getWrapper<QSplitterHandle_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QSplitterHandle_Wrapper* wrapper = qobject_cast<QSplitterHandle_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSplitterHandle_Wrapper* wrapper = dynamic_cast<QSplitterHandle_Wrapper*>(obj);
          //QSplitterHandle_Wrapper* wrapper = (QSplitterHandle_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSplitterHandle: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QSplitterHandle*)wrapper->getWrappedVoid();
          //return getWrapped_QSplitterHandle(wrapper);
          return QSplitterHandle_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSplitterHandle_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSplitterHandle: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QSplitterHandle_Type);
          //return fun.call().toInt()==RJSType::QSplitterHandle_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QSplitterHandle::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QStackedLayout(RJSApi& handler, QStackedLayout* v) {
          QStackedLayout_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QStackedLayout_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QStackedLayout: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QStackedLayout_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QStackedLayout_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QStackedLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QStackedLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QStackedLayout is undefined. Use QStackedLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QStackedLayout('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QStackedLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QStackedLayout(RJSApi& handler, const QStackedLayout* v) {
          return RJSHelper::cpp2js_QStackedLayout(handler, const_cast<QStackedLayout*>(v));
      }

      QStackedLayout* RJSHelper::js2cpp_QStackedLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QStackedLayout: not a QObject";
              return nullptr;
          }
          //QStackedLayout_Wrapper* wrapper = getWrapper<QStackedLayout_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QStackedLayout_Wrapper* wrapper = qobject_cast<QStackedLayout_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QStackedLayout_Wrapper* wrapper = dynamic_cast<QStackedLayout_Wrapper*>(obj);
          //QStackedLayout_Wrapper* wrapper = (QStackedLayout_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QStackedLayout: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QStackedLayout*)wrapper->getWrappedVoid();
          //return getWrapped_QStackedLayout(wrapper);
          return QStackedLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QStackedLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QStackedLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QStackedLayout_Type);
          //return fun.call().toInt()==RJSType::QStackedLayout_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QStackedLayout::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QStackedWidget(RJSApi& handler, QStackedWidget* v) {
          QStackedWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QStackedWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QStackedWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QStackedWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QStackedWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QStackedWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QStackedWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class QStackedWidget is undefined. Use QStackedWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QStackedWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QStackedWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QStackedWidget(RJSApi& handler, const QStackedWidget* v) {
          return RJSHelper::cpp2js_QStackedWidget(handler, const_cast<QStackedWidget*>(v));
      }

      QStackedWidget* RJSHelper::js2cpp_QStackedWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QStackedWidget: not a QObject";
              return nullptr;
          }
          //QStackedWidget_Wrapper* wrapper = getWrapper<QStackedWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QStackedWidget_Wrapper* wrapper = qobject_cast<QStackedWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QStackedWidget_Wrapper* wrapper = dynamic_cast<QStackedWidget_Wrapper*>(obj);
          //QStackedWidget_Wrapper* wrapper = (QStackedWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QStackedWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QStackedWidget*)wrapper->getWrappedVoid();
          //return getWrapped_QStackedWidget(wrapper);
          return QStackedWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QStackedWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QStackedWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QStackedWidget_Type);
          //return fun.call().toInt()==RJSType::QStackedWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QStackedWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QStandardItemModel(RJSApi& handler, QStandardItemModel* v) {
          QStandardItemModel_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QStandardItemModel_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QStandardItemModel: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QStandardItemModel_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QStandardItemModel_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QStandardItemModel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QStandardItemModel");
          if (cl.isUndefined()) {
              qWarning() << "Class QStandardItemModel is undefined. Use QStandardItemModel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QStandardItemModel('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QStandardItemModel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QStandardItemModel(RJSApi& handler, const QStandardItemModel* v) {
          return RJSHelper::cpp2js_QStandardItemModel(handler, const_cast<QStandardItemModel*>(v));
      }

      QStandardItemModel* RJSHelper::js2cpp_QStandardItemModel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QStandardItemModel: not a QObject";
              return nullptr;
          }
          //QStandardItemModel_Wrapper* wrapper = getWrapper<QStandardItemModel_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QStandardItemModel_Wrapper* wrapper = qobject_cast<QStandardItemModel_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QStandardItemModel_Wrapper* wrapper = dynamic_cast<QStandardItemModel_Wrapper*>(obj);
          //QStandardItemModel_Wrapper* wrapper = (QStandardItemModel_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QStandardItemModel: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QStandardItemModel*)wrapper->getWrappedVoid();
          //return getWrapped_QStandardItemModel(wrapper);
          return QStandardItemModel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QStandardItemModel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QStandardItemModel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QStandardItemModel_Type);
          //return fun.call().toInt()==RJSType::QStandardItemModel_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QStandardItemModel::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QStatusBar(RJSApi& handler, QStatusBar* v) {
          QStatusBar_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QStatusBar_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QStatusBar: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QStatusBar_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QStatusBar_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QStatusBar('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QStatusBar");
          if (cl.isUndefined()) {
              qWarning() << "Class QStatusBar is undefined. Use QStatusBar_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QStatusBar('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QStatusBar(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QStatusBar(RJSApi& handler, const QStatusBar* v) {
          return RJSHelper::cpp2js_QStatusBar(handler, const_cast<QStatusBar*>(v));
      }

      QStatusBar* RJSHelper::js2cpp_QStatusBar_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QStatusBar: not a QObject";
              return nullptr;
          }
          //QStatusBar_Wrapper* wrapper = getWrapper<QStatusBar_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QStatusBar_Wrapper* wrapper = qobject_cast<QStatusBar_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QStatusBar_Wrapper* wrapper = dynamic_cast<QStatusBar_Wrapper*>(obj);
          //QStatusBar_Wrapper* wrapper = (QStatusBar_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QStatusBar: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QStatusBar*)wrapper->getWrappedVoid();
          //return getWrapped_QStatusBar(wrapper);
          return QStatusBar_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QStatusBar_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QStatusBar: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QStatusBar_Type);
          //return fun.call().toInt()==RJSType::QStatusBar_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QStatusBar::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QSvgRenderer(RJSApi& handler, QSvgRenderer* v) {
          QSvgRenderer_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QSvgRenderer_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QSvgRenderer: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QSvgRenderer_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QSvgRenderer_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QSvgRenderer('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSvgRenderer");
          if (cl.isUndefined()) {
              qWarning() << "Class QSvgRenderer is undefined. Use QSvgRenderer_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSvgRenderer('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSvgRenderer(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSvgRenderer(RJSApi& handler, const QSvgRenderer* v) {
          return RJSHelper::cpp2js_QSvgRenderer(handler, const_cast<QSvgRenderer*>(v));
      }

      QSvgRenderer* RJSHelper::js2cpp_QSvgRenderer_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSvgRenderer: not a QObject";
              return nullptr;
          }
          //QSvgRenderer_Wrapper* wrapper = getWrapper<QSvgRenderer_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QSvgRenderer_Wrapper* wrapper = qobject_cast<QSvgRenderer_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSvgRenderer_Wrapper* wrapper = dynamic_cast<QSvgRenderer_Wrapper*>(obj);
          //QSvgRenderer_Wrapper* wrapper = (QSvgRenderer_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSvgRenderer: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QSvgRenderer*)wrapper->getWrappedVoid();
          //return getWrapped_QSvgRenderer(wrapper);
          return QSvgRenderer_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSvgRenderer_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSvgRenderer: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QSvgRenderer_Type);
          //return fun.call().toInt()==RJSType::QSvgRenderer_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QSvgRenderer::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTabBar(RJSApi& handler, QTabBar* v) {
          QTabBar_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTabBar_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTabBar: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTabBar_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTabBar_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTabBar('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTabBar");
          if (cl.isUndefined()) {
              qWarning() << "Class QTabBar is undefined. Use QTabBar_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTabBar('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTabBar(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTabBar(RJSApi& handler, const QTabBar* v) {
          return RJSHelper::cpp2js_QTabBar(handler, const_cast<QTabBar*>(v));
      }

      QTabBar* RJSHelper::js2cpp_QTabBar_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTabBar: not a QObject";
              return nullptr;
          }
          //QTabBar_Wrapper* wrapper = getWrapper<QTabBar_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTabBar_Wrapper* wrapper = qobject_cast<QTabBar_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTabBar_Wrapper* wrapper = dynamic_cast<QTabBar_Wrapper*>(obj);
          //QTabBar_Wrapper* wrapper = (QTabBar_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTabBar: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTabBar*)wrapper->getWrappedVoid();
          //return getWrapped_QTabBar(wrapper);
          return QTabBar_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTabBar_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTabBar: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTabBar_Type);
          //return fun.call().toInt()==RJSType::QTabBar_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTabBar::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTabWidget(RJSApi& handler, QTabWidget* v) {
          QTabWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTabWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTabWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTabWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTabWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTabWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTabWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class QTabWidget is undefined. Use QTabWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTabWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTabWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTabWidget(RJSApi& handler, const QTabWidget* v) {
          return RJSHelper::cpp2js_QTabWidget(handler, const_cast<QTabWidget*>(v));
      }

      QTabWidget* RJSHelper::js2cpp_QTabWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTabWidget: not a QObject";
              return nullptr;
          }
          //QTabWidget_Wrapper* wrapper = getWrapper<QTabWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTabWidget_Wrapper* wrapper = qobject_cast<QTabWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTabWidget_Wrapper* wrapper = dynamic_cast<QTabWidget_Wrapper*>(obj);
          //QTabWidget_Wrapper* wrapper = (QTabWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTabWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTabWidget*)wrapper->getWrappedVoid();
          //return getWrapped_QTabWidget(wrapper);
          return QTabWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTabWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTabWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTabWidget_Type);
          //return fun.call().toInt()==RJSType::QTabWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTabWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTableView(RJSApi& handler, QTableView* v) {
          
            // downcast to QTableWidget:
            {
                QTableWidget* o = qobject_cast<QTableWidget*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QTableWidget(handler, o);
                }
            }
          QTableView_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTableView_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTableView: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTableView_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTableView_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTableView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTableView");
          if (cl.isUndefined()) {
              qWarning() << "Class QTableView is undefined. Use QTableView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTableView('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTableView(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTableView(RJSApi& handler, const QTableView* v) {
          return RJSHelper::cpp2js_QTableView(handler, const_cast<QTableView*>(v));
      }

      QTableView* RJSHelper::js2cpp_QTableView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTableView: not a QObject";
              return nullptr;
          }
          //QTableView_Wrapper* wrapper = getWrapper<QTableView_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTableView_Wrapper* wrapper = qobject_cast<QTableView_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTableView_Wrapper* wrapper = dynamic_cast<QTableView_Wrapper*>(obj);
          //QTableView_Wrapper* wrapper = (QTableView_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTableView: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTableView*)wrapper->getWrappedVoid();
          //return getWrapped_QTableView(wrapper);
          return QTableView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTableView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTableView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTableView_Type);
          //return fun.call().toInt()==RJSType::QTableView_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTableView::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTableWidget(RJSApi& handler, QTableWidget* v) {
          QTableWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTableWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTableWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTableWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTableWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTableWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTableWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class QTableWidget is undefined. Use QTableWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTableWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTableWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTableWidget(RJSApi& handler, const QTableWidget* v) {
          return RJSHelper::cpp2js_QTableWidget(handler, const_cast<QTableWidget*>(v));
      }

      QTableWidget* RJSHelper::js2cpp_QTableWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTableWidget: not a QObject";
              return nullptr;
          }
          //QTableWidget_Wrapper* wrapper = getWrapper<QTableWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTableWidget_Wrapper* wrapper = qobject_cast<QTableWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTableWidget_Wrapper* wrapper = dynamic_cast<QTableWidget_Wrapper*>(obj);
          //QTableWidget_Wrapper* wrapper = (QTableWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTableWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTableWidget*)wrapper->getWrappedVoid();
          //return getWrapped_QTableWidget(wrapper);
          return QTableWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTableWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTableWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTableWidget_Type);
          //return fun.call().toInt()==RJSType::QTableWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTableWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTextBrowser(RJSApi& handler, QTextBrowser* v) {
          
            // downcast to types derrived from QTextBrowser but defined in other modules:
            for (int i=0; i<downcasters_QTextBrowser.length(); i++) {
                QJSValue dc = downcasters_QTextBrowser[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QTextBrowser_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTextBrowser_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTextBrowser: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTextBrowser_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTextBrowser_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTextBrowser('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextBrowser");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextBrowser is undefined. Use QTextBrowser_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextBrowser('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextBrowser(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextBrowser(RJSApi& handler, const QTextBrowser* v) {
          return RJSHelper::cpp2js_QTextBrowser(handler, const_cast<QTextBrowser*>(v));
      }

      QTextBrowser* RJSHelper::js2cpp_QTextBrowser_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextBrowser: not a QObject";
              return nullptr;
          }
          //QTextBrowser_Wrapper* wrapper = getWrapper<QTextBrowser_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTextBrowser_Wrapper* wrapper = qobject_cast<QTextBrowser_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTextBrowser_Wrapper* wrapper = dynamic_cast<QTextBrowser_Wrapper*>(obj);
          //QTextBrowser_Wrapper* wrapper = (QTextBrowser_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextBrowser: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTextBrowser*)wrapper->getWrappedVoid();
          //return getWrapped_QTextBrowser(wrapper);
          return QTextBrowser_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTextBrowser_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextBrowser: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTextBrowser_Type);
          //return fun.call().toInt()==RJSType::QTextBrowser_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextBrowser::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTextDocument(RJSApi& handler, QTextDocument* v) {
          QTextDocument_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTextDocument_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTextDocument: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTextDocument_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTextDocument_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTextDocument('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextDocument");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextDocument is undefined. Use QTextDocument_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextDocument('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextDocument(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextDocument(RJSApi& handler, const QTextDocument* v) {
          return RJSHelper::cpp2js_QTextDocument(handler, const_cast<QTextDocument*>(v));
      }

      QTextDocument* RJSHelper::js2cpp_QTextDocument_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextDocument: not a QObject";
              return nullptr;
          }
          //QTextDocument_Wrapper* wrapper = getWrapper<QTextDocument_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTextDocument_Wrapper* wrapper = qobject_cast<QTextDocument_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTextDocument_Wrapper* wrapper = dynamic_cast<QTextDocument_Wrapper*>(obj);
          //QTextDocument_Wrapper* wrapper = (QTextDocument_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextDocument: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTextDocument*)wrapper->getWrappedVoid();
          //return getWrapped_QTextDocument(wrapper);
          return QTextDocument_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTextDocument_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextDocument: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTextDocument_Type);
          //return fun.call().toInt()==RJSType::QTextDocument_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextDocument::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTextEdit(RJSApi& handler, QTextEdit* v) {
          
            // downcast to QTextBrowser:
            {
                QTextBrowser* o = qobject_cast<QTextBrowser*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QTextBrowser(handler, o);
                }
            }
          QTextEdit_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTextEdit_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTextEdit: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTextEdit_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTextEdit_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTextEdit('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextEdit");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextEdit is undefined. Use QTextEdit_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextEdit('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextEdit(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextEdit(RJSApi& handler, const QTextEdit* v) {
          return RJSHelper::cpp2js_QTextEdit(handler, const_cast<QTextEdit*>(v));
      }

      QTextEdit* RJSHelper::js2cpp_QTextEdit_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextEdit: not a QObject";
              return nullptr;
          }
          //QTextEdit_Wrapper* wrapper = getWrapper<QTextEdit_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTextEdit_Wrapper* wrapper = qobject_cast<QTextEdit_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTextEdit_Wrapper* wrapper = dynamic_cast<QTextEdit_Wrapper*>(obj);
          //QTextEdit_Wrapper* wrapper = (QTextEdit_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextEdit: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTextEdit*)wrapper->getWrappedVoid();
          //return getWrapped_QTextEdit(wrapper);
          return QTextEdit_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTextEdit_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextEdit: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTextEdit_Type);
          //return fun.call().toInt()==RJSType::QTextEdit_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextEdit::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTimer(RJSApi& handler, QTimer* v) {
          QTimer_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTimer_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTimer: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTimer_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTimer_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTimer('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTimer");
          if (cl.isUndefined()) {
              qWarning() << "Class QTimer is undefined. Use QTimer_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTimer('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTimer(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTimer(RJSApi& handler, const QTimer* v) {
          return RJSHelper::cpp2js_QTimer(handler, const_cast<QTimer*>(v));
      }

      QTimer* RJSHelper::js2cpp_QTimer_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTimer: not a QObject";
              return nullptr;
          }
          //QTimer_Wrapper* wrapper = getWrapper<QTimer_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTimer_Wrapper* wrapper = qobject_cast<QTimer_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTimer_Wrapper* wrapper = dynamic_cast<QTimer_Wrapper*>(obj);
          //QTimer_Wrapper* wrapper = (QTimer_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTimer: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTimer*)wrapper->getWrappedVoid();
          //return getWrapped_QTimer(wrapper);
          return QTimer_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTimer_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTimer: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTimer_Type);
          //return fun.call().toInt()==RJSType::QTimer_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTimer::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QToolBar(RJSApi& handler, QToolBar* v) {
          
            // downcast to types derrived from QToolBar but defined in other modules:
            for (int i=0; i<downcasters_QToolBar.length(); i++) {
                QJSValue dc = downcasters_QToolBar[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QToolBar_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QToolBar_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QToolBar: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QToolBar_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QToolBar_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QToolBar('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QToolBar");
          if (cl.isUndefined()) {
              qWarning() << "Class QToolBar is undefined. Use QToolBar_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QToolBar('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QToolBar(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QToolBar(RJSApi& handler, const QToolBar* v) {
          return RJSHelper::cpp2js_QToolBar(handler, const_cast<QToolBar*>(v));
      }

      QToolBar* RJSHelper::js2cpp_QToolBar_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QToolBar: not a QObject";
              return nullptr;
          }
          //QToolBar_Wrapper* wrapper = getWrapper<QToolBar_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QToolBar_Wrapper* wrapper = qobject_cast<QToolBar_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QToolBar_Wrapper* wrapper = dynamic_cast<QToolBar_Wrapper*>(obj);
          //QToolBar_Wrapper* wrapper = (QToolBar_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QToolBar: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QToolBar*)wrapper->getWrappedVoid();
          //return getWrapped_QToolBar(wrapper);
          return QToolBar_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QToolBar_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QToolBar: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QToolBar_Type);
          //return fun.call().toInt()==RJSType::QToolBar_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QToolBar::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QToolButton(RJSApi& handler, QToolButton* v) {
          
            // downcast to types derrived from QToolButton but defined in other modules:
            for (int i=0; i<downcasters_QToolButton.length(); i++) {
                QJSValue dc = downcasters_QToolButton[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QToolButton_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QToolButton_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QToolButton: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QToolButton_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QToolButton_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QToolButton('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QToolButton");
          if (cl.isUndefined()) {
              qWarning() << "Class QToolButton is undefined. Use QToolButton_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QToolButton('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QToolButton(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QToolButton(RJSApi& handler, const QToolButton* v) {
          return RJSHelper::cpp2js_QToolButton(handler, const_cast<QToolButton*>(v));
      }

      QToolButton* RJSHelper::js2cpp_QToolButton_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QToolButton: not a QObject";
              return nullptr;
          }
          //QToolButton_Wrapper* wrapper = getWrapper<QToolButton_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QToolButton_Wrapper* wrapper = qobject_cast<QToolButton_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QToolButton_Wrapper* wrapper = dynamic_cast<QToolButton_Wrapper*>(obj);
          //QToolButton_Wrapper* wrapper = (QToolButton_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QToolButton: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QToolButton*)wrapper->getWrappedVoid();
          //return getWrapped_QToolButton(wrapper);
          return QToolButton_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QToolButton_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QToolButton: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QToolButton_Type);
          //return fun.call().toInt()==RJSType::QToolButton_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QToolButton::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTranslator(RJSApi& handler, QTranslator* v) {
          QTranslator_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTranslator_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTranslator: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTranslator_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTranslator_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTranslator('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTranslator");
          if (cl.isUndefined()) {
              qWarning() << "Class QTranslator is undefined. Use QTranslator_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTranslator('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTranslator(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTranslator(RJSApi& handler, const QTranslator* v) {
          return RJSHelper::cpp2js_QTranslator(handler, const_cast<QTranslator*>(v));
      }

      QTranslator* RJSHelper::js2cpp_QTranslator_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTranslator: not a QObject";
              return nullptr;
          }
          //QTranslator_Wrapper* wrapper = getWrapper<QTranslator_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTranslator_Wrapper* wrapper = qobject_cast<QTranslator_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTranslator_Wrapper* wrapper = dynamic_cast<QTranslator_Wrapper*>(obj);
          //QTranslator_Wrapper* wrapper = (QTranslator_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTranslator: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTranslator*)wrapper->getWrappedVoid();
          //return getWrapped_QTranslator(wrapper);
          return QTranslator_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTranslator_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTranslator: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTranslator_Type);
          //return fun.call().toInt()==RJSType::QTranslator_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTranslator::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTreeView(RJSApi& handler, QTreeView* v) {
          
            // downcast to QTreeWidget:
            {
                QTreeWidget* o = qobject_cast<QTreeWidget*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QTreeWidget(handler, o);
                }
            }
          QTreeView_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTreeView_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTreeView: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTreeView_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTreeView_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTreeView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTreeView");
          if (cl.isUndefined()) {
              qWarning() << "Class QTreeView is undefined. Use QTreeView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTreeView('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTreeView(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTreeView(RJSApi& handler, const QTreeView* v) {
          return RJSHelper::cpp2js_QTreeView(handler, const_cast<QTreeView*>(v));
      }

      QTreeView* RJSHelper::js2cpp_QTreeView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTreeView: not a QObject";
              return nullptr;
          }
          //QTreeView_Wrapper* wrapper = getWrapper<QTreeView_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTreeView_Wrapper* wrapper = qobject_cast<QTreeView_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTreeView_Wrapper* wrapper = dynamic_cast<QTreeView_Wrapper*>(obj);
          //QTreeView_Wrapper* wrapper = (QTreeView_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTreeView: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTreeView*)wrapper->getWrappedVoid();
          //return getWrapped_QTreeView(wrapper);
          return QTreeView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTreeView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTreeView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTreeView_Type);
          //return fun.call().toInt()==RJSType::QTreeView_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTreeView::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTreeWidget(RJSApi& handler, QTreeWidget* v) {
          
            // downcast to types derrived from QTreeWidget but defined in other modules:
            for (int i=0; i<downcasters_QTreeWidget.length(); i++) {
                QJSValue dc = downcasters_QTreeWidget[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QTreeWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTreeWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTreeWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTreeWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTreeWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTreeWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTreeWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class QTreeWidget is undefined. Use QTreeWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTreeWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTreeWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTreeWidget(RJSApi& handler, const QTreeWidget* v) {
          return RJSHelper::cpp2js_QTreeWidget(handler, const_cast<QTreeWidget*>(v));
      }

      QTreeWidget* RJSHelper::js2cpp_QTreeWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTreeWidget: not a QObject";
              return nullptr;
          }
          //QTreeWidget_Wrapper* wrapper = getWrapper<QTreeWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTreeWidget_Wrapper* wrapper = qobject_cast<QTreeWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTreeWidget_Wrapper* wrapper = dynamic_cast<QTreeWidget_Wrapper*>(obj);
          //QTreeWidget_Wrapper* wrapper = (QTreeWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTreeWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTreeWidget*)wrapper->getWrappedVoid();
          //return getWrapped_QTreeWidget(wrapper);
          return QTreeWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTreeWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTreeWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTreeWidget_Type);
          //return fun.call().toInt()==RJSType::QTreeWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTreeWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QVBoxLayout(RJSApi& handler, QVBoxLayout* v) {
          QVBoxLayout_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QVBoxLayout_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QVBoxLayout: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QVBoxLayout_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QVBoxLayout_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QVBoxLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QVBoxLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QVBoxLayout is undefined. Use QVBoxLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QVBoxLayout('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QVBoxLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QVBoxLayout(RJSApi& handler, const QVBoxLayout* v) {
          return RJSHelper::cpp2js_QVBoxLayout(handler, const_cast<QVBoxLayout*>(v));
      }

      QVBoxLayout* RJSHelper::js2cpp_QVBoxLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QVBoxLayout: not a QObject";
              return nullptr;
          }
          //QVBoxLayout_Wrapper* wrapper = getWrapper<QVBoxLayout_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QVBoxLayout_Wrapper* wrapper = qobject_cast<QVBoxLayout_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QVBoxLayout_Wrapper* wrapper = dynamic_cast<QVBoxLayout_Wrapper*>(obj);
          //QVBoxLayout_Wrapper* wrapper = (QVBoxLayout_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QVBoxLayout: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QVBoxLayout*)wrapper->getWrappedVoid();
          //return getWrapped_QVBoxLayout(wrapper);
          return QVBoxLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QVBoxLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QVBoxLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QVBoxLayout_Type);
          //return fun.call().toInt()==RJSType::QVBoxLayout_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QVBoxLayout::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QValidator(RJSApi& handler, QValidator* v) {
          
            // downcast to QIntValidator:
            {
                QIntValidator* o = qobject_cast<QIntValidator*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QIntValidator(handler, o);
                }
            }
          
            // downcast to QDoubleValidator:
            {
                QDoubleValidator* o = qobject_cast<QDoubleValidator*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QDoubleValidator(handler, o);
                }
            }
          
            // downcast to QRegularExpressionValidator:
            {
                QRegularExpressionValidator* o = qobject_cast<QRegularExpressionValidator*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QRegularExpressionValidator(handler, o);
                }
            }
          QValidator_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QValidator_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QValidator: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QValidator_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QValidator_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QValidator('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QValidator");
          if (cl.isUndefined()) {
              qWarning() << "Class QValidator is undefined. Use QValidator_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QValidator('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QValidator(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QValidator(RJSApi& handler, const QValidator* v) {
          return RJSHelper::cpp2js_QValidator(handler, const_cast<QValidator*>(v));
      }

      QValidator* RJSHelper::js2cpp_QValidator_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QValidator: not a QObject";
              return nullptr;
          }
          //QValidator_Wrapper* wrapper = getWrapper<QValidator_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QValidator_Wrapper* wrapper = qobject_cast<QValidator_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QValidator_Wrapper* wrapper = dynamic_cast<QValidator_Wrapper*>(obj);
          //QValidator_Wrapper* wrapper = (QValidator_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QValidator: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QValidator*)wrapper->getWrappedVoid();
          //return getWrapped_QValidator(wrapper);
          return QValidator_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QValidator_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QValidator: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QValidator_Type);
          //return fun.call().toInt()==RJSType::QValidator_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QValidator::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QWidgetAction(RJSApi& handler, QWidgetAction* v) {
          QWidgetAction_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QWidgetAction_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QWidgetAction: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QWidgetAction_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QWidgetAction_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QWidgetAction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QWidgetAction");
          if (cl.isUndefined()) {
              qWarning() << "Class QWidgetAction is undefined. Use QWidgetAction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QWidgetAction('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QWidgetAction(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QWidgetAction(RJSApi& handler, const QWidgetAction* v) {
          return RJSHelper::cpp2js_QWidgetAction(handler, const_cast<QWidgetAction*>(v));
      }

      QWidgetAction* RJSHelper::js2cpp_QWidgetAction_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QWidgetAction: not a QObject";
              return nullptr;
          }
          //QWidgetAction_Wrapper* wrapper = getWrapper<QWidgetAction_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QWidgetAction_Wrapper* wrapper = qobject_cast<QWidgetAction_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QWidgetAction_Wrapper* wrapper = dynamic_cast<QWidgetAction_Wrapper*>(obj);
          //QWidgetAction_Wrapper* wrapper = (QWidgetAction_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QWidgetAction: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QWidgetAction*)wrapper->getWrappedVoid();
          //return getWrapped_QWidgetAction(wrapper);
          return QWidgetAction_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QWidgetAction_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QWidgetAction: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QWidgetAction_Type);
          //return fun.call().toInt()==RJSType::QWidgetAction_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QWidgetAction::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QWindow(RJSApi& handler, QWindow* v) {
          
            // downcast to QQuickView:
            {
                QQuickView* o = qobject_cast<QQuickView*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QQuickView(handler, o);
                }
            }
          QWindow_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QWindow_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QWindow: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QWindow_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QWindow_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QWindow('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QWindow");
          if (cl.isUndefined()) {
              qWarning() << "Class QWindow is undefined. Use QWindow_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QWindow('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QWindow(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QWindow(RJSApi& handler, const QWindow* v) {
          return RJSHelper::cpp2js_QWindow(handler, const_cast<QWindow*>(v));
      }

      QWindow* RJSHelper::js2cpp_QWindow_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QWindow: not a QObject";
              return nullptr;
          }
          //QWindow_Wrapper* wrapper = getWrapper<QWindow_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QWindow_Wrapper* wrapper = qobject_cast<QWindow_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QWindow_Wrapper* wrapper = dynamic_cast<QWindow_Wrapper*>(obj);
          //QWindow_Wrapper* wrapper = (QWindow_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QWindow: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QWindow*)wrapper->getWrappedVoid();
          //return getWrapped_QWindow(wrapper);
          return QWindow_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QWindow_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QWindow: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QWindow_Type);
          //return fun.call().toInt()==RJSType::QWindow_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QWindow::getIdStatic())).toBool();
      }

    
  // ------------
  // QList types:
  // ------------
  
      QJSValue RJSHelper::cpp2js_QFileInfoList(RJSApi& handler, const QFileInfoList& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QFileInfo(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QFileInfoList RJSHelper::js2cpp_QFileInfoList(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QFileInfoList>(v);
          QFileInfoList ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QFileInfoList: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QFileInfo(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QFileInfoList(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QByteArray(RJSApi& handler, const QList<QByteArray>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QByteArray(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QByteArray> RJSHelper::js2cpp_QList_QByteArray(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QByteArray>>(v);
          QList<QByteArray> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QByteArray: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QByteArray(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QByteArray(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QChar(RJSApi& handler, const QList<QChar>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QChar(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QChar> RJSHelper::js2cpp_QList_QChar(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QChar>>(v);
          QList<QChar> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QChar: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QChar(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QChar(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QFontDatabase_WritingSystem(RJSApi& handler, const QList<QFontDatabase::WritingSystem>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QFontDatabase_WritingSystem(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QFontDatabase::WritingSystem> RJSHelper::js2cpp_QList_QFontDatabase_WritingSystem(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QFontDatabase::WritingSystem>>(v);
          QList<QFontDatabase::WritingSystem> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QFontDatabase_WritingSystem: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QFontDatabase_WritingSystem(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QFontDatabase_WritingSystem(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QKeySequence(RJSApi& handler, const QList<QKeySequence>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QKeySequence(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QKeySequence> RJSHelper::js2cpp_QList_QKeySequence(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QKeySequence>>(v);
          QList<QKeySequence> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QKeySequence: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QKeySequence(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QKeySequence(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QLine(RJSApi& handler, const QList<QLine>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QLine(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QLine> RJSHelper::js2cpp_QList_QLine(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QLine>>(v);
          QList<QLine> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QLine: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QLine(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QLine(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QLineF(RJSApi& handler, const QList<QLineF>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QLineF(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QLineF> RJSHelper::js2cpp_QList_QLineF(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QLineF>>(v);
          QList<QLineF> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QLineF: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QLineF(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QLineF(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QLocale(RJSApi& handler, const QList<QLocale>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QLocale(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QLocale> RJSHelper::js2cpp_QList_QLocale(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QLocale>>(v);
          QList<QLocale> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QLocale: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QLocale(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QLocale(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QLocale_Country(RJSApi& handler, const QList<QLocale::Country>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QLocale_Country(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QLocale::Country> RJSHelper::js2cpp_QList_QLocale_Country(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QLocale::Country>>(v);
          QList<QLocale::Country> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QLocale_Country: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QLocale_Country(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QLocale_Country(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QPageSize(RJSApi& handler, const QList<QPageSize>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QPageSize(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QPageSize> RJSHelper::js2cpp_QList_QPageSize(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QPageSize>>(v);
          QList<QPageSize> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QPageSize: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QPageSize(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QPageSize(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QPoint(RJSApi& handler, const QList<QPoint>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QPoint(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QPoint> RJSHelper::js2cpp_QList_QPoint(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QPoint>>(v);
          QList<QPoint> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QPoint: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QPoint(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QPoint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QPointF(RJSApi& handler, const QList<QPointF>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QPointF(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QPointF> RJSHelper::js2cpp_QList_QPointF(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QPointF>>(v);
          QList<QPointF> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QPointF: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QPointF(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QPointF(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QPolygonF(RJSApi& handler, const QList<QPolygonF>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QPolygonF(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QPolygonF> RJSHelper::js2cpp_QList_QPolygonF(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QPolygonF>>(v);
          QList<QPolygonF> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QPolygonF: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QPolygonF(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QPolygonF(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QPrinter_ColorMode(RJSApi& handler, const QList<QPrinter::ColorMode>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QPrinter_ColorMode(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QPrinter::ColorMode> RJSHelper::js2cpp_QList_QPrinter_ColorMode(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QPrinter::ColorMode>>(v);
          QList<QPrinter::ColorMode> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QPrinter_ColorMode: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QPrinter_ColorMode(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QPrinter_ColorMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QPrinter_DuplexMode(RJSApi& handler, const QList<QPrinter::DuplexMode>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QPrinter_DuplexMode(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QPrinter::DuplexMode> RJSHelper::js2cpp_QList_QPrinter_DuplexMode(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QPrinter::DuplexMode>>(v);
          QList<QPrinter::DuplexMode> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QPrinter_DuplexMode: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QPrinter_DuplexMode(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QPrinter_DuplexMode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QPrinter_PaperSource(RJSApi& handler, const QList<QPrinter::PaperSource>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QPrinter_PaperSource(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QPrinter::PaperSource> RJSHelper::js2cpp_QList_QPrinter_PaperSource(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QPrinter::PaperSource>>(v);
          QList<QPrinter::PaperSource> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QPrinter_PaperSource: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QPrinter_PaperSource(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QPrinter_PaperSource(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QPrinterInfo(RJSApi& handler, const QList<QPrinterInfo>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QPrinterInfo(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QPrinterInfo> RJSHelper::js2cpp_QList_QPrinterInfo(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QPrinterInfo>>(v);
          QList<QPrinterInfo> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QPrinterInfo: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QPrinterInfo(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QPrinterInfo(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QRect(RJSApi& handler, const QList<QRect>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QRect(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QRect> RJSHelper::js2cpp_QList_QRect(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QRect>>(v);
          QList<QRect> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QRect: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QRect(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QRect(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QRectF(RJSApi& handler, const QList<QRectF>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QRectF(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QRectF> RJSHelper::js2cpp_QList_QRectF(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QRectF>>(v);
          QList<QRectF> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QRectF: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QRectF(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QRectF(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QSize(RJSApi& handler, const QList<QSize>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QSize(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QSize> RJSHelper::js2cpp_QList_QSize(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QSize>>(v);
          QList<QSize> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QSize: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QSize(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QSize(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QString(RJSApi& handler, const QList<QString>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QString(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QString> RJSHelper::js2cpp_QList_QString(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QString>>(v);
          QList<QString> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QString: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QString(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QString(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QTextFormat(RJSApi& handler, const QList<QTextFormat>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QTextFormat(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QTextFormat> RJSHelper::js2cpp_QList_QTextFormat(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QTextFormat>>(v);
          QList<QTextFormat> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QTextFormat: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QTextFormat(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QTextFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QTextLength(RJSApi& handler, const QList<QTextLength>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QTextLength(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QTextLength> RJSHelper::js2cpp_QList_QTextLength(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QTextLength>>(v);
          QList<QTextLength> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QTextLength: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QTextLength(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QTextLength(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QUrl(RJSApi& handler, const QList<QUrl>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QUrl(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QUrl> RJSHelper::js2cpp_QList_QUrl(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QUrl>>(v);
          QList<QUrl> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QUrl: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QUrl(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QUrl(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QVariant(RJSApi& handler, const QList<QVariant>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QVariant(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QVariant> RJSHelper::js2cpp_QList_QVariant(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<QVariant>>(v);
          QList<QVariant> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_QVariant: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QVariant(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_QVariant(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_Qt_DayOfWeek(RJSApi& handler, const QList<Qt::DayOfWeek>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_Qt_DayOfWeek(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<Qt::DayOfWeek> RJSHelper::js2cpp_QList_Qt_DayOfWeek(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<Qt::DayOfWeek>>(v);
          QList<Qt::DayOfWeek> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_Qt_DayOfWeek: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_Qt_DayOfWeek(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_Qt_DayOfWeek(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_bool(RJSApi& handler, const QList<bool>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_bool(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<bool> RJSHelper::js2cpp_QList_bool(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<bool>>(v);
          QList<bool> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_bool: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_bool(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_bool(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_double(RJSApi& handler, const QList<double>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_double(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<double> RJSHelper::js2cpp_QList_double(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<double>>(v);
          QList<double> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_double: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_double(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_double(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_int(RJSApi& handler, const QList<int>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_int(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<int> RJSHelper::js2cpp_QList_int(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<int>>(v);
          QList<int> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_int: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_int(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_int(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_qreal(RJSApi& handler, const QList<qreal>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_qreal(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<qreal> RJSHelper::js2cpp_QList_qreal(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QList<qreal>>(v);
          QList<qreal> ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QList_qreal: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_qreal(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QList_qreal(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QModelIndexList(RJSApi& handler, const QModelIndexList& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QModelIndex(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QModelIndexList RJSHelper::js2cpp_QModelIndexList(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QModelIndexList>(v);
          QModelIndexList ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QModelIndexList: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QModelIndex(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QModelIndexList(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QStringList(RJSApi& handler, const QStringList& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QString(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QStringList RJSHelper::js2cpp_QStringList(RJSApi& handler, const QJSValue& v) {
          //return engine->fromScriptValue<QStringList>(v);
          QStringList ret;

          if (!v.isArray()) {
              qWarning() << "js2cpp_QStringList: value is not an array";
              return ret;
          }

          const int length = v.property("length").toInt();
          for (int i=0; i<length; ++i) {
              ret.append(js2cpp_QString(handler, v.property(i)));
          }

          return ret;
      }

      bool RJSHelper::is_QStringList(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
  // --------------------
  // QList pointer types:
  // --------------------
  
      QJSValue RJSHelper::cpp2js_QList_QAbstractButton_ptr(RJSApi& handler, const QList<QAbstractButton*>& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QAbstractButton(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QAbstractButton*> RJSHelper::js2cpp_QList_QAbstractButton_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_QAbstractButton: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QList<QAbstractButton*>>(v);
      }

      bool RJSHelper::is_QList_QAbstractButton_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QAction_ptr(RJSApi& handler, const QList<QAction*>& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QAction(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QAction*> RJSHelper::js2cpp_QList_QAction_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_QAction: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QList<QAction*>>(v);
      }

      bool RJSHelper::is_QList_QAction_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QDockWidget_ptr(RJSApi& handler, const QList<QDockWidget*>& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QDockWidget(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QDockWidget*> RJSHelper::js2cpp_QList_QDockWidget_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_QDockWidget: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QList<QDockWidget*>>(v);
      }

      bool RJSHelper::is_QList_QDockWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QListWidgetItem_ptr(RJSApi& handler, const QList<QListWidgetItem*>& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QListWidgetItem(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QListWidgetItem*> RJSHelper::js2cpp_QList_QListWidgetItem_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_QListWidgetItem: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QList<QListWidgetItem*>>(v);
      }

      bool RJSHelper::is_QList_QListWidgetItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QMdiSubWindow_ptr(RJSApi& handler, const QList<QMdiSubWindow*>& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QMdiSubWindow(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QMdiSubWindow*> RJSHelper::js2cpp_QList_QMdiSubWindow_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_QMdiSubWindow: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QList<QMdiSubWindow*>>(v);
      }

      bool RJSHelper::is_QList_QMdiSubWindow_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QObject_ptr(RJSApi& handler, const QList<QObject*>& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QObject(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QObject*> RJSHelper::js2cpp_QList_QObject_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_QObject: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QList<QObject*>>(v);
      }

      bool RJSHelper::is_QList_QObject_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QScreen_ptr(RJSApi& handler, const QList<QScreen*>& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QScreen(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QScreen*> RJSHelper::js2cpp_QList_QScreen_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_QScreen: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QList<QScreen*>>(v);
      }

      bool RJSHelper::is_QList_QScreen_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QStandardItem_ptr(RJSApi& handler, const QList<QStandardItem*>& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QStandardItem(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QStandardItem*> RJSHelper::js2cpp_QList_QStandardItem_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_QStandardItem: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QList<QStandardItem*>>(v);
      }

      bool RJSHelper::is_QList_QStandardItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QToolBar_ptr(RJSApi& handler, const QList<QToolBar*>& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QToolBar(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QToolBar*> RJSHelper::js2cpp_QList_QToolBar_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_QToolBar: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QList<QToolBar*>>(v);
      }

      bool RJSHelper::is_QList_QToolBar_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QTreeWidgetItem_ptr(RJSApi& handler, const QList<QTreeWidgetItem*>& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QTreeWidgetItem(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QTreeWidgetItem*> RJSHelper::js2cpp_QList_QTreeWidgetItem_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_QTreeWidgetItem: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QList<QTreeWidgetItem*>>(v);
      }

      bool RJSHelper::is_QList_QTreeWidgetItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QList_QWidget_ptr(RJSApi& handler, const QList<QWidget*>& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QWidget(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QList<QWidget*> RJSHelper::js2cpp_QList_QWidget_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QList_QWidget: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QList<QWidget*>>(v);
      }

      bool RJSHelper::is_QList_QWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QWidgetList_ptr(RJSApi& handler, const QWidgetList& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QWidget(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QWidgetList RJSHelper::js2cpp_QWidgetList_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QWidgetList: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QWidgetList>(v);
      }

      bool RJSHelper::is_QWidgetList_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QWindowList_ptr(RJSApi& handler, const QWindowList& v) {
          QJSValue ret = handler.getEngine()->newArray((uint)v.length());
          for (int i=0; i<v.length(); i++) {
              QJSValue jv = RJSHelper::cpp2js_QWindow(handler, v.at(i));
              // prevent undefined values from C++ (e.g. QObjects that are not included in result):
              if (!jv.isUndefined()) {
                  ret.setProperty((quint32)i, jv);
              }
          }
          return ret;
      }

      QWindowList RJSHelper::js2cpp_QWindowList_ptr(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QWindowList: TODO: not properly implemented";
          return handler.getEngine()->fromScriptValue<QWindowList>(v);
      }

      bool RJSHelper::is_QWindowList_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
  // -----------
  // QSet types:
  // -----------
  
      QJSValue RJSHelper::cpp2js_QSet_QString(RJSApi& handler, const QSet<QString>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray((uint)v.size());
          QSet<QString>::const_iterator it;
          int i=0;
          for (it=v.constBegin(); it!=v.constEnd(); i++, it++) {
              ret.setProperty((quint32)i, RJSHelper::cpp2js_QString(handler, *it));
          }
          return ret;
      }

      QSet<QString> RJSHelper::js2cpp_QSet_QString(RJSApi& handler, const QJSValue& v) {
          QSet<QString> ret;
          if (!v.isArray()) {
              qWarning() << "js2cpp_QSet_QString: value is not an array";
              return ret;
          }

          int len = v.property("length").toInt();
          for (int i=0; i<len; i++) {
              ret.insert(js2cpp_QString(handler, v.property(i)));
          }
          return ret;

          //QJSEngine* engine = handler.getEngine();
          //return engine->fromScriptValue<QSet<QString>>(v);
      }

      bool RJSHelper::is_QSet_QString(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
  // -----------
  // QMap types:
  // -----------
  
      QJSValue RJSHelper::cpp2js_QVariantMap(RJSApi& handler, const QVariantMap& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newObject();
          QVariantMap::const_iterator it;
          int i=0;
          for (it=v.constBegin(); it!=v.constEnd(); i++, it++) {
              ret.setProperty(it.key(), RJSHelper::cpp2js_QVariant(handler, it.value()));
          }
          return ret;
      }

      QVariantMap RJSHelper::js2cpp_QVariantMap(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QVariantMap: TODO: not properly implemented";
          QJSEngine* engine = handler.getEngine();
          return engine->fromScriptValue<QVariantMap>(v);
      }

      bool RJSHelper::is_QVariantMap(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isObject();
      }
    
  // -----------
  // QHash types:
  // -----------
  
      QJSValue RJSHelper::cpp2js_QHash_int_QByteArray(RJSApi& handler, const QHash<int,QByteArray>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newObject();
          QHash<int,QByteArray>::const_iterator it;
          for (it=v.constBegin(); it!=v.constEnd(); it++) {
              ret.setProperty(it.key(), RJSHelper::cpp2js_QByteArray(handler, it.value()));
          }
          return ret;
      }

      QHash<int,QByteArray> RJSHelper::js2cpp_QHash_int_QByteArray(RJSApi& handler, const QJSValue& v) {
          QJSEngine* engine = handler.getEngine();

          QHash<int,QByteArray> ret;

          QJSValueIterator it(v);
          while (it.hasNext()) {
              it.next();

              ret.insert(it.name().toInt(), it.value().toString().toUtf8());
          }

          return ret;
      }

      bool RJSHelper::is_QHash_int_QByteArray(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isObject();
      }
    
  // ------------
  // QPair types:
  // ------------
  
      QJSValue RJSHelper::cpp2js_QPair_QString_QString(RJSApi& handler, const QPair<QString,QString>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray(2);
          ret.setProperty(0, RJSHelper::cpp2js_QString(handler, v.first));
          ret.setProperty(1, RJSHelper::cpp2js_QString(handler, v.second));
          return ret;
      }

      QPair<QString,QString> RJSHelper::js2cpp_QPair_QString_QString(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QPair_QString_QString: TODO: not properly implemented";
          QJSEngine* engine = handler.getEngine();
          return engine->fromScriptValue<QPair<QString,QString>>(v);
      }

      bool RJSHelper::is_QPair_QString_QString(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
      QJSValue RJSHelper::cpp2js_QPair_int_int(RJSApi& handler, const QPair<int,int>& v) {
          QJSEngine* engine = handler.getEngine();
          QJSValue ret = engine->newArray(2);
          ret.setProperty(0, RJSHelper::cpp2js_int(handler, v.first));
          ret.setProperty(1, RJSHelper::cpp2js_int(handler, v.second));
          return ret;
      }

      QPair<int,int> RJSHelper::js2cpp_QPair_int_int(RJSApi& handler, const QJSValue& v) {
          // TODO:
          qWarning() << "js2cpp_QPair_int_int: TODO: not properly implemented";
          QJSEngine* engine = handler.getEngine();
          return engine->fromScriptValue<QPair<int,int>>(v);
      }

      bool RJSHelper::is_QPair_int_int(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return v.isArray();
      }
    
  // ------------
  // dummy types:
  // ------------
  
      QJSValue RJSHelper::cpp2js_QCalendar(RJSApi& handler, const QCalendar& v) { return QJSValue(); }

      QCalendar RJSHelper::js2cpp_QCalendar(RJSApi& handler, const QJSValue& v) { ; return QCalendar(); }

      bool RJSHelper::is_QCalendar(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper::cpp2js_QFontInfo(RJSApi& handler, const QFontInfo& v) { return QJSValue(); }

      QFontInfo RJSHelper::js2cpp_QFontInfo(RJSApi& handler, const QJSValue& v) { QFont f; return QFontInfo(f); }

      bool RJSHelper::is_QFontInfo(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return !v.isUndefined();
      }
    
      QJSValue RJSHelper::cpp2js_QTimeZone(RJSApi& handler, const QTimeZone& v) { return QJSValue(); }

      QTimeZone RJSHelper::js2cpp_QTimeZone(RJSApi& handler, const QJSValue& v) { ; return QTimeZone(); }

      bool RJSHelper::is_QTimeZone(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return !v.isUndefined();
      }
    
  // --------------------
  // dummy pointer types:
  // --------------------
  
      QJSValue RJSHelper::cpp2js_QGraphicsProxyWidget(RJSApi& handler, QGraphicsProxyWidget* v) { return QJSValue(); }

      QGraphicsProxyWidget* RJSHelper::js2cpp_QGraphicsProxyWidget(RJSApi& handler, const QJSValue& v) { return nullptr; }

      bool RJSHelper::is_QGraphicsProxyWidget(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return !v.isUndefined() || (v.isNumber() && v.toInt()==0);
      }
    
      QJSValue RJSHelper::cpp2js_QPaintEngine(RJSApi& handler, QPaintEngine* v) { return QJSValue(); }

      QPaintEngine* RJSHelper::js2cpp_QPaintEngine(RJSApi& handler, const QJSValue& v) { return nullptr; }

      bool RJSHelper::is_QPaintEngine(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          return !v.isUndefined() || (v.isNumber() && v.toInt()==0);
      }
    
      QJSValue RJSHelper::cpp2js_QList_QAction(RJSApi& handler, const QList<QAction*>& v) { return QJSValue(); }

      QList<QAction*> RJSHelper::js2cpp_QList_QAction(RJSApi& handler, const QJSValue& v) { return QList<QAction*>(); }
      