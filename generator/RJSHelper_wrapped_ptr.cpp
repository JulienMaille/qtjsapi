
  // Automatically generated, do not edit
  
          #include "RJSHelper.h"
        
          #include "header_cpp.h"
        
          #include "qabstractbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractfileiconprovider_wrapper.h"
        
          #include "qabstractitemdelegate_wrapper.h"
        
          #include "qmodelindex_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qabstracttablemodel_wrapper.h"
        
          #include "qabstractlistmodel_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractprintdialog_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
          #include "qabstractslider_wrapper.h"
        
          #include "qabstractspinbox_wrapper.h"
        
          #include "qaction_wrapper.h"
        
          #include "qactiongroup_wrapper.h"
        
          #include "qapplication_wrapper.h"
        
          #include "qcoreapplication_wrapper.h"
        
          #include "qguiapplication_wrapper.h"
        
          #include "qbitmap_wrapper.h"
        
          #include "qpixmap_wrapper.h"
        
          #include "qboxlayout_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qhboxlayout_wrapper.h"
        
          #include "qvboxlayout_wrapper.h"
        
          #include "qbrush_wrapper.h"
        
          #include "qgradient_wrapper.h"
        
          #include "qlineargradient_wrapper.h"
        
          #include "qradialgradient_wrapper.h"
        
          #include "qconicalgradient_wrapper.h"
        
          #include "qbuffer_wrapper.h"
        
          #include "qiodevicebase_wrapper.h"
        
          #include "qiodevice_wrapper.h"
        
          #include "qbuttongroup_wrapper.h"
        
          #include "qbytearray_wrapper.h"
        
          #include "qcalendar_wrapper.h"
        
          #include "qcheckbox_wrapper.h"
        
          #include "qclipboard_wrapper.h"
        
          #include "qcolor_wrapper.h"
        
          #include "qcolordialog_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qcompleter_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qcursor_wrapper.h"
        
          #include "qdate_wrapper.h"
        
          #include "qtime_wrapper.h"
        
          #include "qdatetime_wrapper.h"
        
          #include "qdesktopservices_wrapper.h"
        
          #include "qdialogbuttonbox_wrapper.h"
        
          #include "qdir_wrapper.h"
        
          #include "qdiriterator_wrapper.h"
        
          #include "qdockwidget_wrapper.h"
        
          #include "qdomimplementation_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnodelist_wrapper.h"
        
          #include "qdomdocumenttype_wrapper.h"
        
          #include "qdomdocument_wrapper.h"
        
          #include "qdomnamednodemap_wrapper.h"
        
          #include "qdomdocumentfragment_wrapper.h"
        
          #include "qdomcharacterdata_wrapper.h"
        
          #include "qdomattr_wrapper.h"
        
          #include "qdomelement_wrapper.h"
        
          #include "qdomtext_wrapper.h"
        
          #include "qdomcomment_wrapper.h"
        
          #include "qdomcdatasection_wrapper.h"
        
          #include "qdomnotation_wrapper.h"
        
          #include "qdomentity_wrapper.h"
        
          #include "qdomentityreference_wrapper.h"
        
          #include "qdomprocessinginstruction_wrapper.h"
        
          #include "qdrag_wrapper.h"
        
          #include "qeasingcurve_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qmouseevent_wrapper.h"
        
          #include "qwheelevent_wrapper.h"
        
          #include "qkeyevent_wrapper.h"
        
          #include "qfocusevent_wrapper.h"
        
          #include "qpaintevent_wrapper.h"
        
          #include "qresizeevent_wrapper.h"
        
          #include "qdragenterevent_wrapper.h"
        
          #include "qdropevent_wrapper.h"
        
          #include "qdragmoveevent_wrapper.h"
        
          #include "qcontextmenuevent_wrapper.h"
        
          #include "qdragleaveevent_wrapper.h"
        
          #include "qhelpevent_wrapper.h"
        
          #include "qactionevent_wrapper.h"
        
          #include "qeventloop_wrapper.h"
        
          #include "qeventpoint_wrapper.h"
        
          #include "qfile_wrapper.h"
        
          #include "qfiledevice_wrapper.h"
        
          #include "qfiledialog_wrapper.h"
        
          #include "qfileiconprovider_wrapper.h"
        
          #include "qfileinfo_wrapper.h"
        
          #include "qfilesystemmodel_wrapper.h"
        
          #include "qfilesystemwatcher_wrapper.h"
        
          #include "qfont_wrapper.h"
        
          #include "qfontcombobox_wrapper.h"
        
          #include "qfontdatabase_wrapper.h"
        
          #include "qfontmetrics_wrapper.h"
        
          #include "qfontmetricsf_wrapper.h"
        
          #include "qformlayout_wrapper.h"
        
          #include "qgesture_wrapper.h"
        
          #include "qpangesture_wrapper.h"
        
          #include "qpinchgesture_wrapper.h"
        
          #include "qswipegesture_wrapper.h"
        
          #include "qgraphicseffect_wrapper.h"
        
          #include "qgraphicscolorizeeffect_wrapper.h"
        
          #include "qgraphicsblureffect_wrapper.h"
        
          #include "qgraphicsdropshadoweffect_wrapper.h"
        
          #include "qgraphicsopacityeffect_wrapper.h"
        
          #include "qgridlayout_wrapper.h"
        
          #include "qgroupbox_wrapper.h"
        
          #include "qheaderview_wrapper.h"
        
          #include "qicon_wrapper.h"
        
          #include "qimage_wrapper.h"
        
          #include "qimagereader_wrapper.h"
        
          #include "qimagewriter_wrapper.h"
        
          #include "qinputdevice_wrapper.h"
        
          #include "qinputdialog_wrapper.h"
        
          #include "qitemdelegate_wrapper.h"
        
          #include "qitemselectionmodel_wrapper.h"
        
          #include "qitemselection_wrapper.h"
        
          #include "qjsengine_wrapper.h"
        
          #include "qkeysequence_wrapper.h"
        
          #include "qlabel_wrapper.h"
        
          #include "qspaceritem_wrapper.h"
        
          #include "qwidgetitem_wrapper.h"
        
          #include "qline_wrapper.h"
        
          #include "qlinef_wrapper.h"
        
          #include "qlineedit_wrapper.h"
        
          #include "qlistview_wrapper.h"
        
          #include "qlistwidgetitem_wrapper.h"
        
          #include "qlistwidget_wrapper.h"
        
          #include "qlocale_wrapper.h"
        
          #include "qmainwindow_wrapper.h"
        
          #include "qmargins_wrapper.h"
        
          #include "qmarginsf_wrapper.h"
        
          #include "qmdiarea_wrapper.h"
        
          #include "qmdisubwindow_wrapper.h"
        
          #include "qmenu_wrapper.h"
        
          #include "qmenubar_wrapper.h"
        
          #include "qmessagebox_wrapper.h"
        
          #include "qmimedata_wrapper.h"
        
          #include "qkeycombination_wrapper.h"
        
          #include "qpagedpaintdevice_wrapper.h"
        
          #include "qpagelayout_wrapper.h"
        
          #include "qpageranges_wrapper.h"
        
          #include "qpagesize_wrapper.h"
        
          #include "qpainter_wrapper.h"
        
          #include "qpainterpath_wrapper.h"
        
          #include "qpainterpathstroker_wrapper.h"
        
          #include "qpalette_wrapper.h"
        
          #include "qpen_wrapper.h"
        
          #include "qpicture_wrapper.h"
        
          #include "qplaintextedit_wrapper.h"
        
          #include "qpoint_wrapper.h"
        
          #include "qpointf_wrapper.h"
        
          #include "qpolygon_wrapper.h"
        
          #include "qpolygonf_wrapper.h"
        
          #include "qprintdialog_wrapper.h"
        
          #include "qprinter_wrapper.h"
        
          #include "qprinterinfo_wrapper.h"
        
          #include "qprocessenvironment_wrapper.h"
        
          #include "qprocess_wrapper.h"
        
          #include "qprogressbar_wrapper.h"
        
          #include "qprogressdialog_wrapper.h"
        
          #include "qpushbutton_wrapper.h"
        
          #include "qqmlapplicationengine_wrapper.h"
        
          #include "qqmlengine_wrapper.h"
        
          #include "qqmlcontext_wrapper.h"
        
          #include "qradiobutton_wrapper.h"
        
          #include "qrect_wrapper.h"
        
          #include "qrectf_wrapper.h"
        
          #include "qregion_wrapper.h"
        
          #include "qregularexpression_wrapper.h"
        
          #include "qregularexpressionmatch_wrapper.h"
        
          #include "qrhiwidget_wrapper.h"
        
          #include "qscreen_wrapper.h"
        
          #include "qscrollarea_wrapper.h"
        
          #include "qscrollbar_wrapper.h"
        
          #include "qsettings_wrapper.h"
        
          #include "qshortcut_wrapper.h"
        
          #include "qsize_wrapper.h"
        
          #include "qsizef_wrapper.h"
        
          #include "qsizepolicy_wrapper.h"
        
          #include "qslider_wrapper.h"
        
          #include "qsortfilterproxymodel_wrapper.h"
        
          #include "qabstractproxymodel_wrapper.h"
        
          #include "qspinbox_wrapper.h"
        
          #include "qdoublespinbox_wrapper.h"
        
          #include "qsplashscreen_wrapper.h"
        
          #include "qsplitter_wrapper.h"
        
          #include "qsplitterhandle_wrapper.h"
        
          #include "qstackedlayout_wrapper.h"
        
          #include "qstackedwidget_wrapper.h"
        
          #include "qstandarditem_wrapper.h"
        
          #include "qstandarditemmodel_wrapper.h"
        
          #include "qstatusbar_wrapper.h"
        
          #include "qstringconverter_wrapper.h"
        
          #include "qstringconverterbase_wrapper.h"
        
          #include "qstringencoder_wrapper.h"
        
          #include "qstringdecoder_wrapper.h"
        
          #include "qsurfaceformat_wrapper.h"
        
          #include "qsvgrenderer_wrapper.h"
        
          #include "qtabbar_wrapper.h"
        
          #include "qtableview_wrapper.h"
        
          #include "qtablewidgetitem_wrapper.h"
        
          #include "qtablewidget_wrapper.h"
        
          #include "qtabwidget_wrapper.h"
        
          #include "qtextbrowser_wrapper.h"
        
          #include "qtextedit_wrapper.h"
        
          #include "qtextcursor_wrapper.h"
        
          #include "qtextdocument_wrapper.h"
        
          #include "qtextlength_wrapper.h"
        
          #include "qtextformat_wrapper.h"
        
          #include "qtextcharformat_wrapper.h"
        
          #include "qtextblockformat_wrapper.h"
        
          #include "qtextlistformat_wrapper.h"
        
          #include "qtextimageformat_wrapper.h"
        
          #include "qtextframeformat_wrapper.h"
        
          #include "qtexttableformat_wrapper.h"
        
          #include "qtexttablecellformat_wrapper.h"
        
          #include "qtextlayout_wrapper.h"
        
          #include "qtextstream_wrapper.h"
        
          #include "qtimer_wrapper.h"
        
          #include "qtoolbar_wrapper.h"
        
          #include "qtoolbutton_wrapper.h"
        
          #include "qtooltip_wrapper.h"
        
          #include "qtransform_wrapper.h"
        
          #include "qtranslator_wrapper.h"
        
          #include "qtreeview_wrapper.h"
        
          #include "qtreewidgetitem_wrapper.h"
        
          #include "qtreewidget_wrapper.h"
        
          #include "quiloader_wrapper.h"
        
          #include "qurl_wrapper.h"
        
          #include "qurlquery_wrapper.h"
        
          #include "qvalidator_wrapper.h"
        
          #include "qintvalidator_wrapper.h"
        
          #include "qdoublevalidator_wrapper.h"
        
          #include "qregularexpressionvalidator_wrapper.h"
        
          #include "qvariant_wrapper.h"
        
          #include "qwidgetaction_wrapper.h"
        
          #include "qwindow_wrapper.h"
        
          #include "qsurface_wrapper.h"
        
          #include "qxmlattributes_wrapper.h"
        
          #include "qxmlinputsource_wrapper.h"
        
          #include "qxmlparseexception_wrapper.h"
        
          #include "qxmlreader_wrapper.h"
        
          #include "qxmlsimplereader_wrapper.h"
        
          #include "qxmllocator_wrapper.h"
        
          #include "qxmlcontenthandler_wrapper.h"
        
          #include "qxmlerrorhandler_wrapper.h"
        
          #include "qxmldtdhandler_wrapper.h"
        
          #include "qxmlentityresolver_wrapper.h"
        
          #include "qxmllexicalhandler_wrapper.h"
        
          #include "qxmldeclhandler_wrapper.h"
        
          #include "qxmldefaulthandler_wrapper.h"
        
          #include "qxmlstreamattribute_wrapper.h"
        
          #include "qxmlstreamattributes_wrapper.h"
        
          #include "qxmlstreamreader_wrapper.h"
        
          #include "qxmlstreamwriter_wrapper.h"
        
  // ----------------------
  // wrapped pointer types:
  // ----------------------
  
      QJSValue RJSHelper::cpp2js_QAbstractFileIconProvider(RJSApi& handler, QAbstractFileIconProvider* v) {

          
            // downcast to QFileIconProvider:
            {
                QFileIconProvider* o = dynamic_cast<QFileIconProvider*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QFileIconProvider(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QAbstractFileIconProvider_Wrapper* ret = new QAbstractFileIconProvider_Wrapper(handler, v, false);

          // JS: new QAbstractFileIconProvider('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractFileIconProvider");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractFileIconProvider is undefined. Use QAbstractFileIconProvider_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractFileIconProvider('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractFileIconProvider(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QAbstractFileIconProvider* RJSHelper::js2cpp_QAbstractFileIconProvider_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractFileIconProvider: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractFileIconProvider_Wrapper* wrapper = qobject_cast<QAbstractFileIconProvider_Wrapper*>(obj);
          //QAbstractFileIconProvider_Wrapper* wrapper = dynamic_cast<QAbstractFileIconProvider_Wrapper*>(obj);
          //QAbstractFileIconProvider_Wrapper* wrapper = (QAbstractFileIconProvider_Wrapper*)(obj);
          //QAbstractFileIconProvider_Wrapper* wrapper = getWrapper<QAbstractFileIconProvider_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractFileIconProvider_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QAbstractFileIconProvider(wrapper);
          return QAbstractFileIconProvider_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractFileIconProvider_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractFileIconProvider: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractFileIconProvider::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractListModel(RJSApi& handler, QAbstractListModel* v) {

          

          QJSEngine* engine = handler.getEngine();
          QAbstractListModel_Wrapper* ret = new QAbstractListModel_Wrapper(handler, v, false);

          // JS: new QAbstractListModel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractListModel");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractListModel is undefined. Use QAbstractListModel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractListModel('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractListModel(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QAbstractListModel* RJSHelper::js2cpp_QAbstractListModel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractListModel: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractListModel_Wrapper* wrapper = qobject_cast<QAbstractListModel_Wrapper*>(obj);
          //QAbstractListModel_Wrapper* wrapper = dynamic_cast<QAbstractListModel_Wrapper*>(obj);
          //QAbstractListModel_Wrapper* wrapper = (QAbstractListModel_Wrapper*)(obj);
          //QAbstractListModel_Wrapper* wrapper = getWrapper<QAbstractListModel_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractListModel_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QAbstractListModel(wrapper);
          return QAbstractListModel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractListModel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractListModel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractListModel::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QAbstractTableModel(RJSApi& handler, QAbstractTableModel* v) {

          

          QJSEngine* engine = handler.getEngine();
          QAbstractTableModel_Wrapper* ret = new QAbstractTableModel_Wrapper(handler, v, false);

          // JS: new QAbstractTableModel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractTableModel");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractTableModel is undefined. Use QAbstractTableModel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractTableModel('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractTableModel(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QAbstractTableModel* RJSHelper::js2cpp_QAbstractTableModel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractTableModel: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractTableModel_Wrapper* wrapper = qobject_cast<QAbstractTableModel_Wrapper*>(obj);
          //QAbstractTableModel_Wrapper* wrapper = dynamic_cast<QAbstractTableModel_Wrapper*>(obj);
          //QAbstractTableModel_Wrapper* wrapper = (QAbstractTableModel_Wrapper*)(obj);
          //QAbstractTableModel_Wrapper* wrapper = getWrapper<QAbstractTableModel_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractTableModel_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QAbstractTableModel(wrapper);
          return QAbstractTableModel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractTableModel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractTableModel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractTableModel::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QActionEvent(RJSApi& handler, QActionEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QActionEvent_Wrapper* ret = new QActionEvent_Wrapper(handler, v, false);

          // JS: new QActionEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QActionEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QActionEvent is undefined. Use QActionEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QActionEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QActionEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QActionEvent* RJSHelper::js2cpp_QActionEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QActionEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QActionEvent_Wrapper* wrapper = qobject_cast<QActionEvent_Wrapper*>(obj);
          //QActionEvent_Wrapper* wrapper = dynamic_cast<QActionEvent_Wrapper*>(obj);
          //QActionEvent_Wrapper* wrapper = (QActionEvent_Wrapper*)(obj);
          //QActionEvent_Wrapper* wrapper = getWrapper<QActionEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QActionEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QActionEvent(wrapper);
          return QActionEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QActionEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QActionEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QActionEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QCompleter(RJSApi& handler, QCompleter* v) {

          

          QJSEngine* engine = handler.getEngine();
          QCompleter_Wrapper* ret = new QCompleter_Wrapper(handler, v, false);

          // JS: new QCompleter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QCompleter");
          if (cl.isUndefined()) {
              qWarning() << "Class QCompleter is undefined. Use QCompleter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QCompleter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QCompleter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QCompleter* RJSHelper::js2cpp_QCompleter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QCompleter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QCompleter_Wrapper* wrapper = qobject_cast<QCompleter_Wrapper*>(obj);
          //QCompleter_Wrapper* wrapper = dynamic_cast<QCompleter_Wrapper*>(obj);
          //QCompleter_Wrapper* wrapper = (QCompleter_Wrapper*)(obj);
          //QCompleter_Wrapper* wrapper = getWrapper<QCompleter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QCompleter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QCompleter(wrapper);
          return QCompleter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QCompleter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QCompleter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QCompleter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QContextMenuEvent(RJSApi& handler, QContextMenuEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QContextMenuEvent_Wrapper* ret = new QContextMenuEvent_Wrapper(handler, v, false);

          // JS: new QContextMenuEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QContextMenuEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QContextMenuEvent is undefined. Use QContextMenuEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QContextMenuEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QContextMenuEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QContextMenuEvent* RJSHelper::js2cpp_QContextMenuEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QContextMenuEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QContextMenuEvent_Wrapper* wrapper = qobject_cast<QContextMenuEvent_Wrapper*>(obj);
          //QContextMenuEvent_Wrapper* wrapper = dynamic_cast<QContextMenuEvent_Wrapper*>(obj);
          //QContextMenuEvent_Wrapper* wrapper = (QContextMenuEvent_Wrapper*)(obj);
          //QContextMenuEvent_Wrapper* wrapper = getWrapper<QContextMenuEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QContextMenuEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QContextMenuEvent(wrapper);
          return QContextMenuEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QContextMenuEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QContextMenuEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QContextMenuEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDirIterator(RJSApi& handler, QDirIterator* v) {

          

          QJSEngine* engine = handler.getEngine();
          QDirIterator_Wrapper* ret = new QDirIterator_Wrapper(handler, v, false);

          // JS: new QDirIterator('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDirIterator");
          if (cl.isUndefined()) {
              qWarning() << "Class QDirIterator is undefined. Use QDirIterator_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDirIterator('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDirIterator(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QDirIterator* RJSHelper::js2cpp_QDirIterator_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDirIterator: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDirIterator_Wrapper* wrapper = qobject_cast<QDirIterator_Wrapper*>(obj);
          //QDirIterator_Wrapper* wrapper = dynamic_cast<QDirIterator_Wrapper*>(obj);
          //QDirIterator_Wrapper* wrapper = (QDirIterator_Wrapper*)(obj);
          //QDirIterator_Wrapper* wrapper = getWrapper<QDirIterator_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDirIterator_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QDirIterator(wrapper);
          return QDirIterator_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDirIterator_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDirIterator: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QDirIterator::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDragEnterEvent(RJSApi& handler, QDragEnterEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QDragEnterEvent_Wrapper* ret = new QDragEnterEvent_Wrapper(handler, v, false);

          // JS: new QDragEnterEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDragEnterEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QDragEnterEvent is undefined. Use QDragEnterEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDragEnterEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDragEnterEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QDragEnterEvent* RJSHelper::js2cpp_QDragEnterEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDragEnterEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDragEnterEvent_Wrapper* wrapper = qobject_cast<QDragEnterEvent_Wrapper*>(obj);
          //QDragEnterEvent_Wrapper* wrapper = dynamic_cast<QDragEnterEvent_Wrapper*>(obj);
          //QDragEnterEvent_Wrapper* wrapper = (QDragEnterEvent_Wrapper*)(obj);
          //QDragEnterEvent_Wrapper* wrapper = getWrapper<QDragEnterEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDragEnterEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QDragEnterEvent(wrapper);
          return QDragEnterEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDragEnterEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDragEnterEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QDragEnterEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDragLeaveEvent(RJSApi& handler, QDragLeaveEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QDragLeaveEvent_Wrapper* ret = new QDragLeaveEvent_Wrapper(handler, v, false);

          // JS: new QDragLeaveEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDragLeaveEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QDragLeaveEvent is undefined. Use QDragLeaveEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDragLeaveEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDragLeaveEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QDragLeaveEvent* RJSHelper::js2cpp_QDragLeaveEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDragLeaveEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDragLeaveEvent_Wrapper* wrapper = qobject_cast<QDragLeaveEvent_Wrapper*>(obj);
          //QDragLeaveEvent_Wrapper* wrapper = dynamic_cast<QDragLeaveEvent_Wrapper*>(obj);
          //QDragLeaveEvent_Wrapper* wrapper = (QDragLeaveEvent_Wrapper*)(obj);
          //QDragLeaveEvent_Wrapper* wrapper = getWrapper<QDragLeaveEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDragLeaveEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QDragLeaveEvent(wrapper);
          return QDragLeaveEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDragLeaveEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDragLeaveEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QDragLeaveEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDragMoveEvent(RJSApi& handler, QDragMoveEvent* v) {

          
            // downcast to QDragEnterEvent:
            {
                QDragEnterEvent* o = dynamic_cast<QDragEnterEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QDragEnterEvent(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QDragMoveEvent_Wrapper* ret = new QDragMoveEvent_Wrapper(handler, v, false);

          // JS: new QDragMoveEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDragMoveEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QDragMoveEvent is undefined. Use QDragMoveEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDragMoveEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDragMoveEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QDragMoveEvent* RJSHelper::js2cpp_QDragMoveEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDragMoveEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDragMoveEvent_Wrapper* wrapper = qobject_cast<QDragMoveEvent_Wrapper*>(obj);
          //QDragMoveEvent_Wrapper* wrapper = dynamic_cast<QDragMoveEvent_Wrapper*>(obj);
          //QDragMoveEvent_Wrapper* wrapper = (QDragMoveEvent_Wrapper*)(obj);
          //QDragMoveEvent_Wrapper* wrapper = getWrapper<QDragMoveEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDragMoveEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QDragMoveEvent(wrapper);
          return QDragMoveEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDragMoveEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDragMoveEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QDragMoveEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDropEvent(RJSApi& handler, QDropEvent* v) {

          
            // downcast to QDragMoveEvent:
            {
                QDragMoveEvent* o = dynamic_cast<QDragMoveEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QDragMoveEvent(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QDropEvent_Wrapper* ret = new QDropEvent_Wrapper(handler, v, false);

          // JS: new QDropEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDropEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QDropEvent is undefined. Use QDropEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDropEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDropEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QDropEvent* RJSHelper::js2cpp_QDropEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDropEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDropEvent_Wrapper* wrapper = qobject_cast<QDropEvent_Wrapper*>(obj);
          //QDropEvent_Wrapper* wrapper = dynamic_cast<QDropEvent_Wrapper*>(obj);
          //QDropEvent_Wrapper* wrapper = (QDropEvent_Wrapper*)(obj);
          //QDropEvent_Wrapper* wrapper = getWrapper<QDropEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDropEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QDropEvent(wrapper);
          return QDropEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDropEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDropEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QDropEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QEvent(RJSApi& handler, QEvent* v) {

          
            // downcast to QInputEvent:
            {
                QInputEvent* o = dynamic_cast<QInputEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QInputEvent(handler, o);
                }
            }
          
            // downcast to QFocusEvent:
            {
                QFocusEvent* o = dynamic_cast<QFocusEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QFocusEvent(handler, o);
                }
            }
          
            // downcast to QPaintEvent:
            {
                QPaintEvent* o = dynamic_cast<QPaintEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPaintEvent(handler, o);
                }
            }
          
            // downcast to QResizeEvent:
            {
                QResizeEvent* o = dynamic_cast<QResizeEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QResizeEvent(handler, o);
                }
            }
          
            // downcast to QDropEvent:
            {
                QDropEvent* o = dynamic_cast<QDropEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QDropEvent(handler, o);
                }
            }
          
            // downcast to QDragLeaveEvent:
            {
                QDragLeaveEvent* o = dynamic_cast<QDragLeaveEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QDragLeaveEvent(handler, o);
                }
            }
          
            // downcast to QHelpEvent:
            {
                QHelpEvent* o = dynamic_cast<QHelpEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QHelpEvent(handler, o);
                }
            }
          
            // downcast to QActionEvent:
            {
                QActionEvent* o = dynamic_cast<QActionEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QActionEvent(handler, o);
                }
            }
          
            // downcast to types derrived from QEvent but defined in other modules:
            for (int i=0; i<downcasters_QEvent.length(); i++) {
                QJSValue dc = downcasters_QEvent[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QEvent_Wrapper* ret = new QEvent_Wrapper(handler, v, false);

          // JS: new QEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QEvent is undefined. Use QEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QEvent* RJSHelper::js2cpp_QEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QEvent_Wrapper* wrapper = qobject_cast<QEvent_Wrapper*>(obj);
          //QEvent_Wrapper* wrapper = dynamic_cast<QEvent_Wrapper*>(obj);
          //QEvent_Wrapper* wrapper = (QEvent_Wrapper*)(obj);
          //QEvent_Wrapper* wrapper = getWrapper<QEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QEvent(wrapper);
          return QEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QFileIconProvider(RJSApi& handler, QFileIconProvider* v) {

          

          QJSEngine* engine = handler.getEngine();
          QFileIconProvider_Wrapper* ret = new QFileIconProvider_Wrapper(handler, v, false);

          // JS: new QFileIconProvider('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFileIconProvider");
          if (cl.isUndefined()) {
              qWarning() << "Class QFileIconProvider is undefined. Use QFileIconProvider_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFileIconProvider('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFileIconProvider(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QFileIconProvider* RJSHelper::js2cpp_QFileIconProvider_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFileIconProvider: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFileIconProvider_Wrapper* wrapper = qobject_cast<QFileIconProvider_Wrapper*>(obj);
          //QFileIconProvider_Wrapper* wrapper = dynamic_cast<QFileIconProvider_Wrapper*>(obj);
          //QFileIconProvider_Wrapper* wrapper = (QFileIconProvider_Wrapper*)(obj);
          //QFileIconProvider_Wrapper* wrapper = getWrapper<QFileIconProvider_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFileIconProvider_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QFileIconProvider(wrapper);
          return QFileIconProvider_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFileIconProvider_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFileIconProvider: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QFileIconProvider::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QFocusEvent(RJSApi& handler, QFocusEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QFocusEvent_Wrapper* ret = new QFocusEvent_Wrapper(handler, v, false);

          // JS: new QFocusEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFocusEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QFocusEvent is undefined. Use QFocusEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFocusEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFocusEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QFocusEvent* RJSHelper::js2cpp_QFocusEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFocusEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFocusEvent_Wrapper* wrapper = qobject_cast<QFocusEvent_Wrapper*>(obj);
          //QFocusEvent_Wrapper* wrapper = dynamic_cast<QFocusEvent_Wrapper*>(obj);
          //QFocusEvent_Wrapper* wrapper = (QFocusEvent_Wrapper*)(obj);
          //QFocusEvent_Wrapper* wrapper = getWrapper<QFocusEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFocusEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QFocusEvent(wrapper);
          return QFocusEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFocusEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFocusEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QFocusEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QFontMetrics(RJSApi& handler, QFontMetrics* v) {

          

          QJSEngine* engine = handler.getEngine();
          QFontMetrics_Wrapper* ret = new QFontMetrics_Wrapper(handler, v, false);

          // JS: new QFontMetrics('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFontMetrics");
          if (cl.isUndefined()) {
              qWarning() << "Class QFontMetrics is undefined. Use QFontMetrics_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFontMetrics('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFontMetrics(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QFontMetrics* RJSHelper::js2cpp_QFontMetrics_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFontMetrics: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFontMetrics_Wrapper* wrapper = qobject_cast<QFontMetrics_Wrapper*>(obj);
          //QFontMetrics_Wrapper* wrapper = dynamic_cast<QFontMetrics_Wrapper*>(obj);
          //QFontMetrics_Wrapper* wrapper = (QFontMetrics_Wrapper*)(obj);
          //QFontMetrics_Wrapper* wrapper = getWrapper<QFontMetrics_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFontMetrics_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QFontMetrics(wrapper);
          return QFontMetrics_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFontMetrics_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFontMetrics: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QFontMetrics::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QFontMetricsF(RJSApi& handler, QFontMetricsF* v) {

          

          QJSEngine* engine = handler.getEngine();
          QFontMetricsF_Wrapper* ret = new QFontMetricsF_Wrapper(handler, v, false);

          // JS: new QFontMetricsF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFontMetricsF");
          if (cl.isUndefined()) {
              qWarning() << "Class QFontMetricsF is undefined. Use QFontMetricsF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFontMetricsF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFontMetricsF(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QFontMetricsF* RJSHelper::js2cpp_QFontMetricsF_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFontMetricsF: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFontMetricsF_Wrapper* wrapper = qobject_cast<QFontMetricsF_Wrapper*>(obj);
          //QFontMetricsF_Wrapper* wrapper = dynamic_cast<QFontMetricsF_Wrapper*>(obj);
          //QFontMetricsF_Wrapper* wrapper = (QFontMetricsF_Wrapper*)(obj);
          //QFontMetricsF_Wrapper* wrapper = getWrapper<QFontMetricsF_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFontMetricsF_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QFontMetricsF(wrapper);
          return QFontMetricsF_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFontMetricsF_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFontMetricsF: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QFontMetricsF::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QHelpEvent(RJSApi& handler, QHelpEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QHelpEvent_Wrapper* ret = new QHelpEvent_Wrapper(handler, v, false);

          // JS: new QHelpEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QHelpEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QHelpEvent is undefined. Use QHelpEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QHelpEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QHelpEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QHelpEvent* RJSHelper::js2cpp_QHelpEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QHelpEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QHelpEvent_Wrapper* wrapper = qobject_cast<QHelpEvent_Wrapper*>(obj);
          //QHelpEvent_Wrapper* wrapper = dynamic_cast<QHelpEvent_Wrapper*>(obj);
          //QHelpEvent_Wrapper* wrapper = (QHelpEvent_Wrapper*)(obj);
          //QHelpEvent_Wrapper* wrapper = getWrapper<QHelpEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QHelpEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QHelpEvent(wrapper);
          return QHelpEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QHelpEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QHelpEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QHelpEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QIODeviceBase(RJSApi& handler, QIODeviceBase* v) {

          

          QJSEngine* engine = handler.getEngine();
          QIODeviceBase_Wrapper* ret = new QIODeviceBase_Wrapper(handler, v, false);

          // JS: new QIODeviceBase('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QIODeviceBase");
          if (cl.isUndefined()) {
              qWarning() << "Class QIODeviceBase is undefined. Use QIODeviceBase_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QIODeviceBase('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QIODeviceBase(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QIODeviceBase* RJSHelper::js2cpp_QIODeviceBase_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QIODeviceBase: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QIODeviceBase_Wrapper* wrapper = qobject_cast<QIODeviceBase_Wrapper*>(obj);
          //QIODeviceBase_Wrapper* wrapper = dynamic_cast<QIODeviceBase_Wrapper*>(obj);
          //QIODeviceBase_Wrapper* wrapper = (QIODeviceBase_Wrapper*)(obj);
          //QIODeviceBase_Wrapper* wrapper = getWrapper<QIODeviceBase_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QIODeviceBase_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QIODeviceBase(wrapper);
          return QIODeviceBase_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QIODeviceBase_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QIODeviceBase: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QIODeviceBase::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QImageReader(RJSApi& handler, QImageReader* v) {

          

          QJSEngine* engine = handler.getEngine();
          QImageReader_Wrapper* ret = new QImageReader_Wrapper(handler, v, false);

          // JS: new QImageReader('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QImageReader");
          if (cl.isUndefined()) {
              qWarning() << "Class QImageReader is undefined. Use QImageReader_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QImageReader('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QImageReader(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QImageReader* RJSHelper::js2cpp_QImageReader_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QImageReader: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QImageReader_Wrapper* wrapper = qobject_cast<QImageReader_Wrapper*>(obj);
          //QImageReader_Wrapper* wrapper = dynamic_cast<QImageReader_Wrapper*>(obj);
          //QImageReader_Wrapper* wrapper = (QImageReader_Wrapper*)(obj);
          //QImageReader_Wrapper* wrapper = getWrapper<QImageReader_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QImageReader_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QImageReader(wrapper);
          return QImageReader_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QImageReader_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QImageReader: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QImageReader::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QImageWriter(RJSApi& handler, QImageWriter* v) {

          

          QJSEngine* engine = handler.getEngine();
          QImageWriter_Wrapper* ret = new QImageWriter_Wrapper(handler, v, false);

          // JS: new QImageWriter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QImageWriter");
          if (cl.isUndefined()) {
              qWarning() << "Class QImageWriter is undefined. Use QImageWriter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QImageWriter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QImageWriter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QImageWriter* RJSHelper::js2cpp_QImageWriter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QImageWriter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QImageWriter_Wrapper* wrapper = qobject_cast<QImageWriter_Wrapper*>(obj);
          //QImageWriter_Wrapper* wrapper = dynamic_cast<QImageWriter_Wrapper*>(obj);
          //QImageWriter_Wrapper* wrapper = (QImageWriter_Wrapper*)(obj);
          //QImageWriter_Wrapper* wrapper = getWrapper<QImageWriter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QImageWriter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QImageWriter(wrapper);
          return QImageWriter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QImageWriter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QImageWriter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QImageWriter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QInputEvent(RJSApi& handler, QInputEvent* v) {

          
            // downcast to QPointerEvent:
            {
                QPointerEvent* o = dynamic_cast<QPointerEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPointerEvent(handler, o);
                }
            }
          
            // downcast to QKeyEvent:
            {
                QKeyEvent* o = dynamic_cast<QKeyEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QKeyEvent(handler, o);
                }
            }
          
            // downcast to QContextMenuEvent:
            {
                QContextMenuEvent* o = dynamic_cast<QContextMenuEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QContextMenuEvent(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QInputEvent_Wrapper* ret = new QInputEvent_Wrapper(handler, v, false);

          // JS: new QInputEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QInputEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QInputEvent is undefined. Use QInputEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QInputEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QInputEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QInputEvent* RJSHelper::js2cpp_QInputEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QInputEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QInputEvent_Wrapper* wrapper = qobject_cast<QInputEvent_Wrapper*>(obj);
          //QInputEvent_Wrapper* wrapper = dynamic_cast<QInputEvent_Wrapper*>(obj);
          //QInputEvent_Wrapper* wrapper = (QInputEvent_Wrapper*)(obj);
          //QInputEvent_Wrapper* wrapper = getWrapper<QInputEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QInputEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QInputEvent(wrapper);
          return QInputEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QInputEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QInputEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QInputEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QJSEngine(RJSApi& handler, QJSEngine* v) {

          
            // downcast to QQmlEngine:
            {
                QQmlEngine* o = dynamic_cast<QQmlEngine*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QQmlEngine(handler, o);
                }
            }
          
            // downcast to types derrived from QJSEngine but defined in other modules:
            for (int i=0; i<downcasters_QJSEngine.length(); i++) {
                QJSValue dc = downcasters_QJSEngine[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QJSEngine_Wrapper* ret = new QJSEngine_Wrapper(handler, v, false);

          // JS: new QJSEngine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QJSEngine");
          if (cl.isUndefined()) {
              qWarning() << "Class QJSEngine is undefined. Use QJSEngine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QJSEngine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QJSEngine(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QJSEngine* RJSHelper::js2cpp_QJSEngine_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QJSEngine: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QJSEngine_Wrapper* wrapper = qobject_cast<QJSEngine_Wrapper*>(obj);
          //QJSEngine_Wrapper* wrapper = dynamic_cast<QJSEngine_Wrapper*>(obj);
          //QJSEngine_Wrapper* wrapper = (QJSEngine_Wrapper*)(obj);
          //QJSEngine_Wrapper* wrapper = getWrapper<QJSEngine_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QJSEngine_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QJSEngine(wrapper);
          return QJSEngine_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QJSEngine_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QJSEngine: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QJSEngine::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QKeyEvent(RJSApi& handler, QKeyEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QKeyEvent_Wrapper* ret = new QKeyEvent_Wrapper(handler, v, false);

          // JS: new QKeyEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QKeyEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QKeyEvent is undefined. Use QKeyEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QKeyEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QKeyEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QKeyEvent* RJSHelper::js2cpp_QKeyEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QKeyEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QKeyEvent_Wrapper* wrapper = qobject_cast<QKeyEvent_Wrapper*>(obj);
          //QKeyEvent_Wrapper* wrapper = dynamic_cast<QKeyEvent_Wrapper*>(obj);
          //QKeyEvent_Wrapper* wrapper = (QKeyEvent_Wrapper*)(obj);
          //QKeyEvent_Wrapper* wrapper = getWrapper<QKeyEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QKeyEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QKeyEvent(wrapper);
          return QKeyEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QKeyEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QKeyEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QKeyEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QLayoutItem(RJSApi& handler, QLayoutItem* v) {

          
            // downcast to QLayout:
            {
                QLayout* o = dynamic_cast<QLayout*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QLayout(handler, o);
                }
            }
          
            // downcast to QSpacerItem:
            {
                QSpacerItem* o = dynamic_cast<QSpacerItem*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QSpacerItem(handler, o);
                }
            }
          
            // downcast to QWidgetItem:
            {
                QWidgetItem* o = dynamic_cast<QWidgetItem*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QWidgetItem(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QLayoutItem_Wrapper* ret = new QLayoutItem_Wrapper(handler, v, false);

          // JS: new QLayoutItem('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLayoutItem");
          if (cl.isUndefined()) {
              qWarning() << "Class QLayoutItem is undefined. Use QLayoutItem_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLayoutItem('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLayoutItem(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QLayoutItem* RJSHelper::js2cpp_QLayoutItem_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QLayoutItem: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QLayoutItem_Wrapper* wrapper = qobject_cast<QLayoutItem_Wrapper*>(obj);
          //QLayoutItem_Wrapper* wrapper = dynamic_cast<QLayoutItem_Wrapper*>(obj);
          //QLayoutItem_Wrapper* wrapper = (QLayoutItem_Wrapper*)(obj);
          //QLayoutItem_Wrapper* wrapper = getWrapper<QLayoutItem_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLayoutItem_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QLayoutItem(wrapper);
          return QLayoutItem_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QLayoutItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QLayoutItem: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QLayoutItem::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QListWidgetItem(RJSApi& handler, QListWidgetItem* v) {

          

          QJSEngine* engine = handler.getEngine();
          QListWidgetItem_Wrapper* ret = new QListWidgetItem_Wrapper(handler, v, false);

          // JS: new QListWidgetItem('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QListWidgetItem");
          if (cl.isUndefined()) {
              qWarning() << "Class QListWidgetItem is undefined. Use QListWidgetItem_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QListWidgetItem('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QListWidgetItem(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QListWidgetItem* RJSHelper::js2cpp_QListWidgetItem_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QListWidgetItem: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QListWidgetItem_Wrapper* wrapper = qobject_cast<QListWidgetItem_Wrapper*>(obj);
          //QListWidgetItem_Wrapper* wrapper = dynamic_cast<QListWidgetItem_Wrapper*>(obj);
          //QListWidgetItem_Wrapper* wrapper = (QListWidgetItem_Wrapper*)(obj);
          //QListWidgetItem_Wrapper* wrapper = getWrapper<QListWidgetItem_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QListWidgetItem_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QListWidgetItem(wrapper);
          return QListWidgetItem_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QListWidgetItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QListWidgetItem: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QListWidgetItem::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QMouseEvent(RJSApi& handler, QMouseEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QMouseEvent_Wrapper* ret = new QMouseEvent_Wrapper(handler, v, false);

          // JS: new QMouseEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMouseEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QMouseEvent is undefined. Use QMouseEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMouseEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMouseEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QMouseEvent* RJSHelper::js2cpp_QMouseEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMouseEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QMouseEvent_Wrapper* wrapper = qobject_cast<QMouseEvent_Wrapper*>(obj);
          //QMouseEvent_Wrapper* wrapper = dynamic_cast<QMouseEvent_Wrapper*>(obj);
          //QMouseEvent_Wrapper* wrapper = (QMouseEvent_Wrapper*)(obj);
          //QMouseEvent_Wrapper* wrapper = getWrapper<QMouseEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMouseEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QMouseEvent(wrapper);
          return QMouseEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QMouseEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMouseEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QMouseEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPagedPaintDevice(RJSApi& handler, QPagedPaintDevice* v) {

          
            // downcast to QPrinter:
            {
                QPrinter* o = dynamic_cast<QPrinter*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPrinter(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QPagedPaintDevice_Wrapper* ret = new QPagedPaintDevice_Wrapper(handler, v, false);

          // JS: new QPagedPaintDevice('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPagedPaintDevice");
          if (cl.isUndefined()) {
              qWarning() << "Class QPagedPaintDevice is undefined. Use QPagedPaintDevice_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPagedPaintDevice('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPagedPaintDevice(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QPagedPaintDevice* RJSHelper::js2cpp_QPagedPaintDevice_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPagedPaintDevice: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPagedPaintDevice_Wrapper* wrapper = qobject_cast<QPagedPaintDevice_Wrapper*>(obj);
          //QPagedPaintDevice_Wrapper* wrapper = dynamic_cast<QPagedPaintDevice_Wrapper*>(obj);
          //QPagedPaintDevice_Wrapper* wrapper = (QPagedPaintDevice_Wrapper*)(obj);
          //QPagedPaintDevice_Wrapper* wrapper = getWrapper<QPagedPaintDevice_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPagedPaintDevice_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QPagedPaintDevice(wrapper);
          return QPagedPaintDevice_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPagedPaintDevice_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPagedPaintDevice: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QPagedPaintDevice::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPaintDevice(RJSApi& handler, QPaintDevice* v) {

          
            // downcast to QImage:
            {
                QImage* o = dynamic_cast<QImage*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QImage(handler, o);
                }
            }
          
            // downcast to QPagedPaintDevice:
            {
                QPagedPaintDevice* o = dynamic_cast<QPagedPaintDevice*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPagedPaintDevice(handler, o);
                }
            }
          
            // downcast to QPicture:
            {
                QPicture* o = dynamic_cast<QPicture*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPicture(handler, o);
                }
            }
          
            // downcast to QPixmap:
            {
                QPixmap* o = dynamic_cast<QPixmap*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPixmap(handler, o);
                }
            }
          
            // downcast to QWidget:
            {
                QWidget* o = dynamic_cast<QWidget*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QWidget(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QPaintDevice_Wrapper* ret = new QPaintDevice_Wrapper(handler, v, false);

          // JS: new QPaintDevice('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPaintDevice");
          if (cl.isUndefined()) {
              qWarning() << "Class QPaintDevice is undefined. Use QPaintDevice_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPaintDevice('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPaintDevice(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QPaintDevice* RJSHelper::js2cpp_QPaintDevice_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPaintDevice: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPaintDevice_Wrapper* wrapper = qobject_cast<QPaintDevice_Wrapper*>(obj);
          //QPaintDevice_Wrapper* wrapper = dynamic_cast<QPaintDevice_Wrapper*>(obj);
          //QPaintDevice_Wrapper* wrapper = (QPaintDevice_Wrapper*)(obj);
          //QPaintDevice_Wrapper* wrapper = getWrapper<QPaintDevice_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPaintDevice_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QPaintDevice(wrapper);
          return QPaintDevice_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPaintDevice_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPaintDevice: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QPaintDevice::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPaintEvent(RJSApi& handler, QPaintEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QPaintEvent_Wrapper* ret = new QPaintEvent_Wrapper(handler, v, false);

          // JS: new QPaintEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPaintEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QPaintEvent is undefined. Use QPaintEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPaintEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPaintEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QPaintEvent* RJSHelper::js2cpp_QPaintEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPaintEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPaintEvent_Wrapper* wrapper = qobject_cast<QPaintEvent_Wrapper*>(obj);
          //QPaintEvent_Wrapper* wrapper = dynamic_cast<QPaintEvent_Wrapper*>(obj);
          //QPaintEvent_Wrapper* wrapper = (QPaintEvent_Wrapper*)(obj);
          //QPaintEvent_Wrapper* wrapper = getWrapper<QPaintEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPaintEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QPaintEvent(wrapper);
          return QPaintEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPaintEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPaintEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QPaintEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPainter(RJSApi& handler, QPainter* v) {

          

          QJSEngine* engine = handler.getEngine();
          QPainter_Wrapper* ret = new QPainter_Wrapper(handler, v, false);

          // JS: new QPainter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPainter");
          if (cl.isUndefined()) {
              qWarning() << "Class QPainter is undefined. Use QPainter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPainter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPainter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QPainter* RJSHelper::js2cpp_QPainter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPainter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPainter_Wrapper* wrapper = qobject_cast<QPainter_Wrapper*>(obj);
          //QPainter_Wrapper* wrapper = dynamic_cast<QPainter_Wrapper*>(obj);
          //QPainter_Wrapper* wrapper = (QPainter_Wrapper*)(obj);
          //QPainter_Wrapper* wrapper = getWrapper<QPainter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPainter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QPainter(wrapper);
          return QPainter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPainter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPainter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QPainter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPanGesture(RJSApi& handler, QPanGesture* v) {

          

          QJSEngine* engine = handler.getEngine();
          QPanGesture_Wrapper* ret = new QPanGesture_Wrapper(handler, v, false);

          // JS: new QPanGesture('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPanGesture");
          if (cl.isUndefined()) {
              qWarning() << "Class QPanGesture is undefined. Use QPanGesture_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPanGesture('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPanGesture(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QPanGesture* RJSHelper::js2cpp_QPanGesture_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPanGesture: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPanGesture_Wrapper* wrapper = qobject_cast<QPanGesture_Wrapper*>(obj);
          //QPanGesture_Wrapper* wrapper = dynamic_cast<QPanGesture_Wrapper*>(obj);
          //QPanGesture_Wrapper* wrapper = (QPanGesture_Wrapper*)(obj);
          //QPanGesture_Wrapper* wrapper = getWrapper<QPanGesture_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPanGesture_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QPanGesture(wrapper);
          return QPanGesture_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPanGesture_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPanGesture: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QPanGesture::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPinchGesture(RJSApi& handler, QPinchGesture* v) {

          

          QJSEngine* engine = handler.getEngine();
          QPinchGesture_Wrapper* ret = new QPinchGesture_Wrapper(handler, v, false);

          // JS: new QPinchGesture('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPinchGesture");
          if (cl.isUndefined()) {
              qWarning() << "Class QPinchGesture is undefined. Use QPinchGesture_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPinchGesture('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPinchGesture(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QPinchGesture* RJSHelper::js2cpp_QPinchGesture_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPinchGesture: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPinchGesture_Wrapper* wrapper = qobject_cast<QPinchGesture_Wrapper*>(obj);
          //QPinchGesture_Wrapper* wrapper = dynamic_cast<QPinchGesture_Wrapper*>(obj);
          //QPinchGesture_Wrapper* wrapper = (QPinchGesture_Wrapper*)(obj);
          //QPinchGesture_Wrapper* wrapper = getWrapper<QPinchGesture_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPinchGesture_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QPinchGesture(wrapper);
          return QPinchGesture_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPinchGesture_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPinchGesture: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QPinchGesture::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPointerEvent(RJSApi& handler, QPointerEvent* v) {

          
            // downcast to QSinglePointEvent:
            {
                QSinglePointEvent* o = dynamic_cast<QSinglePointEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QSinglePointEvent(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QPointerEvent_Wrapper* ret = new QPointerEvent_Wrapper(handler, v, false);

          // JS: new QPointerEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPointerEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QPointerEvent is undefined. Use QPointerEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPointerEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPointerEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QPointerEvent* RJSHelper::js2cpp_QPointerEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPointerEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPointerEvent_Wrapper* wrapper = qobject_cast<QPointerEvent_Wrapper*>(obj);
          //QPointerEvent_Wrapper* wrapper = dynamic_cast<QPointerEvent_Wrapper*>(obj);
          //QPointerEvent_Wrapper* wrapper = (QPointerEvent_Wrapper*)(obj);
          //QPointerEvent_Wrapper* wrapper = getWrapper<QPointerEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPointerEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QPointerEvent(wrapper);
          return QPointerEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPointerEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPointerEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QPointerEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPrinter(RJSApi& handler, QPrinter* v) {

          

          QJSEngine* engine = handler.getEngine();
          QPrinter_Wrapper* ret = new QPrinter_Wrapper(handler, v, false);

          // JS: new QPrinter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPrinter");
          if (cl.isUndefined()) {
              qWarning() << "Class QPrinter is undefined. Use QPrinter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPrinter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPrinter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QPrinter* RJSHelper::js2cpp_QPrinter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPrinter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPrinter_Wrapper* wrapper = qobject_cast<QPrinter_Wrapper*>(obj);
          //QPrinter_Wrapper* wrapper = dynamic_cast<QPrinter_Wrapper*>(obj);
          //QPrinter_Wrapper* wrapper = (QPrinter_Wrapper*)(obj);
          //QPrinter_Wrapper* wrapper = getWrapper<QPrinter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPrinter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QPrinter(wrapper);
          return QPrinter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPrinter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPrinter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QPrinter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QProcess(RJSApi& handler, QProcess* v) {

          

          QJSEngine* engine = handler.getEngine();
          QProcess_Wrapper* ret = new QProcess_Wrapper(handler, v, false);

          // JS: new QProcess('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QProcess");
          if (cl.isUndefined()) {
              qWarning() << "Class QProcess is undefined. Use QProcess_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QProcess('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QProcess(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QProcess* RJSHelper::js2cpp_QProcess_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QProcess: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QProcess_Wrapper* wrapper = qobject_cast<QProcess_Wrapper*>(obj);
          //QProcess_Wrapper* wrapper = dynamic_cast<QProcess_Wrapper*>(obj);
          //QProcess_Wrapper* wrapper = (QProcess_Wrapper*)(obj);
          //QProcess_Wrapper* wrapper = getWrapper<QProcess_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QProcess_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QProcess(wrapper);
          return QProcess_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QProcess_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QProcess: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QProcess::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QQmlEngine(RJSApi& handler, QQmlEngine* v) {

          
            // downcast to QQmlApplicationEngine:
            {
                QQmlApplicationEngine* o = dynamic_cast<QQmlApplicationEngine*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QQmlApplicationEngine(handler, o);
                }
            }
          
            // downcast to types derrived from QQmlEngine but defined in other modules:
            for (int i=0; i<downcasters_QQmlEngine.length(); i++) {
                QJSValue dc = downcasters_QQmlEngine[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QQmlEngine_Wrapper* ret = new QQmlEngine_Wrapper(handler, v, false);

          // JS: new QQmlEngine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QQmlEngine");
          if (cl.isUndefined()) {
              qWarning() << "Class QQmlEngine is undefined. Use QQmlEngine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QQmlEngine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QQmlEngine(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QQmlEngine* RJSHelper::js2cpp_QQmlEngine_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QQmlEngine: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QQmlEngine_Wrapper* wrapper = qobject_cast<QQmlEngine_Wrapper*>(obj);
          //QQmlEngine_Wrapper* wrapper = dynamic_cast<QQmlEngine_Wrapper*>(obj);
          //QQmlEngine_Wrapper* wrapper = (QQmlEngine_Wrapper*)(obj);
          //QQmlEngine_Wrapper* wrapper = getWrapper<QQmlEngine_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QQmlEngine_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QQmlEngine(wrapper);
          return QQmlEngine_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QQmlEngine_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QQmlEngine: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QQmlEngine::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QQmlContext(RJSApi& handler, QQmlContext* v) {

          

          QJSEngine* engine = handler.getEngine();
          QQmlContext_Wrapper* ret = new QQmlContext_Wrapper(handler, v, false);

          // JS: new QQmlContext('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QQmlContext");
          if (cl.isUndefined()) {
              qWarning() << "Class QQmlContext is undefined. Use QQmlContext_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QQmlContext('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QQmlContext(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QQmlContext* RJSHelper::js2cpp_QQmlContext_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QQmlContext: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QQmlContext_Wrapper* wrapper = qobject_cast<QQmlContext_Wrapper*>(obj);
          //QQmlContext_Wrapper* wrapper = dynamic_cast<QQmlContext_Wrapper*>(obj);
          //QQmlContext_Wrapper* wrapper = (QQmlContext_Wrapper*)(obj);
          //QQmlContext_Wrapper* wrapper = getWrapper<QQmlContext_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QQmlContext_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QQmlContext(wrapper);
          return QQmlContext_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QQmlContext_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QQmlContext: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QQmlContext::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QQmlApplicationEngine(RJSApi& handler, QQmlApplicationEngine* v) {

          

          QJSEngine* engine = handler.getEngine();
          QQmlApplicationEngine_Wrapper* ret = new QQmlApplicationEngine_Wrapper(handler, v, false);

          // JS: new QQmlApplicationEngine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QQmlApplicationEngine");
          if (cl.isUndefined()) {
              qWarning() << "Class QQmlApplicationEngine is undefined. Use QQmlApplicationEngine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QQmlApplicationEngine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QQmlApplicationEngine(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QQmlApplicationEngine* RJSHelper::js2cpp_QQmlApplicationEngine_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QQmlApplicationEngine: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QQmlApplicationEngine_Wrapper* wrapper = qobject_cast<QQmlApplicationEngine_Wrapper*>(obj);
          //QQmlApplicationEngine_Wrapper* wrapper = dynamic_cast<QQmlApplicationEngine_Wrapper*>(obj);
          //QQmlApplicationEngine_Wrapper* wrapper = (QQmlApplicationEngine_Wrapper*)(obj);
          //QQmlApplicationEngine_Wrapper* wrapper = getWrapper<QQmlApplicationEngine_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QQmlApplicationEngine_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QQmlApplicationEngine(wrapper);
          return QQmlApplicationEngine_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QQmlApplicationEngine_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QQmlApplicationEngine: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QQmlApplicationEngine::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QResizeEvent(RJSApi& handler, QResizeEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QResizeEvent_Wrapper* ret = new QResizeEvent_Wrapper(handler, v, false);

          // JS: new QResizeEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QResizeEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QResizeEvent is undefined. Use QResizeEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QResizeEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QResizeEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QResizeEvent* RJSHelper::js2cpp_QResizeEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QResizeEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QResizeEvent_Wrapper* wrapper = qobject_cast<QResizeEvent_Wrapper*>(obj);
          //QResizeEvent_Wrapper* wrapper = dynamic_cast<QResizeEvent_Wrapper*>(obj);
          //QResizeEvent_Wrapper* wrapper = (QResizeEvent_Wrapper*)(obj);
          //QResizeEvent_Wrapper* wrapper = getWrapper<QResizeEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QResizeEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QResizeEvent(wrapper);
          return QResizeEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QResizeEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QResizeEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QResizeEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QSinglePointEvent(RJSApi& handler, QSinglePointEvent* v) {

          
            // downcast to QMouseEvent:
            {
                QMouseEvent* o = dynamic_cast<QMouseEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QMouseEvent(handler, o);
                }
            }
          
            // downcast to QWheelEvent:
            {
                QWheelEvent* o = dynamic_cast<QWheelEvent*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QWheelEvent(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QSinglePointEvent_Wrapper* ret = new QSinglePointEvent_Wrapper(handler, v, false);

          // JS: new QSinglePointEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSinglePointEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QSinglePointEvent is undefined. Use QSinglePointEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSinglePointEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSinglePointEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QSinglePointEvent* RJSHelper::js2cpp_QSinglePointEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSinglePointEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSinglePointEvent_Wrapper* wrapper = qobject_cast<QSinglePointEvent_Wrapper*>(obj);
          //QSinglePointEvent_Wrapper* wrapper = dynamic_cast<QSinglePointEvent_Wrapper*>(obj);
          //QSinglePointEvent_Wrapper* wrapper = (QSinglePointEvent_Wrapper*)(obj);
          //QSinglePointEvent_Wrapper* wrapper = getWrapper<QSinglePointEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSinglePointEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QSinglePointEvent(wrapper);
          return QSinglePointEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSinglePointEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSinglePointEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QSinglePointEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QSpacerItem(RJSApi& handler, QSpacerItem* v) {

          

          QJSEngine* engine = handler.getEngine();
          QSpacerItem_Wrapper* ret = new QSpacerItem_Wrapper(handler, v, false);

          // JS: new QSpacerItem('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSpacerItem");
          if (cl.isUndefined()) {
              qWarning() << "Class QSpacerItem is undefined. Use QSpacerItem_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSpacerItem('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSpacerItem(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QSpacerItem* RJSHelper::js2cpp_QSpacerItem_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSpacerItem: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSpacerItem_Wrapper* wrapper = qobject_cast<QSpacerItem_Wrapper*>(obj);
          //QSpacerItem_Wrapper* wrapper = dynamic_cast<QSpacerItem_Wrapper*>(obj);
          //QSpacerItem_Wrapper* wrapper = (QSpacerItem_Wrapper*)(obj);
          //QSpacerItem_Wrapper* wrapper = getWrapper<QSpacerItem_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSpacerItem_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QSpacerItem(wrapper);
          return QSpacerItem_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSpacerItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSpacerItem: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QSpacerItem::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QStandardItem(RJSApi& handler, QStandardItem* v) {

          

          QJSEngine* engine = handler.getEngine();
          QStandardItem_Wrapper* ret = new QStandardItem_Wrapper(handler, v, false);

          // JS: new QStandardItem('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QStandardItem");
          if (cl.isUndefined()) {
              qWarning() << "Class QStandardItem is undefined. Use QStandardItem_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QStandardItem('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QStandardItem(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QStandardItem* RJSHelper::js2cpp_QStandardItem_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QStandardItem: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QStandardItem_Wrapper* wrapper = qobject_cast<QStandardItem_Wrapper*>(obj);
          //QStandardItem_Wrapper* wrapper = dynamic_cast<QStandardItem_Wrapper*>(obj);
          //QStandardItem_Wrapper* wrapper = (QStandardItem_Wrapper*)(obj);
          //QStandardItem_Wrapper* wrapper = getWrapper<QStandardItem_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QStandardItem_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QStandardItem(wrapper);
          return QStandardItem_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QStandardItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QStandardItem: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QStandardItem::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QStringConverter(RJSApi& handler, QStringConverter* v) {

          

          QJSEngine* engine = handler.getEngine();
          QStringConverter_Wrapper* ret = new QStringConverter_Wrapper(handler, v, false);

          // JS: new QStringConverter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QStringConverter");
          if (cl.isUndefined()) {
              qWarning() << "Class QStringConverter is undefined. Use QStringConverter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QStringConverter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QStringConverter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QStringConverter* RJSHelper::js2cpp_QStringConverter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QStringConverter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QStringConverter_Wrapper* wrapper = qobject_cast<QStringConverter_Wrapper*>(obj);
          //QStringConverter_Wrapper* wrapper = dynamic_cast<QStringConverter_Wrapper*>(obj);
          //QStringConverter_Wrapper* wrapper = (QStringConverter_Wrapper*)(obj);
          //QStringConverter_Wrapper* wrapper = getWrapper<QStringConverter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QStringConverter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QStringConverter(wrapper);
          return QStringConverter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QStringConverter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QStringConverter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QStringConverter::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QStringDecoder(RJSApi& handler, QStringDecoder* v) {

          

          QJSEngine* engine = handler.getEngine();
          QStringDecoder_Wrapper* ret = new QStringDecoder_Wrapper(handler, v, false);

          // JS: new QStringDecoder('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QStringDecoder");
          if (cl.isUndefined()) {
              qWarning() << "Class QStringDecoder is undefined. Use QStringDecoder_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QStringDecoder('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QStringDecoder(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QStringDecoder* RJSHelper::js2cpp_QStringDecoder_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QStringDecoder: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QStringDecoder_Wrapper* wrapper = qobject_cast<QStringDecoder_Wrapper*>(obj);
          //QStringDecoder_Wrapper* wrapper = dynamic_cast<QStringDecoder_Wrapper*>(obj);
          //QStringDecoder_Wrapper* wrapper = (QStringDecoder_Wrapper*)(obj);
          //QStringDecoder_Wrapper* wrapper = getWrapper<QStringDecoder_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QStringDecoder_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QStringDecoder(wrapper);
          return QStringDecoder_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QStringDecoder_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QStringDecoder: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QStringDecoder::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QStringEncoder(RJSApi& handler, QStringEncoder* v) {

          

          QJSEngine* engine = handler.getEngine();
          QStringEncoder_Wrapper* ret = new QStringEncoder_Wrapper(handler, v, false);

          // JS: new QStringEncoder('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QStringEncoder");
          if (cl.isUndefined()) {
              qWarning() << "Class QStringEncoder is undefined. Use QStringEncoder_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QStringEncoder('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QStringEncoder(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QStringEncoder* RJSHelper::js2cpp_QStringEncoder_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QStringEncoder: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QStringEncoder_Wrapper* wrapper = qobject_cast<QStringEncoder_Wrapper*>(obj);
          //QStringEncoder_Wrapper* wrapper = dynamic_cast<QStringEncoder_Wrapper*>(obj);
          //QStringEncoder_Wrapper* wrapper = (QStringEncoder_Wrapper*)(obj);
          //QStringEncoder_Wrapper* wrapper = getWrapper<QStringEncoder_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QStringEncoder_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QStringEncoder(wrapper);
          return QStringEncoder_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QStringEncoder_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QStringEncoder: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QStringEncoder::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QSwipeGesture(RJSApi& handler, QSwipeGesture* v) {

          

          QJSEngine* engine = handler.getEngine();
          QSwipeGesture_Wrapper* ret = new QSwipeGesture_Wrapper(handler, v, false);

          // JS: new QSwipeGesture('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSwipeGesture");
          if (cl.isUndefined()) {
              qWarning() << "Class QSwipeGesture is undefined. Use QSwipeGesture_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSwipeGesture('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSwipeGesture(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QSwipeGesture* RJSHelper::js2cpp_QSwipeGesture_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSwipeGesture: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSwipeGesture_Wrapper* wrapper = qobject_cast<QSwipeGesture_Wrapper*>(obj);
          //QSwipeGesture_Wrapper* wrapper = dynamic_cast<QSwipeGesture_Wrapper*>(obj);
          //QSwipeGesture_Wrapper* wrapper = (QSwipeGesture_Wrapper*)(obj);
          //QSwipeGesture_Wrapper* wrapper = getWrapper<QSwipeGesture_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSwipeGesture_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QSwipeGesture(wrapper);
          return QSwipeGesture_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSwipeGesture_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSwipeGesture: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QSwipeGesture::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTableWidgetItem(RJSApi& handler, QTableWidgetItem* v) {

          

          QJSEngine* engine = handler.getEngine();
          QTableWidgetItem_Wrapper* ret = new QTableWidgetItem_Wrapper(handler, v, false);

          // JS: new QTableWidgetItem('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTableWidgetItem");
          if (cl.isUndefined()) {
              qWarning() << "Class QTableWidgetItem is undefined. Use QTableWidgetItem_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTableWidgetItem('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTableWidgetItem(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QTableWidgetItem* RJSHelper::js2cpp_QTableWidgetItem_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTableWidgetItem: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTableWidgetItem_Wrapper* wrapper = qobject_cast<QTableWidgetItem_Wrapper*>(obj);
          //QTableWidgetItem_Wrapper* wrapper = dynamic_cast<QTableWidgetItem_Wrapper*>(obj);
          //QTableWidgetItem_Wrapper* wrapper = (QTableWidgetItem_Wrapper*)(obj);
          //QTableWidgetItem_Wrapper* wrapper = getWrapper<QTableWidgetItem_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTableWidgetItem_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QTableWidgetItem(wrapper);
          return QTableWidgetItem_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTableWidgetItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTableWidgetItem: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QTableWidgetItem::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextCursor(RJSApi& handler, QTextCursor* v) {

          

          QJSEngine* engine = handler.getEngine();
          QTextCursor_Wrapper* ret = new QTextCursor_Wrapper(handler, v, false);

          // JS: new QTextCursor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextCursor");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextCursor is undefined. Use QTextCursor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextCursor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextCursor(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QTextCursor* RJSHelper::js2cpp_QTextCursor_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextCursor: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTextCursor_Wrapper* wrapper = qobject_cast<QTextCursor_Wrapper*>(obj);
          //QTextCursor_Wrapper* wrapper = dynamic_cast<QTextCursor_Wrapper*>(obj);
          //QTextCursor_Wrapper* wrapper = (QTextCursor_Wrapper*)(obj);
          //QTextCursor_Wrapper* wrapper = getWrapper<QTextCursor_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextCursor_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QTextCursor(wrapper);
          return QTextCursor_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTextCursor_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextCursor: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QTextCursor::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextLayout(RJSApi& handler, QTextLayout* v) {

          

          QJSEngine* engine = handler.getEngine();
          QTextLayout_Wrapper* ret = new QTextLayout_Wrapper(handler, v, false);

          // JS: new QTextLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextLayout is undefined. Use QTextLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextLayout('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QTextLayout* RJSHelper::js2cpp_QTextLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextLayout: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTextLayout_Wrapper* wrapper = qobject_cast<QTextLayout_Wrapper*>(obj);
          //QTextLayout_Wrapper* wrapper = dynamic_cast<QTextLayout_Wrapper*>(obj);
          //QTextLayout_Wrapper* wrapper = (QTextLayout_Wrapper*)(obj);
          //QTextLayout_Wrapper* wrapper = getWrapper<QTextLayout_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextLayout_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QTextLayout(wrapper);
          return QTextLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTextLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QTextLayout::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextStream(RJSApi& handler, QTextStream* v) {

          

          QJSEngine* engine = handler.getEngine();
          QTextStream_Wrapper* ret = new QTextStream_Wrapper(handler, v, false);

          // JS: new QTextStream('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextStream");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextStream is undefined. Use QTextStream_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextStream('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextStream(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QTextStream* RJSHelper::js2cpp_QTextStream_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextStream: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTextStream_Wrapper* wrapper = qobject_cast<QTextStream_Wrapper*>(obj);
          //QTextStream_Wrapper* wrapper = dynamic_cast<QTextStream_Wrapper*>(obj);
          //QTextStream_Wrapper* wrapper = (QTextStream_Wrapper*)(obj);
          //QTextStream_Wrapper* wrapper = getWrapper<QTextStream_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextStream_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QTextStream(wrapper);
          return QTextStream_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTextStream_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextStream: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QTextStream::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QToolTip(RJSApi& handler, QToolTip* v) {

          

          QJSEngine* engine = handler.getEngine();
          QToolTip_Wrapper* ret = new QToolTip_Wrapper(handler, v, false);

          // JS: new QToolTip('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QToolTip");
          if (cl.isUndefined()) {
              qWarning() << "Class QToolTip is undefined. Use QToolTip_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QToolTip('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QToolTip(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QToolTip* RJSHelper::js2cpp_QToolTip_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QToolTip: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QToolTip_Wrapper* wrapper = qobject_cast<QToolTip_Wrapper*>(obj);
          //QToolTip_Wrapper* wrapper = dynamic_cast<QToolTip_Wrapper*>(obj);
          //QToolTip_Wrapper* wrapper = (QToolTip_Wrapper*)(obj);
          //QToolTip_Wrapper* wrapper = getWrapper<QToolTip_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QToolTip_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QToolTip(wrapper);
          return QToolTip_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QToolTip_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QToolTip: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QToolTip::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTreeWidgetItem(RJSApi& handler, QTreeWidgetItem* v) {

          

          QJSEngine* engine = handler.getEngine();
          QTreeWidgetItem_Wrapper* ret = new QTreeWidgetItem_Wrapper(handler, v, false);

          // JS: new QTreeWidgetItem('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTreeWidgetItem");
          if (cl.isUndefined()) {
              qWarning() << "Class QTreeWidgetItem is undefined. Use QTreeWidgetItem_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTreeWidgetItem('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTreeWidgetItem(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QTreeWidgetItem* RJSHelper::js2cpp_QTreeWidgetItem_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTreeWidgetItem: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTreeWidgetItem_Wrapper* wrapper = qobject_cast<QTreeWidgetItem_Wrapper*>(obj);
          //QTreeWidgetItem_Wrapper* wrapper = dynamic_cast<QTreeWidgetItem_Wrapper*>(obj);
          //QTreeWidgetItem_Wrapper* wrapper = (QTreeWidgetItem_Wrapper*)(obj);
          //QTreeWidgetItem_Wrapper* wrapper = getWrapper<QTreeWidgetItem_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTreeWidgetItem_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QTreeWidgetItem(wrapper);
          return QTreeWidgetItem_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTreeWidgetItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTreeWidgetItem: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QTreeWidgetItem::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QUiLoader(RJSApi& handler, QUiLoader* v) {

          

          QJSEngine* engine = handler.getEngine();
          QUiLoader_Wrapper* ret = new QUiLoader_Wrapper(handler, v, false);

          // JS: new QUiLoader('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QUiLoader");
          if (cl.isUndefined()) {
              qWarning() << "Class QUiLoader is undefined. Use QUiLoader_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QUiLoader('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QUiLoader(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QUiLoader* RJSHelper::js2cpp_QUiLoader_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QUiLoader: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QUiLoader_Wrapper* wrapper = qobject_cast<QUiLoader_Wrapper*>(obj);
          //QUiLoader_Wrapper* wrapper = dynamic_cast<QUiLoader_Wrapper*>(obj);
          //QUiLoader_Wrapper* wrapper = (QUiLoader_Wrapper*)(obj);
          //QUiLoader_Wrapper* wrapper = getWrapper<QUiLoader_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QUiLoader_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QUiLoader(wrapper);
          return QUiLoader_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QUiLoader_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QUiLoader: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QUiLoader::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QWheelEvent(RJSApi& handler, QWheelEvent* v) {

          

          QJSEngine* engine = handler.getEngine();
          QWheelEvent_Wrapper* ret = new QWheelEvent_Wrapper(handler, v, false);

          // JS: new QWheelEvent('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QWheelEvent");
          if (cl.isUndefined()) {
              qWarning() << "Class QWheelEvent is undefined. Use QWheelEvent_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QWheelEvent('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QWheelEvent(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QWheelEvent* RJSHelper::js2cpp_QWheelEvent_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QWheelEvent: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QWheelEvent_Wrapper* wrapper = qobject_cast<QWheelEvent_Wrapper*>(obj);
          //QWheelEvent_Wrapper* wrapper = dynamic_cast<QWheelEvent_Wrapper*>(obj);
          //QWheelEvent_Wrapper* wrapper = (QWheelEvent_Wrapper*)(obj);
          //QWheelEvent_Wrapper* wrapper = getWrapper<QWheelEvent_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QWheelEvent_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QWheelEvent(wrapper);
          return QWheelEvent_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QWheelEvent_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QWheelEvent: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QWheelEvent::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QWidgetItem(RJSApi& handler, QWidgetItem* v) {

          

          QJSEngine* engine = handler.getEngine();
          QWidgetItem_Wrapper* ret = new QWidgetItem_Wrapper(handler, v, false);

          // JS: new QWidgetItem('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QWidgetItem");
          if (cl.isUndefined()) {
              qWarning() << "Class QWidgetItem is undefined. Use QWidgetItem_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QWidgetItem('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QWidgetItem(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QWidgetItem* RJSHelper::js2cpp_QWidgetItem_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QWidgetItem: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QWidgetItem_Wrapper* wrapper = qobject_cast<QWidgetItem_Wrapper*>(obj);
          //QWidgetItem_Wrapper* wrapper = dynamic_cast<QWidgetItem_Wrapper*>(obj);
          //QWidgetItem_Wrapper* wrapper = (QWidgetItem_Wrapper*)(obj);
          //QWidgetItem_Wrapper* wrapper = getWrapper<QWidgetItem_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QWidgetItem_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QWidgetItem(wrapper);
          return QWidgetItem_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QWidgetItem_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QWidgetItem: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QWidgetItem::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlContentHandler(RJSApi& handler, QXmlContentHandler* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlContentHandler_Wrapper* ret = new QXmlContentHandler_Wrapper(handler, v, false);

          // JS: new QXmlContentHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlContentHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlContentHandler is undefined. Use QXmlContentHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlContentHandler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlContentHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlContentHandler* RJSHelper::js2cpp_QXmlContentHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlContentHandler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlContentHandler_Wrapper* wrapper = qobject_cast<QXmlContentHandler_Wrapper*>(obj);
          //QXmlContentHandler_Wrapper* wrapper = dynamic_cast<QXmlContentHandler_Wrapper*>(obj);
          //QXmlContentHandler_Wrapper* wrapper = (QXmlContentHandler_Wrapper*)(obj);
          //QXmlContentHandler_Wrapper* wrapper = getWrapper<QXmlContentHandler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlContentHandler_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlContentHandler(wrapper);
          return QXmlContentHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlContentHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlContentHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlContentHandler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlDTDHandler(RJSApi& handler, QXmlDTDHandler* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlDTDHandler_Wrapper* ret = new QXmlDTDHandler_Wrapper(handler, v, false);

          // JS: new QXmlDTDHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlDTDHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlDTDHandler is undefined. Use QXmlDTDHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlDTDHandler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlDTDHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlDTDHandler* RJSHelper::js2cpp_QXmlDTDHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlDTDHandler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlDTDHandler_Wrapper* wrapper = qobject_cast<QXmlDTDHandler_Wrapper*>(obj);
          //QXmlDTDHandler_Wrapper* wrapper = dynamic_cast<QXmlDTDHandler_Wrapper*>(obj);
          //QXmlDTDHandler_Wrapper* wrapper = (QXmlDTDHandler_Wrapper*)(obj);
          //QXmlDTDHandler_Wrapper* wrapper = getWrapper<QXmlDTDHandler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlDTDHandler_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlDTDHandler(wrapper);
          return QXmlDTDHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlDTDHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlDTDHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlDTDHandler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlDeclHandler(RJSApi& handler, QXmlDeclHandler* v) {

          
            // downcast to QXmlDefaultHandler:
            {
                QXmlDefaultHandler* o = dynamic_cast<QXmlDefaultHandler*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QXmlDefaultHandler(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QXmlDeclHandler_Wrapper* ret = new QXmlDeclHandler_Wrapper(handler, v, false);

          // JS: new QXmlDeclHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlDeclHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlDeclHandler is undefined. Use QXmlDeclHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlDeclHandler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlDeclHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlDeclHandler* RJSHelper::js2cpp_QXmlDeclHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlDeclHandler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlDeclHandler_Wrapper* wrapper = qobject_cast<QXmlDeclHandler_Wrapper*>(obj);
          //QXmlDeclHandler_Wrapper* wrapper = dynamic_cast<QXmlDeclHandler_Wrapper*>(obj);
          //QXmlDeclHandler_Wrapper* wrapper = (QXmlDeclHandler_Wrapper*)(obj);
          //QXmlDeclHandler_Wrapper* wrapper = getWrapper<QXmlDeclHandler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlDeclHandler_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlDeclHandler(wrapper);
          return QXmlDeclHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlDeclHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlDeclHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlDeclHandler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlDefaultHandler(RJSApi& handler, QXmlDefaultHandler* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlDefaultHandler_Wrapper* ret = new QXmlDefaultHandler_Wrapper(handler, v, false);

          // JS: new QXmlDefaultHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlDefaultHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlDefaultHandler is undefined. Use QXmlDefaultHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlDefaultHandler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlDefaultHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlDefaultHandler* RJSHelper::js2cpp_QXmlDefaultHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlDefaultHandler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlDefaultHandler_Wrapper* wrapper = qobject_cast<QXmlDefaultHandler_Wrapper*>(obj);
          //QXmlDefaultHandler_Wrapper* wrapper = dynamic_cast<QXmlDefaultHandler_Wrapper*>(obj);
          //QXmlDefaultHandler_Wrapper* wrapper = (QXmlDefaultHandler_Wrapper*)(obj);
          //QXmlDefaultHandler_Wrapper* wrapper = getWrapper<QXmlDefaultHandler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlDefaultHandler_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlDefaultHandler(wrapper);
          return QXmlDefaultHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlDefaultHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlDefaultHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlDefaultHandler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlEntityResolver(RJSApi& handler, QXmlEntityResolver* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlEntityResolver_Wrapper* ret = new QXmlEntityResolver_Wrapper(handler, v, false);

          // JS: new QXmlEntityResolver('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlEntityResolver");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlEntityResolver is undefined. Use QXmlEntityResolver_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlEntityResolver('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlEntityResolver(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlEntityResolver* RJSHelper::js2cpp_QXmlEntityResolver_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlEntityResolver: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlEntityResolver_Wrapper* wrapper = qobject_cast<QXmlEntityResolver_Wrapper*>(obj);
          //QXmlEntityResolver_Wrapper* wrapper = dynamic_cast<QXmlEntityResolver_Wrapper*>(obj);
          //QXmlEntityResolver_Wrapper* wrapper = (QXmlEntityResolver_Wrapper*)(obj);
          //QXmlEntityResolver_Wrapper* wrapper = getWrapper<QXmlEntityResolver_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlEntityResolver_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlEntityResolver(wrapper);
          return QXmlEntityResolver_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlEntityResolver_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlEntityResolver: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlEntityResolver::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlErrorHandler(RJSApi& handler, QXmlErrorHandler* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlErrorHandler_Wrapper* ret = new QXmlErrorHandler_Wrapper(handler, v, false);

          // JS: new QXmlErrorHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlErrorHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlErrorHandler is undefined. Use QXmlErrorHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlErrorHandler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlErrorHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlErrorHandler* RJSHelper::js2cpp_QXmlErrorHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlErrorHandler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlErrorHandler_Wrapper* wrapper = qobject_cast<QXmlErrorHandler_Wrapper*>(obj);
          //QXmlErrorHandler_Wrapper* wrapper = dynamic_cast<QXmlErrorHandler_Wrapper*>(obj);
          //QXmlErrorHandler_Wrapper* wrapper = (QXmlErrorHandler_Wrapper*)(obj);
          //QXmlErrorHandler_Wrapper* wrapper = getWrapper<QXmlErrorHandler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlErrorHandler_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlErrorHandler(wrapper);
          return QXmlErrorHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlErrorHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlErrorHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlErrorHandler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlInputSource(RJSApi& handler, QXmlInputSource* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlInputSource_Wrapper* ret = new QXmlInputSource_Wrapper(handler, v, false);

          // JS: new QXmlInputSource('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlInputSource");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlInputSource is undefined. Use QXmlInputSource_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlInputSource('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlInputSource(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlInputSource* RJSHelper::js2cpp_QXmlInputSource_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlInputSource: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlInputSource_Wrapper* wrapper = qobject_cast<QXmlInputSource_Wrapper*>(obj);
          //QXmlInputSource_Wrapper* wrapper = dynamic_cast<QXmlInputSource_Wrapper*>(obj);
          //QXmlInputSource_Wrapper* wrapper = (QXmlInputSource_Wrapper*)(obj);
          //QXmlInputSource_Wrapper* wrapper = getWrapper<QXmlInputSource_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlInputSource_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlInputSource(wrapper);
          return QXmlInputSource_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlInputSource_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlInputSource: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlInputSource::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlLexicalHandler(RJSApi& handler, QXmlLexicalHandler* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlLexicalHandler_Wrapper* ret = new QXmlLexicalHandler_Wrapper(handler, v, false);

          // JS: new QXmlLexicalHandler('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlLexicalHandler");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlLexicalHandler is undefined. Use QXmlLexicalHandler_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlLexicalHandler('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlLexicalHandler(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlLexicalHandler* RJSHelper::js2cpp_QXmlLexicalHandler_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlLexicalHandler: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlLexicalHandler_Wrapper* wrapper = qobject_cast<QXmlLexicalHandler_Wrapper*>(obj);
          //QXmlLexicalHandler_Wrapper* wrapper = dynamic_cast<QXmlLexicalHandler_Wrapper*>(obj);
          //QXmlLexicalHandler_Wrapper* wrapper = (QXmlLexicalHandler_Wrapper*)(obj);
          //QXmlLexicalHandler_Wrapper* wrapper = getWrapper<QXmlLexicalHandler_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlLexicalHandler_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlLexicalHandler(wrapper);
          return QXmlLexicalHandler_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlLexicalHandler_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlLexicalHandler: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlLexicalHandler::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlLocator(RJSApi& handler, QXmlLocator* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlLocator_Wrapper* ret = new QXmlLocator_Wrapper(handler, v, false);

          // JS: new QXmlLocator('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlLocator");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlLocator is undefined. Use QXmlLocator_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlLocator('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlLocator(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlLocator* RJSHelper::js2cpp_QXmlLocator_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlLocator: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlLocator_Wrapper* wrapper = qobject_cast<QXmlLocator_Wrapper*>(obj);
          //QXmlLocator_Wrapper* wrapper = dynamic_cast<QXmlLocator_Wrapper*>(obj);
          //QXmlLocator_Wrapper* wrapper = (QXmlLocator_Wrapper*)(obj);
          //QXmlLocator_Wrapper* wrapper = getWrapper<QXmlLocator_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlLocator_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlLocator(wrapper);
          return QXmlLocator_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlLocator_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlLocator: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlLocator::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlParseException(RJSApi& handler, QXmlParseException* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlParseException_Wrapper* ret = new QXmlParseException_Wrapper(handler, v, false);

          // JS: new QXmlParseException('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlParseException");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlParseException is undefined. Use QXmlParseException_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlParseException('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlParseException(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlParseException* RJSHelper::js2cpp_QXmlParseException_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlParseException: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlParseException_Wrapper* wrapper = qobject_cast<QXmlParseException_Wrapper*>(obj);
          //QXmlParseException_Wrapper* wrapper = dynamic_cast<QXmlParseException_Wrapper*>(obj);
          //QXmlParseException_Wrapper* wrapper = (QXmlParseException_Wrapper*)(obj);
          //QXmlParseException_Wrapper* wrapper = getWrapper<QXmlParseException_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlParseException_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlParseException(wrapper);
          return QXmlParseException_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlParseException_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlParseException: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlParseException::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlReader(RJSApi& handler, QXmlReader* v) {

          
            // downcast to QXmlSimpleReader:
            {
                QXmlSimpleReader* o = dynamic_cast<QXmlSimpleReader*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QXmlSimpleReader(handler, o);
                }
            }
          

          QJSEngine* engine = handler.getEngine();
          QXmlReader_Wrapper* ret = new QXmlReader_Wrapper(handler, v, false);

          // JS: new QXmlReader('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlReader");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlReader is undefined. Use QXmlReader_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlReader('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlReader(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlReader* RJSHelper::js2cpp_QXmlReader_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlReader: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlReader_Wrapper* wrapper = qobject_cast<QXmlReader_Wrapper*>(obj);
          //QXmlReader_Wrapper* wrapper = dynamic_cast<QXmlReader_Wrapper*>(obj);
          //QXmlReader_Wrapper* wrapper = (QXmlReader_Wrapper*)(obj);
          //QXmlReader_Wrapper* wrapper = getWrapper<QXmlReader_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlReader_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlReader(wrapper);
          return QXmlReader_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlReader_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlReader: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlReader::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlSimpleReader(RJSApi& handler, QXmlSimpleReader* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlSimpleReader_Wrapper* ret = new QXmlSimpleReader_Wrapper(handler, v, false);

          // JS: new QXmlSimpleReader('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlSimpleReader");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlSimpleReader is undefined. Use QXmlSimpleReader_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlSimpleReader('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlSimpleReader(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlSimpleReader* RJSHelper::js2cpp_QXmlSimpleReader_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlSimpleReader: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlSimpleReader_Wrapper* wrapper = qobject_cast<QXmlSimpleReader_Wrapper*>(obj);
          //QXmlSimpleReader_Wrapper* wrapper = dynamic_cast<QXmlSimpleReader_Wrapper*>(obj);
          //QXmlSimpleReader_Wrapper* wrapper = (QXmlSimpleReader_Wrapper*)(obj);
          //QXmlSimpleReader_Wrapper* wrapper = getWrapper<QXmlSimpleReader_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlSimpleReader_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlSimpleReader(wrapper);
          return QXmlSimpleReader_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlSimpleReader_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlSimpleReader: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlSimpleReader::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlStreamAttribute(RJSApi& handler, QXmlStreamAttribute* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlStreamAttribute_Wrapper* ret = new QXmlStreamAttribute_Wrapper(handler, v, false);

          // JS: new QXmlStreamAttribute('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlStreamAttribute");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlStreamAttribute is undefined. Use QXmlStreamAttribute_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlStreamAttribute('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlStreamAttribute(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlStreamAttribute* RJSHelper::js2cpp_QXmlStreamAttribute_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlStreamAttribute: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlStreamAttribute_Wrapper* wrapper = qobject_cast<QXmlStreamAttribute_Wrapper*>(obj);
          //QXmlStreamAttribute_Wrapper* wrapper = dynamic_cast<QXmlStreamAttribute_Wrapper*>(obj);
          //QXmlStreamAttribute_Wrapper* wrapper = (QXmlStreamAttribute_Wrapper*)(obj);
          //QXmlStreamAttribute_Wrapper* wrapper = getWrapper<QXmlStreamAttribute_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlStreamAttribute_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlStreamAttribute(wrapper);
          return QXmlStreamAttribute_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlStreamAttribute_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlStreamAttribute: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlStreamAttribute::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlStreamReader(RJSApi& handler, QXmlStreamReader* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlStreamReader_Wrapper* ret = new QXmlStreamReader_Wrapper(handler, v, false);

          // JS: new QXmlStreamReader('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlStreamReader");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlStreamReader is undefined. Use QXmlStreamReader_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlStreamReader('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlStreamReader(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlStreamReader* RJSHelper::js2cpp_QXmlStreamReader_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlStreamReader: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlStreamReader_Wrapper* wrapper = qobject_cast<QXmlStreamReader_Wrapper*>(obj);
          //QXmlStreamReader_Wrapper* wrapper = dynamic_cast<QXmlStreamReader_Wrapper*>(obj);
          //QXmlStreamReader_Wrapper* wrapper = (QXmlStreamReader_Wrapper*)(obj);
          //QXmlStreamReader_Wrapper* wrapper = getWrapper<QXmlStreamReader_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlStreamReader_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlStreamReader(wrapper);
          return QXmlStreamReader_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlStreamReader_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlStreamReader: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlStreamReader::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlStreamWriter(RJSApi& handler, QXmlStreamWriter* v) {

          

          QJSEngine* engine = handler.getEngine();
          QXmlStreamWriter_Wrapper* ret = new QXmlStreamWriter_Wrapper(handler, v, false);

          // JS: new QXmlStreamWriter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlStreamWriter");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlStreamWriter is undefined. Use QXmlStreamWriter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlStreamWriter('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlStreamWriter(wrapper)"
                      << ":" << r.toString();
          }
          return r;

          //return engine->newQObject(ret);
      }

      QXmlStreamWriter* RJSHelper::js2cpp_QXmlStreamWriter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlStreamWriter: not a QObject";
              return nullptr;
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QXmlStreamWriter_Wrapper* wrapper = qobject_cast<QXmlStreamWriter_Wrapper*>(obj);
          //QXmlStreamWriter_Wrapper* wrapper = dynamic_cast<QXmlStreamWriter_Wrapper*>(obj);
          //QXmlStreamWriter_Wrapper* wrapper = (QXmlStreamWriter_Wrapper*)(obj);
          //QXmlStreamWriter_Wrapper* wrapper = getWrapper<QXmlStreamWriter_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlStreamWriter_ptr: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return getWrapped_QXmlStreamWriter(wrapper);
          return QXmlStreamWriter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QXmlStreamWriter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          if (v.isNumber()) {
              return v.toInt()==0;
          }
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlStreamWriter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              // type is for example string, number, etc.:
              return false;
          }
          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlStreamWriter::getIdStatic())).toBool();
      }
    