
  // Automatically generated, do not edit
  
          #include "RJSHelper.h"
        
          #include "header_cpp.h"
        
        #include "qabstractbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qabstractfileiconprovider_wrapper.h"
        
        #include "qabstractitemdelegate_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qmodelindex_wrapper.h"
        
        #include "qabstractitemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qabstracttablemodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
        #include "qabstractlistmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
        #include "qabstractitemview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
        #include "qabstractprintdialog_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
        #include "qabstractscrollarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
        #include "qabstractslider_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qabstractspinbox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qaction_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qactiongroup_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qapplication_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qcoreapplication_wrapper.h"
        
          #include "qguiapplication_wrapper.h"
        
        #include "qbitmap_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qpixmap_wrapper.h"
        
        #include "qboxlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
        #include "qhboxlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qboxlayout_wrapper.h"
        
        #include "qvboxlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qboxlayout_wrapper.h"
        
        #include "qbrush_wrapper.h"
        
        #include "qgradient_wrapper.h"
        
        #include "qlineargradient_wrapper.h"
        
          #include "qgradient_wrapper.h"
        
        #include "qradialgradient_wrapper.h"
        
          #include "qgradient_wrapper.h"
        
        #include "qconicalgradient_wrapper.h"
        
          #include "qgradient_wrapper.h"
        
        #include "qbuffer_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qiodevicebase_wrapper.h"
        
          #include "qiodevice_wrapper.h"
        
        #include "qbuttongroup_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qbytearray_wrapper.h"
        
        #include "qcalendar_wrapper.h"
        
        #include "qcheckbox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractbutton_wrapper.h"
        
        #include "qclipboard_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qcolor_wrapper.h"
        
        #include "qcolordialog_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
        #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qcompleter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qcoreapplication_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qevent_wrapper.h"
        
        #include "qcursor_wrapper.h"
        
        #include "qdate_wrapper.h"
        
        #include "qtime_wrapper.h"
        
        #include "qdatetime_wrapper.h"
        
        #include "qdesktopservices_wrapper.h"
        
        #include "qdialog_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qdialogbuttonbox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qdir_wrapper.h"
        
        #include "qdiriterator_wrapper.h"
        
        #include "qdockwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qdomimplementation_wrapper.h"
        
        #include "qdomnode_wrapper.h"
        
        #include "qdomnodelist_wrapper.h"
        
        #include "qdomdocumenttype_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
        #include "qdomdocument_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
        #include "qdomnamednodemap_wrapper.h"
        
        #include "qdomdocumentfragment_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
        #include "qdomcharacterdata_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
        #include "qdomattr_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
        #include "qdomelement_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
        #include "qdomtext_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomcharacterdata_wrapper.h"
        
        #include "qdomcomment_wrapper.h"
        
          #include "qdomcharacterdata_wrapper.h"
        
        #include "qdomcdatasection_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomcharacterdata_wrapper.h"
        
          #include "qdomtext_wrapper.h"
        
        #include "qdomnotation_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
        #include "qdomentity_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
        #include "qdomentityreference_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
        #include "qdomprocessinginstruction_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
        #include "qdrag_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qeasingcurve_wrapper.h"
        
        #include "qinputevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
        #include "qpointerevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
        #include "qsinglepointevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
        #include "qmouseevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
        #include "qwheelevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
        #include "qkeyevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
        #include "qfocusevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
        #include "qpaintevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
        #include "qresizeevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
        #include "qdragenterevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qdropevent_wrapper.h"
        
          #include "qdragmoveevent_wrapper.h"
        
        #include "qdropevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
        #include "qcontextmenuevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
        #include "qdragmoveevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qdropevent_wrapper.h"
        
        #include "qdragleaveevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
        #include "qhelpevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
        #include "qactionevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
        #include "qeventloop_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qeventpoint_wrapper.h"
        
        #include "qfile_wrapper.h"
        
          #include "qfiledevice_wrapper.h"
        
          #include "qiodevice_wrapper.h"
        
        #include "qfiledevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qiodevicebase_wrapper.h"
        
          #include "qiodevice_wrapper.h"
        
        #include "qfiledialog_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
        #include "qfileiconprovider_wrapper.h"
        
          #include "qabstractfileiconprovider_wrapper.h"
        
        #include "qfileinfo_wrapper.h"
        
        #include "qfilesystemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
        #include "qfilesystemwatcher_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qfont_wrapper.h"
        
        #include "qfontcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
        #include "qfontdatabase_wrapper.h"
        
        #include "qfontmetrics_wrapper.h"
        
        #include "qfontmetricsf_wrapper.h"
        
        #include "qformlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
        #include "qframe_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qgesture_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qpangesture_wrapper.h"
        
          #include "qgesture_wrapper.h"
        
        #include "qpinchgesture_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qgesture_wrapper.h"
        
        #include "qswipegesture_wrapper.h"
        
          #include "qgesture_wrapper.h"
        
        #include "qgraphicseffect_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qgraphicscolorizeeffect_wrapper.h"
        
          #include "qgraphicseffect_wrapper.h"
        
        #include "qgraphicsblureffect_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qgraphicseffect_wrapper.h"
        
        #include "qgraphicsdropshadoweffect_wrapper.h"
        
          #include "qgraphicseffect_wrapper.h"
        
        #include "qgraphicsopacityeffect_wrapper.h"
        
          #include "qgraphicseffect_wrapper.h"
        
        #include "qgridlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
        #include "qgroupbox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qguiapplication_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qcoreapplication_wrapper.h"
        
        #include "qheaderview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
        #include "qicon_wrapper.h"
        
        #include "qimage_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
        #include "qimagereader_wrapper.h"
        
        #include "qimagewriter_wrapper.h"
        
        #include "qinputdevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qiodevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qiodevicebase_wrapper.h"
        
        #include "qiodevicebase_wrapper.h"
        
        #include "qitemdelegate_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemdelegate_wrapper.h"
        
        #include "qitemselectionmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qitemselection_wrapper.h"
        
        #include "qjsengine_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qkeysequence_wrapper.h"
        
        #include "qlabel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
        #include "qlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
        #include "qlayoutitem_wrapper.h"
        
        #include "qspaceritem_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
        #include "qwidgetitem_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
        #include "qline_wrapper.h"
        
        #include "qlinef_wrapper.h"
        
        #include "qlineedit_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qlistview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
        #include "qlistwidgetitem_wrapper.h"
        
        #include "qlistwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qlistview_wrapper.h"
        
        #include "qlocale_wrapper.h"
        
        #include "qmainwindow_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qmargins_wrapper.h"
        
        #include "qmarginsf_wrapper.h"
        
        #include "qmdiarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
        #include "qmdisubwindow_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qmenu_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qmenubar_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qmessagebox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
        #include "qmimedata_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qkeycombination_wrapper.h"
        
        #include "qobject_wrapper.h"
        
        #include "qpagedpaintdevice_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
        #include "qpagelayout_wrapper.h"
        
        #include "qpageranges_wrapper.h"
        
        #include "qpagesize_wrapper.h"
        
        #include "qpaintdevice_wrapper.h"
        
        #include "qpainter_wrapper.h"
        
        #include "qpainterpath_wrapper.h"
        
        #include "qpainterpathstroker_wrapper.h"
        
        #include "qpalette_wrapper.h"
        
        #include "qpen_wrapper.h"
        
        #include "qpicture_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
        #include "qpixmap_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
        #include "qplaintextedit_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
        #include "qpoint_wrapper.h"
        
        #include "qpointf_wrapper.h"
        
        #include "qpolygon_wrapper.h"
        
        #include "qpolygonf_wrapper.h"
        
        #include "qprintdialog_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
          #include "qabstractprintdialog_wrapper.h"
        
        #include "qprinter_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qpagedpaintdevice_wrapper.h"
        
        #include "qprinterinfo_wrapper.h"
        
        #include "qprocessenvironment_wrapper.h"
        
        #include "qprocess_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qiodevice_wrapper.h"
        
        #include "qprogressbar_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qprogressdialog_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
        #include "qpushbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractbutton_wrapper.h"
        
        #include "qqmlapplicationengine_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qjsengine_wrapper.h"
        
          #include "qqmlengine_wrapper.h"
        
        #include "qqmlcontext_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qqmlengine_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qjsengine_wrapper.h"
        
        #include "qquickview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwindow_wrapper.h"
        
        #include "qquickwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qradiobutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractbutton_wrapper.h"
        
        #include "qrect_wrapper.h"
        
        #include "qrectf_wrapper.h"
        
        #include "qregion_wrapper.h"
        
        #include "qregularexpression_wrapper.h"
        
        #include "qregularexpressionmatch_wrapper.h"
        
        #include "qscreen_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qscrollarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
        #include "qscrollbar_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractslider_wrapper.h"
        
        #include "qsettings_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qshortcut_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qsize_wrapper.h"
        
        #include "qsizef_wrapper.h"
        
        #include "qsizepolicy_wrapper.h"
        
        #include "qslider_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractslider_wrapper.h"
        
        #include "qsortfilterproxymodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qabstractproxymodel_wrapper.h"
        
        #include "qspinbox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractspinbox_wrapper.h"
        
        #include "qdoublespinbox_wrapper.h"
        
          #include "qabstractspinbox_wrapper.h"
        
        #include "qsplashscreen_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qsplitter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
        #include "qsplitterhandle_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qstackedlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
        #include "qstackedwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
        #include "qstandarditem_wrapper.h"
        
        #include "qstandarditemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
        #include "qstatusbar_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qstringconverter_wrapper.h"
        
          #include "qstringconverterbase_wrapper.h"
        
        #include "qstringencoder_wrapper.h"
        
          #include "qstringconverter_wrapper.h"
        
        #include "qstringdecoder_wrapper.h"
        
          #include "qstringconverter_wrapper.h"
        
        #include "qsurfaceformat_wrapper.h"
        
        #include "qsvgrenderer_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qtabbar_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qtableview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
        #include "qtablewidgetitem_wrapper.h"
        
        #include "qtablewidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qtableview_wrapper.h"
        
        #include "qtabwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qtextbrowser_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qtextedit_wrapper.h"
        
        #include "qtextcursor_wrapper.h"
        
        #include "qtextdocument_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qtextedit_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
        #include "qtextlength_wrapper.h"
        
        #include "qtextformat_wrapper.h"
        
        #include "qtextcharformat_wrapper.h"
        
          #include "qtextformat_wrapper.h"
        
        #include "qtextblockformat_wrapper.h"
        
          #include "qtextformat_wrapper.h"
        
        #include "qtextlistformat_wrapper.h"
        
          #include "qtextformat_wrapper.h"
        
        #include "qtextimageformat_wrapper.h"
        
          #include "qtextcharformat_wrapper.h"
        
        #include "qtextframeformat_wrapper.h"
        
          #include "qtextformat_wrapper.h"
        
        #include "qtexttableformat_wrapper.h"
        
          #include "qtextframeformat_wrapper.h"
        
        #include "qtexttablecellformat_wrapper.h"
        
          #include "qtextcharformat_wrapper.h"
        
        #include "qtextlayout_wrapper.h"
        
        #include "qtextstream_wrapper.h"
        
          #include "qiodevicebase_wrapper.h"
        
        #include "qtimer_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qtoolbar_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
        #include "qtoolbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractbutton_wrapper.h"
        
        #include "qtooltip_wrapper.h"
        
        #include "qtransform_wrapper.h"
        
        #include "qtranslator_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qtreeview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
        #include "qtreewidgetitem_wrapper.h"
        
        #include "qtreewidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qtreeview_wrapper.h"
        
        #include "quiloader_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qurl_wrapper.h"
        
        #include "qurlquery_wrapper.h"
        
        #include "qvalidator_wrapper.h"
        
          #include "qobject_wrapper.h"
        
        #include "qintvalidator_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qvalidator_wrapper.h"
        
        #include "qdoublevalidator_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qvalidator_wrapper.h"
        
        #include "qregularexpressionvalidator_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qvalidator_wrapper.h"
        
        #include "qvariant_wrapper.h"
        
        #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
        #include "qwidgetaction_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qaction_wrapper.h"
        
        #include "qwindow_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qsurface_wrapper.h"
        
        #include "qxmlattributes_wrapper.h"
        
        #include "qxmlinputsource_wrapper.h"
        
        #include "qxmlparseexception_wrapper.h"
        
        #include "qxmlreader_wrapper.h"
        
        #include "qxmlsimplereader_wrapper.h"
        
          #include "qxmlreader_wrapper.h"
        
        #include "qxmllocator_wrapper.h"
        
        #include "qxmlcontenthandler_wrapper.h"
        
        #include "qxmlerrorhandler_wrapper.h"
        
        #include "qxmldtdhandler_wrapper.h"
        
        #include "qxmlentityresolver_wrapper.h"
        
        #include "qxmllexicalhandler_wrapper.h"
        
        #include "qxmldeclhandler_wrapper.h"
        
        #include "qxmldefaulthandler_wrapper.h"
        
          #include "qxmlcontenthandler_wrapper.h"
        
          #include "qxmlerrorhandler_wrapper.h"
        
          #include "qxmldtdhandler_wrapper.h"
        
          #include "qxmlentityresolver_wrapper.h"
        
          #include "qxmllexicalhandler_wrapper.h"
        
          #include "qxmldeclhandler_wrapper.h"
        
        #include "qxmlstreamattribute_wrapper.h"
        
        #include "qxmlstreamattributes_wrapper.h"
        
        #include "qxmlstreamreader_wrapper.h"
        
        #include "qxmlstreamwriter_wrapper.h"
        
  // --------------
  // wrapped types:
  // --------------
  
      QJSValue RJSHelper::cpp2js_QBitmap(RJSApi& handler, const QBitmap* v) {
          QJSEngine* engine = handler.getEngine();
          QBitmap_Wrapper* ret;

          if (v==nullptr) {
              ret = new QBitmap_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QBitmap object:
              ret = new QBitmap_Wrapper(handler, new QBitmap(*v), true);
          }

          // JS: new QBitmap('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QBitmap");
          if (cl.isUndefined()) {
              qWarning() << "Class QBitmap is undefined. Use QBitmap_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QBitmap('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QBitmap(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QBitmap(RJSApi& handler, const QBitmap& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QBitmap object:
          QBitmap_Wrapper* ret = new QBitmap_Wrapper(handler, new QBitmap(v), true);

          // JS: new QBitmap('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QBitmap");
          if (cl.isUndefined()) {
              qWarning() << "Class QBitmap is undefined. Use QBitmap_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QBitmap('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QBitmap(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QBitmap RJSHelper::js2cpp_QBitmap(RJSApi& handler, const QJSValue& v) {
          /*
          QBitmap_Wrapper* wrapper = getWrapper<QBitmap_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QBitmap: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QBitmap();
          }
          //return *(QBitmap*)wrapper->getWrappedVoid();
          QBitmap* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QBitmap: wrapped pointer is NULL";
              return QBitmap();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QBitmap: not a QObject";
              return QBitmap();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QBitmap_ptr: no wrapper";
              handler.trace();
              return QBitmap();
          }
          //QBitmap* ret = getWrapped_QBitmap(wrapper);
          QBitmap* ret = QBitmap_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QBitmap();
          }
          return *ret;
      }

      bool RJSHelper::is_QBitmap(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QBitmap: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QBitmap::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QBrush(RJSApi& handler, const QBrush* v) {
          QJSEngine* engine = handler.getEngine();
          QBrush_Wrapper* ret;

          if (v==nullptr) {
              ret = new QBrush_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QBrush object:
              ret = new QBrush_Wrapper(handler, new QBrush(*v), true);
          }

          // JS: new QBrush('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QBrush");
          if (cl.isUndefined()) {
              qWarning() << "Class QBrush is undefined. Use QBrush_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QBrush('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QBrush(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QBrush(RJSApi& handler, const QBrush& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QBrush object:
          QBrush_Wrapper* ret = new QBrush_Wrapper(handler, new QBrush(v), true);

          // JS: new QBrush('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QBrush");
          if (cl.isUndefined()) {
              qWarning() << "Class QBrush is undefined. Use QBrush_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QBrush('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QBrush(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QBrush RJSHelper::js2cpp_QBrush(RJSApi& handler, const QJSValue& v) {
          /*
          QBrush_Wrapper* wrapper = getWrapper<QBrush_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QBrush: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QBrush();
          }
          //return *(QBrush*)wrapper->getWrappedVoid();
          QBrush* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QBrush: wrapped pointer is NULL";
              return QBrush();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QBrush: not a QObject";
              return QBrush();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QBrush_ptr: no wrapper";
              handler.trace();
              return QBrush();
          }
          //QBrush* ret = getWrapped_QBrush(wrapper);
          QBrush* ret = QBrush_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QBrush();
          }
          return *ret;
      }

      bool RJSHelper::is_QBrush(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QBrush: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QBrush::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QByteArray(RJSApi& handler, const QByteArray* v) {
          QJSEngine* engine = handler.getEngine();
          QByteArray_Wrapper* ret;

          if (v==nullptr) {
              ret = new QByteArray_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QByteArray object:
              ret = new QByteArray_Wrapper(handler, new QByteArray(*v), true);
          }

          // JS: new QByteArray('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QByteArray");
          if (cl.isUndefined()) {
              qWarning() << "Class QByteArray is undefined. Use QByteArray_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QByteArray('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QByteArray(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QByteArray(RJSApi& handler, const QByteArray& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QByteArray object:
          QByteArray_Wrapper* ret = new QByteArray_Wrapper(handler, new QByteArray(v), true);

          // JS: new QByteArray('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QByteArray");
          if (cl.isUndefined()) {
              qWarning() << "Class QByteArray is undefined. Use QByteArray_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QByteArray('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QByteArray(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QByteArray RJSHelper::js2cpp_QByteArray(RJSApi& handler, const QJSValue& v) {
          /*
          QByteArray_Wrapper* wrapper = getWrapper<QByteArray_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QByteArray: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QByteArray();
          }
          //return *(QByteArray*)wrapper->getWrappedVoid();
          QByteArray* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QByteArray: wrapped pointer is NULL";
              return QByteArray();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QByteArray: not a QObject";
              return QByteArray();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QByteArray_ptr: no wrapper";
              handler.trace();
              return QByteArray();
          }
          //QByteArray* ret = getWrapped_QByteArray(wrapper);
          QByteArray* ret = QByteArray_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QByteArray();
          }
          return *ret;
      }

      bool RJSHelper::is_QByteArray(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QByteArray: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QByteArray::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QColor(RJSApi& handler, const QColor* v) {
          QJSEngine* engine = handler.getEngine();
          QColor_Wrapper* ret;

          if (v==nullptr) {
              ret = new QColor_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QColor object:
              ret = new QColor_Wrapper(handler, new QColor(*v), true);
          }

          // JS: new QColor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QColor");
          if (cl.isUndefined()) {
              qWarning() << "Class QColor is undefined. Use QColor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QColor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QColor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QColor(RJSApi& handler, const QColor& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QColor object:
          QColor_Wrapper* ret = new QColor_Wrapper(handler, new QColor(v), true);

          // JS: new QColor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QColor");
          if (cl.isUndefined()) {
              qWarning() << "Class QColor is undefined. Use QColor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QColor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QColor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QColor RJSHelper::js2cpp_QColor(RJSApi& handler, const QJSValue& v) {
          /*
          QColor_Wrapper* wrapper = getWrapper<QColor_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QColor: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QColor();
          }
          //return *(QColor*)wrapper->getWrappedVoid();
          QColor* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QColor: wrapped pointer is NULL";
              return QColor();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QColor: not a QObject";
              return QColor();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QColor_ptr: no wrapper";
              handler.trace();
              return QColor();
          }
          //QColor* ret = getWrapped_QColor(wrapper);
          QColor* ret = QColor_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QColor();
          }
          return *ret;
      }

      bool RJSHelper::is_QColor(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QColor: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QColor::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QConicalGradient(RJSApi& handler, const QConicalGradient* v) {
          QJSEngine* engine = handler.getEngine();
          QConicalGradient_Wrapper* ret;

          if (v==nullptr) {
              ret = new QConicalGradient_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QConicalGradient object:
              ret = new QConicalGradient_Wrapper(handler, new QConicalGradient(*v), true);
          }

          // JS: new QConicalGradient('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QConicalGradient");
          if (cl.isUndefined()) {
              qWarning() << "Class QConicalGradient is undefined. Use QConicalGradient_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QConicalGradient('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QConicalGradient(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QConicalGradient(RJSApi& handler, const QConicalGradient& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QConicalGradient object:
          QConicalGradient_Wrapper* ret = new QConicalGradient_Wrapper(handler, new QConicalGradient(v), true);

          // JS: new QConicalGradient('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QConicalGradient");
          if (cl.isUndefined()) {
              qWarning() << "Class QConicalGradient is undefined. Use QConicalGradient_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QConicalGradient('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QConicalGradient(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QConicalGradient RJSHelper::js2cpp_QConicalGradient(RJSApi& handler, const QJSValue& v) {
          /*
          QConicalGradient_Wrapper* wrapper = getWrapper<QConicalGradient_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QConicalGradient: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QConicalGradient();
          }
          //return *(QConicalGradient*)wrapper->getWrappedVoid();
          QConicalGradient* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QConicalGradient: wrapped pointer is NULL";
              return QConicalGradient();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QConicalGradient: not a QObject";
              return QConicalGradient();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QConicalGradient_ptr: no wrapper";
              handler.trace();
              return QConicalGradient();
          }
          //QConicalGradient* ret = getWrapped_QConicalGradient(wrapper);
          QConicalGradient* ret = QConicalGradient_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QConicalGradient();
          }
          return *ret;
      }

      bool RJSHelper::is_QConicalGradient(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QConicalGradient: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QConicalGradient::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QCursor(RJSApi& handler, const QCursor* v) {
          QJSEngine* engine = handler.getEngine();
          QCursor_Wrapper* ret;

          if (v==nullptr) {
              ret = new QCursor_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QCursor object:
              ret = new QCursor_Wrapper(handler, new QCursor(*v), true);
          }

          // JS: new QCursor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QCursor");
          if (cl.isUndefined()) {
              qWarning() << "Class QCursor is undefined. Use QCursor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QCursor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QCursor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QCursor(RJSApi& handler, const QCursor& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QCursor object:
          QCursor_Wrapper* ret = new QCursor_Wrapper(handler, new QCursor(v), true);

          // JS: new QCursor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QCursor");
          if (cl.isUndefined()) {
              qWarning() << "Class QCursor is undefined. Use QCursor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QCursor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QCursor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QCursor RJSHelper::js2cpp_QCursor(RJSApi& handler, const QJSValue& v) {
          /*
          QCursor_Wrapper* wrapper = getWrapper<QCursor_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QCursor: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QCursor();
          }
          //return *(QCursor*)wrapper->getWrappedVoid();
          QCursor* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QCursor: wrapped pointer is NULL";
              return QCursor();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QCursor: not a QObject";
              return QCursor();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QCursor_ptr: no wrapper";
              handler.trace();
              return QCursor();
          }
          //QCursor* ret = getWrapped_QCursor(wrapper);
          QCursor* ret = QCursor_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QCursor();
          }
          return *ret;
      }

      bool RJSHelper::is_QCursor(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QCursor: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QCursor::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDate(RJSApi& handler, const QDate* v) {
          QJSEngine* engine = handler.getEngine();
          QDate_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDate_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDate object:
              ret = new QDate_Wrapper(handler, new QDate(*v), true);
          }

          // JS: new QDate('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDate");
          if (cl.isUndefined()) {
              qWarning() << "Class QDate is undefined. Use QDate_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDate('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDate(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDate(RJSApi& handler, const QDate& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDate object:
          QDate_Wrapper* ret = new QDate_Wrapper(handler, new QDate(v), true);

          // JS: new QDate('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDate");
          if (cl.isUndefined()) {
              qWarning() << "Class QDate is undefined. Use QDate_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDate('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDate(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDate RJSHelper::js2cpp_QDate(RJSApi& handler, const QJSValue& v) {
          /*
          QDate_Wrapper* wrapper = getWrapper<QDate_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDate: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDate();
          }
          //return *(QDate*)wrapper->getWrappedVoid();
          QDate* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDate: wrapped pointer is NULL";
              return QDate();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDate: not a QObject";
              return QDate();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDate_ptr: no wrapper";
              handler.trace();
              return QDate();
          }
          //QDate* ret = getWrapped_QDate(wrapper);
          QDate* ret = QDate_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDate();
          }
          return *ret;
      }

      bool RJSHelper::is_QDate(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDate: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDate::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDateTime(RJSApi& handler, const QDateTime* v) {
          QJSEngine* engine = handler.getEngine();
          QDateTime_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDateTime_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDateTime object:
              ret = new QDateTime_Wrapper(handler, new QDateTime(*v), true);
          }

          // JS: new QDateTime('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDateTime");
          if (cl.isUndefined()) {
              qWarning() << "Class QDateTime is undefined. Use QDateTime_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDateTime('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDateTime(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDateTime(RJSApi& handler, const QDateTime& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDateTime object:
          QDateTime_Wrapper* ret = new QDateTime_Wrapper(handler, new QDateTime(v), true);

          // JS: new QDateTime('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDateTime");
          if (cl.isUndefined()) {
              qWarning() << "Class QDateTime is undefined. Use QDateTime_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDateTime('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDateTime(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDateTime RJSHelper::js2cpp_QDateTime(RJSApi& handler, const QJSValue& v) {
          /*
          QDateTime_Wrapper* wrapper = getWrapper<QDateTime_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDateTime: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDateTime();
          }
          //return *(QDateTime*)wrapper->getWrappedVoid();
          QDateTime* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDateTime: wrapped pointer is NULL";
              return QDateTime();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDateTime: not a QObject";
              return QDateTime();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDateTime_ptr: no wrapper";
              handler.trace();
              return QDateTime();
          }
          //QDateTime* ret = getWrapped_QDateTime(wrapper);
          QDateTime* ret = QDateTime_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDateTime();
          }
          return *ret;
      }

      bool RJSHelper::is_QDateTime(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDateTime: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDateTime::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDesktopServices(RJSApi& handler, const QDesktopServices* v) {
          QJSEngine* engine = handler.getEngine();
          QDesktopServices_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDesktopServices_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDesktopServices object:
              ret = new QDesktopServices_Wrapper(handler, new QDesktopServices(*v), true);
          }

          // JS: new QDesktopServices('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDesktopServices");
          if (cl.isUndefined()) {
              qWarning() << "Class QDesktopServices is undefined. Use QDesktopServices_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDesktopServices('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDesktopServices(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDesktopServices(RJSApi& handler, const QDesktopServices& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDesktopServices object:
          QDesktopServices_Wrapper* ret = new QDesktopServices_Wrapper(handler, new QDesktopServices(v), true);

          // JS: new QDesktopServices('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDesktopServices");
          if (cl.isUndefined()) {
              qWarning() << "Class QDesktopServices is undefined. Use QDesktopServices_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDesktopServices('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDesktopServices(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDesktopServices RJSHelper::js2cpp_QDesktopServices(RJSApi& handler, const QJSValue& v) {
          /*
          QDesktopServices_Wrapper* wrapper = getWrapper<QDesktopServices_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDesktopServices: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDesktopServices();
          }
          //return *(QDesktopServices*)wrapper->getWrappedVoid();
          QDesktopServices* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDesktopServices: wrapped pointer is NULL";
              return QDesktopServices();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDesktopServices: not a QObject";
              return QDesktopServices();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDesktopServices_ptr: no wrapper";
              handler.trace();
              return QDesktopServices();
          }
          //QDesktopServices* ret = getWrapped_QDesktopServices(wrapper);
          QDesktopServices* ret = QDesktopServices_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDesktopServices();
          }
          return *ret;
      }

      bool RJSHelper::is_QDesktopServices(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDesktopServices: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDesktopServices::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDir(RJSApi& handler, const QDir* v) {
          QJSEngine* engine = handler.getEngine();
          QDir_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDir_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDir object:
              ret = new QDir_Wrapper(handler, new QDir(*v), true);
          }

          // JS: new QDir('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDir");
          if (cl.isUndefined()) {
              qWarning() << "Class QDir is undefined. Use QDir_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDir('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDir(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDir(RJSApi& handler, const QDir& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDir object:
          QDir_Wrapper* ret = new QDir_Wrapper(handler, new QDir(v), true);

          // JS: new QDir('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDir");
          if (cl.isUndefined()) {
              qWarning() << "Class QDir is undefined. Use QDir_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDir('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDir(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDir RJSHelper::js2cpp_QDir(RJSApi& handler, const QJSValue& v) {
          /*
          QDir_Wrapper* wrapper = getWrapper<QDir_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDir: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDir();
          }
          //return *(QDir*)wrapper->getWrappedVoid();
          QDir* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDir: wrapped pointer is NULL";
              return QDir();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDir: not a QObject";
              return QDir();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDir_ptr: no wrapper";
              handler.trace();
              return QDir();
          }
          //QDir* ret = getWrapped_QDir(wrapper);
          QDir* ret = QDir_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDir();
          }
          return *ret;
      }

      bool RJSHelper::is_QDir(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDir: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDir::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomAttr(RJSApi& handler, const QDomAttr* v) {
          QJSEngine* engine = handler.getEngine();
          QDomAttr_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomAttr_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomAttr object:
              ret = new QDomAttr_Wrapper(handler, new QDomAttr(*v), true);
          }

          // JS: new QDomAttr('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomAttr");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomAttr is undefined. Use QDomAttr_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomAttr('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomAttr(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomAttr(RJSApi& handler, const QDomAttr& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomAttr object:
          QDomAttr_Wrapper* ret = new QDomAttr_Wrapper(handler, new QDomAttr(v), true);

          // JS: new QDomAttr('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomAttr");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomAttr is undefined. Use QDomAttr_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomAttr('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomAttr(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomAttr RJSHelper::js2cpp_QDomAttr(RJSApi& handler, const QJSValue& v) {
          /*
          QDomAttr_Wrapper* wrapper = getWrapper<QDomAttr_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomAttr: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomAttr();
          }
          //return *(QDomAttr*)wrapper->getWrappedVoid();
          QDomAttr* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomAttr: wrapped pointer is NULL";
              return QDomAttr();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomAttr: not a QObject";
              return QDomAttr();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomAttr_ptr: no wrapper";
              handler.trace();
              return QDomAttr();
          }
          //QDomAttr* ret = getWrapped_QDomAttr(wrapper);
          QDomAttr* ret = QDomAttr_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomAttr();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomAttr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomAttr: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomAttr::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomCDATASection(RJSApi& handler, const QDomCDATASection* v) {
          QJSEngine* engine = handler.getEngine();
          QDomCDATASection_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomCDATASection_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomCDATASection object:
              ret = new QDomCDATASection_Wrapper(handler, new QDomCDATASection(*v), true);
          }

          // JS: new QDomCDATASection('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomCDATASection");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomCDATASection is undefined. Use QDomCDATASection_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomCDATASection('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomCDATASection(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomCDATASection(RJSApi& handler, const QDomCDATASection& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomCDATASection object:
          QDomCDATASection_Wrapper* ret = new QDomCDATASection_Wrapper(handler, new QDomCDATASection(v), true);

          // JS: new QDomCDATASection('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomCDATASection");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomCDATASection is undefined. Use QDomCDATASection_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomCDATASection('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomCDATASection(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomCDATASection RJSHelper::js2cpp_QDomCDATASection(RJSApi& handler, const QJSValue& v) {
          /*
          QDomCDATASection_Wrapper* wrapper = getWrapper<QDomCDATASection_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomCDATASection: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomCDATASection();
          }
          //return *(QDomCDATASection*)wrapper->getWrappedVoid();
          QDomCDATASection* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomCDATASection: wrapped pointer is NULL";
              return QDomCDATASection();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomCDATASection: not a QObject";
              return QDomCDATASection();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomCDATASection_ptr: no wrapper";
              handler.trace();
              return QDomCDATASection();
          }
          //QDomCDATASection* ret = getWrapped_QDomCDATASection(wrapper);
          QDomCDATASection* ret = QDomCDATASection_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomCDATASection();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomCDATASection(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomCDATASection: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomCDATASection::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomCharacterData(RJSApi& handler, const QDomCharacterData* v) {
          QJSEngine* engine = handler.getEngine();
          QDomCharacterData_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomCharacterData_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomCharacterData object:
              ret = new QDomCharacterData_Wrapper(handler, new QDomCharacterData(*v), true);
          }

          // JS: new QDomCharacterData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomCharacterData");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomCharacterData is undefined. Use QDomCharacterData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomCharacterData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomCharacterData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomCharacterData(RJSApi& handler, const QDomCharacterData& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomCharacterData object:
          QDomCharacterData_Wrapper* ret = new QDomCharacterData_Wrapper(handler, new QDomCharacterData(v), true);

          // JS: new QDomCharacterData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomCharacterData");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomCharacterData is undefined. Use QDomCharacterData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomCharacterData('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomCharacterData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomCharacterData RJSHelper::js2cpp_QDomCharacterData(RJSApi& handler, const QJSValue& v) {
          /*
          QDomCharacterData_Wrapper* wrapper = getWrapper<QDomCharacterData_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomCharacterData: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomCharacterData();
          }
          //return *(QDomCharacterData*)wrapper->getWrappedVoid();
          QDomCharacterData* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomCharacterData: wrapped pointer is NULL";
              return QDomCharacterData();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomCharacterData: not a QObject";
              return QDomCharacterData();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomCharacterData_ptr: no wrapper";
              handler.trace();
              return QDomCharacterData();
          }
          //QDomCharacterData* ret = getWrapped_QDomCharacterData(wrapper);
          QDomCharacterData* ret = QDomCharacterData_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomCharacterData();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomCharacterData(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomCharacterData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomCharacterData::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomComment(RJSApi& handler, const QDomComment* v) {
          QJSEngine* engine = handler.getEngine();
          QDomComment_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomComment_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomComment object:
              ret = new QDomComment_Wrapper(handler, new QDomComment(*v), true);
          }

          // JS: new QDomComment('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomComment");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomComment is undefined. Use QDomComment_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomComment('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomComment(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomComment(RJSApi& handler, const QDomComment& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomComment object:
          QDomComment_Wrapper* ret = new QDomComment_Wrapper(handler, new QDomComment(v), true);

          // JS: new QDomComment('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomComment");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomComment is undefined. Use QDomComment_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomComment('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomComment(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomComment RJSHelper::js2cpp_QDomComment(RJSApi& handler, const QJSValue& v) {
          /*
          QDomComment_Wrapper* wrapper = getWrapper<QDomComment_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomComment: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomComment();
          }
          //return *(QDomComment*)wrapper->getWrappedVoid();
          QDomComment* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomComment: wrapped pointer is NULL";
              return QDomComment();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomComment: not a QObject";
              return QDomComment();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomComment_ptr: no wrapper";
              handler.trace();
              return QDomComment();
          }
          //QDomComment* ret = getWrapped_QDomComment(wrapper);
          QDomComment* ret = QDomComment_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomComment();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomComment(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomComment: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomComment::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomDocument(RJSApi& handler, const QDomDocument* v) {
          QJSEngine* engine = handler.getEngine();
          QDomDocument_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomDocument_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomDocument object:
              ret = new QDomDocument_Wrapper(handler, new QDomDocument(*v), true);
          }

          // JS: new QDomDocument('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomDocument");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomDocument is undefined. Use QDomDocument_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomDocument('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomDocument(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomDocument(RJSApi& handler, const QDomDocument& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomDocument object:
          QDomDocument_Wrapper* ret = new QDomDocument_Wrapper(handler, new QDomDocument(v), true);

          // JS: new QDomDocument('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomDocument");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomDocument is undefined. Use QDomDocument_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomDocument('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomDocument(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomDocument RJSHelper::js2cpp_QDomDocument(RJSApi& handler, const QJSValue& v) {
          /*
          QDomDocument_Wrapper* wrapper = getWrapper<QDomDocument_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomDocument: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomDocument();
          }
          //return *(QDomDocument*)wrapper->getWrappedVoid();
          QDomDocument* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomDocument: wrapped pointer is NULL";
              return QDomDocument();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomDocument: not a QObject";
              return QDomDocument();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomDocument_ptr: no wrapper";
              handler.trace();
              return QDomDocument();
          }
          //QDomDocument* ret = getWrapped_QDomDocument(wrapper);
          QDomDocument* ret = QDomDocument_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomDocument();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomDocument(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomDocument: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomDocument::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomDocumentFragment(RJSApi& handler, const QDomDocumentFragment* v) {
          QJSEngine* engine = handler.getEngine();
          QDomDocumentFragment_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomDocumentFragment_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomDocumentFragment object:
              ret = new QDomDocumentFragment_Wrapper(handler, new QDomDocumentFragment(*v), true);
          }

          // JS: new QDomDocumentFragment('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomDocumentFragment");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomDocumentFragment is undefined. Use QDomDocumentFragment_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomDocumentFragment('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomDocumentFragment(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomDocumentFragment(RJSApi& handler, const QDomDocumentFragment& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomDocumentFragment object:
          QDomDocumentFragment_Wrapper* ret = new QDomDocumentFragment_Wrapper(handler, new QDomDocumentFragment(v), true);

          // JS: new QDomDocumentFragment('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomDocumentFragment");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomDocumentFragment is undefined. Use QDomDocumentFragment_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomDocumentFragment('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomDocumentFragment(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomDocumentFragment RJSHelper::js2cpp_QDomDocumentFragment(RJSApi& handler, const QJSValue& v) {
          /*
          QDomDocumentFragment_Wrapper* wrapper = getWrapper<QDomDocumentFragment_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomDocumentFragment: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomDocumentFragment();
          }
          //return *(QDomDocumentFragment*)wrapper->getWrappedVoid();
          QDomDocumentFragment* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomDocumentFragment: wrapped pointer is NULL";
              return QDomDocumentFragment();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomDocumentFragment: not a QObject";
              return QDomDocumentFragment();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomDocumentFragment_ptr: no wrapper";
              handler.trace();
              return QDomDocumentFragment();
          }
          //QDomDocumentFragment* ret = getWrapped_QDomDocumentFragment(wrapper);
          QDomDocumentFragment* ret = QDomDocumentFragment_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomDocumentFragment();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomDocumentFragment(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomDocumentFragment: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomDocumentFragment::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomDocumentType(RJSApi& handler, const QDomDocumentType* v) {
          QJSEngine* engine = handler.getEngine();
          QDomDocumentType_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomDocumentType_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomDocumentType object:
              ret = new QDomDocumentType_Wrapper(handler, new QDomDocumentType(*v), true);
          }

          // JS: new QDomDocumentType('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomDocumentType");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomDocumentType is undefined. Use QDomDocumentType_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomDocumentType('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomDocumentType(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomDocumentType(RJSApi& handler, const QDomDocumentType& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomDocumentType object:
          QDomDocumentType_Wrapper* ret = new QDomDocumentType_Wrapper(handler, new QDomDocumentType(v), true);

          // JS: new QDomDocumentType('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomDocumentType");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomDocumentType is undefined. Use QDomDocumentType_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomDocumentType('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomDocumentType(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomDocumentType RJSHelper::js2cpp_QDomDocumentType(RJSApi& handler, const QJSValue& v) {
          /*
          QDomDocumentType_Wrapper* wrapper = getWrapper<QDomDocumentType_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomDocumentType: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomDocumentType();
          }
          //return *(QDomDocumentType*)wrapper->getWrappedVoid();
          QDomDocumentType* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomDocumentType: wrapped pointer is NULL";
              return QDomDocumentType();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomDocumentType: not a QObject";
              return QDomDocumentType();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomDocumentType_ptr: no wrapper";
              handler.trace();
              return QDomDocumentType();
          }
          //QDomDocumentType* ret = getWrapped_QDomDocumentType(wrapper);
          QDomDocumentType* ret = QDomDocumentType_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomDocumentType();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomDocumentType(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomDocumentType: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomDocumentType::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomElement(RJSApi& handler, const QDomElement* v) {
          QJSEngine* engine = handler.getEngine();
          QDomElement_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomElement_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomElement object:
              ret = new QDomElement_Wrapper(handler, new QDomElement(*v), true);
          }

          // JS: new QDomElement('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomElement");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomElement is undefined. Use QDomElement_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomElement('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomElement(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomElement(RJSApi& handler, const QDomElement& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomElement object:
          QDomElement_Wrapper* ret = new QDomElement_Wrapper(handler, new QDomElement(v), true);

          // JS: new QDomElement('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomElement");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomElement is undefined. Use QDomElement_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomElement('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomElement(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomElement RJSHelper::js2cpp_QDomElement(RJSApi& handler, const QJSValue& v) {
          /*
          QDomElement_Wrapper* wrapper = getWrapper<QDomElement_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomElement: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomElement();
          }
          //return *(QDomElement*)wrapper->getWrappedVoid();
          QDomElement* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomElement: wrapped pointer is NULL";
              return QDomElement();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomElement: not a QObject";
              return QDomElement();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomElement_ptr: no wrapper";
              handler.trace();
              return QDomElement();
          }
          //QDomElement* ret = getWrapped_QDomElement(wrapper);
          QDomElement* ret = QDomElement_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomElement();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomElement(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomElement: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomElement::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomEntity(RJSApi& handler, const QDomEntity* v) {
          QJSEngine* engine = handler.getEngine();
          QDomEntity_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomEntity_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomEntity object:
              ret = new QDomEntity_Wrapper(handler, new QDomEntity(*v), true);
          }

          // JS: new QDomEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomEntity is undefined. Use QDomEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomEntity(RJSApi& handler, const QDomEntity& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomEntity object:
          QDomEntity_Wrapper* ret = new QDomEntity_Wrapper(handler, new QDomEntity(v), true);

          // JS: new QDomEntity('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomEntity");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomEntity is undefined. Use QDomEntity_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomEntity('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomEntity(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomEntity RJSHelper::js2cpp_QDomEntity(RJSApi& handler, const QJSValue& v) {
          /*
          QDomEntity_Wrapper* wrapper = getWrapper<QDomEntity_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomEntity: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomEntity();
          }
          //return *(QDomEntity*)wrapper->getWrappedVoid();
          QDomEntity* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomEntity: wrapped pointer is NULL";
              return QDomEntity();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomEntity: not a QObject";
              return QDomEntity();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomEntity_ptr: no wrapper";
              handler.trace();
              return QDomEntity();
          }
          //QDomEntity* ret = getWrapped_QDomEntity(wrapper);
          QDomEntity* ret = QDomEntity_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomEntity();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomEntity(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomEntity: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomEntity::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomEntityReference(RJSApi& handler, const QDomEntityReference* v) {
          QJSEngine* engine = handler.getEngine();
          QDomEntityReference_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomEntityReference_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomEntityReference object:
              ret = new QDomEntityReference_Wrapper(handler, new QDomEntityReference(*v), true);
          }

          // JS: new QDomEntityReference('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomEntityReference");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomEntityReference is undefined. Use QDomEntityReference_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomEntityReference('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomEntityReference(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomEntityReference(RJSApi& handler, const QDomEntityReference& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomEntityReference object:
          QDomEntityReference_Wrapper* ret = new QDomEntityReference_Wrapper(handler, new QDomEntityReference(v), true);

          // JS: new QDomEntityReference('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomEntityReference");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomEntityReference is undefined. Use QDomEntityReference_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomEntityReference('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomEntityReference(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomEntityReference RJSHelper::js2cpp_QDomEntityReference(RJSApi& handler, const QJSValue& v) {
          /*
          QDomEntityReference_Wrapper* wrapper = getWrapper<QDomEntityReference_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomEntityReference: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomEntityReference();
          }
          //return *(QDomEntityReference*)wrapper->getWrappedVoid();
          QDomEntityReference* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomEntityReference: wrapped pointer is NULL";
              return QDomEntityReference();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomEntityReference: not a QObject";
              return QDomEntityReference();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomEntityReference_ptr: no wrapper";
              handler.trace();
              return QDomEntityReference();
          }
          //QDomEntityReference* ret = getWrapped_QDomEntityReference(wrapper);
          QDomEntityReference* ret = QDomEntityReference_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomEntityReference();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomEntityReference(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomEntityReference: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomEntityReference::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomImplementation(RJSApi& handler, const QDomImplementation* v) {
          QJSEngine* engine = handler.getEngine();
          QDomImplementation_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomImplementation_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomImplementation object:
              ret = new QDomImplementation_Wrapper(handler, new QDomImplementation(*v), true);
          }

          // JS: new QDomImplementation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomImplementation");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomImplementation is undefined. Use QDomImplementation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomImplementation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomImplementation(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomImplementation(RJSApi& handler, const QDomImplementation& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomImplementation object:
          QDomImplementation_Wrapper* ret = new QDomImplementation_Wrapper(handler, new QDomImplementation(v), true);

          // JS: new QDomImplementation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomImplementation");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomImplementation is undefined. Use QDomImplementation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomImplementation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomImplementation(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomImplementation RJSHelper::js2cpp_QDomImplementation(RJSApi& handler, const QJSValue& v) {
          /*
          QDomImplementation_Wrapper* wrapper = getWrapper<QDomImplementation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomImplementation: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomImplementation();
          }
          //return *(QDomImplementation*)wrapper->getWrappedVoid();
          QDomImplementation* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomImplementation: wrapped pointer is NULL";
              return QDomImplementation();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomImplementation: not a QObject";
              return QDomImplementation();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomImplementation_ptr: no wrapper";
              handler.trace();
              return QDomImplementation();
          }
          //QDomImplementation* ret = getWrapped_QDomImplementation(wrapper);
          QDomImplementation* ret = QDomImplementation_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomImplementation();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomImplementation(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomImplementation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomImplementation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomNamedNodeMap(RJSApi& handler, const QDomNamedNodeMap* v) {
          QJSEngine* engine = handler.getEngine();
          QDomNamedNodeMap_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomNamedNodeMap_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomNamedNodeMap object:
              ret = new QDomNamedNodeMap_Wrapper(handler, new QDomNamedNodeMap(*v), true);
          }

          // JS: new QDomNamedNodeMap('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomNamedNodeMap");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomNamedNodeMap is undefined. Use QDomNamedNodeMap_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomNamedNodeMap('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomNamedNodeMap(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomNamedNodeMap(RJSApi& handler, const QDomNamedNodeMap& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomNamedNodeMap object:
          QDomNamedNodeMap_Wrapper* ret = new QDomNamedNodeMap_Wrapper(handler, new QDomNamedNodeMap(v), true);

          // JS: new QDomNamedNodeMap('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomNamedNodeMap");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomNamedNodeMap is undefined. Use QDomNamedNodeMap_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomNamedNodeMap('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomNamedNodeMap(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomNamedNodeMap RJSHelper::js2cpp_QDomNamedNodeMap(RJSApi& handler, const QJSValue& v) {
          /*
          QDomNamedNodeMap_Wrapper* wrapper = getWrapper<QDomNamedNodeMap_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomNamedNodeMap: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomNamedNodeMap();
          }
          //return *(QDomNamedNodeMap*)wrapper->getWrappedVoid();
          QDomNamedNodeMap* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomNamedNodeMap: wrapped pointer is NULL";
              return QDomNamedNodeMap();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomNamedNodeMap: not a QObject";
              return QDomNamedNodeMap();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomNamedNodeMap_ptr: no wrapper";
              handler.trace();
              return QDomNamedNodeMap();
          }
          //QDomNamedNodeMap* ret = getWrapped_QDomNamedNodeMap(wrapper);
          QDomNamedNodeMap* ret = QDomNamedNodeMap_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomNamedNodeMap();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomNamedNodeMap(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomNamedNodeMap: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomNamedNodeMap::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomNode(RJSApi& handler, const QDomNode* v) {
          QJSEngine* engine = handler.getEngine();
          QDomNode_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomNode_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomNode object:
              ret = new QDomNode_Wrapper(handler, new QDomNode(*v), true);
          }

          // JS: new QDomNode('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomNode");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomNode is undefined. Use QDomNode_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomNode('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomNode(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomNode(RJSApi& handler, const QDomNode& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomNode object:
          QDomNode_Wrapper* ret = new QDomNode_Wrapper(handler, new QDomNode(v), true);

          // JS: new QDomNode('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomNode");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomNode is undefined. Use QDomNode_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomNode('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomNode(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomNode RJSHelper::js2cpp_QDomNode(RJSApi& handler, const QJSValue& v) {
          /*
          QDomNode_Wrapper* wrapper = getWrapper<QDomNode_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomNode: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomNode();
          }
          //return *(QDomNode*)wrapper->getWrappedVoid();
          QDomNode* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomNode: wrapped pointer is NULL";
              return QDomNode();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomNode: not a QObject";
              return QDomNode();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomNode_ptr: no wrapper";
              handler.trace();
              return QDomNode();
          }
          //QDomNode* ret = getWrapped_QDomNode(wrapper);
          QDomNode* ret = QDomNode_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomNode();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomNode(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomNode: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomNode::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomNodeList(RJSApi& handler, const QDomNodeList* v) {
          QJSEngine* engine = handler.getEngine();
          QDomNodeList_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomNodeList_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomNodeList object:
              ret = new QDomNodeList_Wrapper(handler, new QDomNodeList(*v), true);
          }

          // JS: new QDomNodeList('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomNodeList");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomNodeList is undefined. Use QDomNodeList_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomNodeList('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomNodeList(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomNodeList(RJSApi& handler, const QDomNodeList& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomNodeList object:
          QDomNodeList_Wrapper* ret = new QDomNodeList_Wrapper(handler, new QDomNodeList(v), true);

          // JS: new QDomNodeList('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomNodeList");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomNodeList is undefined. Use QDomNodeList_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomNodeList('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomNodeList(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomNodeList RJSHelper::js2cpp_QDomNodeList(RJSApi& handler, const QJSValue& v) {
          /*
          QDomNodeList_Wrapper* wrapper = getWrapper<QDomNodeList_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomNodeList: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomNodeList();
          }
          //return *(QDomNodeList*)wrapper->getWrappedVoid();
          QDomNodeList* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomNodeList: wrapped pointer is NULL";
              return QDomNodeList();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomNodeList: not a QObject";
              return QDomNodeList();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomNodeList_ptr: no wrapper";
              handler.trace();
              return QDomNodeList();
          }
          //QDomNodeList* ret = getWrapped_QDomNodeList(wrapper);
          QDomNodeList* ret = QDomNodeList_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomNodeList();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomNodeList(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomNodeList: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomNodeList::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomNotation(RJSApi& handler, const QDomNotation* v) {
          QJSEngine* engine = handler.getEngine();
          QDomNotation_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomNotation_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomNotation object:
              ret = new QDomNotation_Wrapper(handler, new QDomNotation(*v), true);
          }

          // JS: new QDomNotation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomNotation");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomNotation is undefined. Use QDomNotation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomNotation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomNotation(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomNotation(RJSApi& handler, const QDomNotation& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomNotation object:
          QDomNotation_Wrapper* ret = new QDomNotation_Wrapper(handler, new QDomNotation(v), true);

          // JS: new QDomNotation('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomNotation");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomNotation is undefined. Use QDomNotation_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomNotation('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomNotation(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomNotation RJSHelper::js2cpp_QDomNotation(RJSApi& handler, const QJSValue& v) {
          /*
          QDomNotation_Wrapper* wrapper = getWrapper<QDomNotation_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomNotation: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomNotation();
          }
          //return *(QDomNotation*)wrapper->getWrappedVoid();
          QDomNotation* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomNotation: wrapped pointer is NULL";
              return QDomNotation();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomNotation: not a QObject";
              return QDomNotation();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomNotation_ptr: no wrapper";
              handler.trace();
              return QDomNotation();
          }
          //QDomNotation* ret = getWrapped_QDomNotation(wrapper);
          QDomNotation* ret = QDomNotation_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomNotation();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomNotation(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomNotation: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomNotation::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomProcessingInstruction(RJSApi& handler, const QDomProcessingInstruction* v) {
          QJSEngine* engine = handler.getEngine();
          QDomProcessingInstruction_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomProcessingInstruction_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomProcessingInstruction object:
              ret = new QDomProcessingInstruction_Wrapper(handler, new QDomProcessingInstruction(*v), true);
          }

          // JS: new QDomProcessingInstruction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomProcessingInstruction");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomProcessingInstruction is undefined. Use QDomProcessingInstruction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomProcessingInstruction('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomProcessingInstruction(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomProcessingInstruction(RJSApi& handler, const QDomProcessingInstruction& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomProcessingInstruction object:
          QDomProcessingInstruction_Wrapper* ret = new QDomProcessingInstruction_Wrapper(handler, new QDomProcessingInstruction(v), true);

          // JS: new QDomProcessingInstruction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomProcessingInstruction");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomProcessingInstruction is undefined. Use QDomProcessingInstruction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomProcessingInstruction('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomProcessingInstruction(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomProcessingInstruction RJSHelper::js2cpp_QDomProcessingInstruction(RJSApi& handler, const QJSValue& v) {
          /*
          QDomProcessingInstruction_Wrapper* wrapper = getWrapper<QDomProcessingInstruction_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomProcessingInstruction: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomProcessingInstruction();
          }
          //return *(QDomProcessingInstruction*)wrapper->getWrappedVoid();
          QDomProcessingInstruction* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomProcessingInstruction: wrapped pointer is NULL";
              return QDomProcessingInstruction();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomProcessingInstruction: not a QObject";
              return QDomProcessingInstruction();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomProcessingInstruction_ptr: no wrapper";
              handler.trace();
              return QDomProcessingInstruction();
          }
          //QDomProcessingInstruction* ret = getWrapped_QDomProcessingInstruction(wrapper);
          QDomProcessingInstruction* ret = QDomProcessingInstruction_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomProcessingInstruction();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomProcessingInstruction(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomProcessingInstruction: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomProcessingInstruction::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QDomText(RJSApi& handler, const QDomText* v) {
          QJSEngine* engine = handler.getEngine();
          QDomText_Wrapper* ret;

          if (v==nullptr) {
              ret = new QDomText_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QDomText object:
              ret = new QDomText_Wrapper(handler, new QDomText(*v), true);
          }

          // JS: new QDomText('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomText");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomText is undefined. Use QDomText_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomText('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomText(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDomText(RJSApi& handler, const QDomText& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QDomText object:
          QDomText_Wrapper* ret = new QDomText_Wrapper(handler, new QDomText(v), true);

          // JS: new QDomText('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDomText");
          if (cl.isUndefined()) {
              qWarning() << "Class QDomText is undefined. Use QDomText_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDomText('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDomText(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QDomText RJSHelper::js2cpp_QDomText(RJSApi& handler, const QJSValue& v) {
          /*
          QDomText_Wrapper* wrapper = getWrapper<QDomText_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomText: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QDomText();
          }
          //return *(QDomText*)wrapper->getWrappedVoid();
          QDomText* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QDomText: wrapped pointer is NULL";
              return QDomText();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDomText: not a QObject";
              return QDomText();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDomText_ptr: no wrapper";
              handler.trace();
              return QDomText();
          }
          //QDomText* ret = getWrapped_QDomText(wrapper);
          QDomText* ret = QDomText_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QDomText();
          }
          return *ret;
      }

      bool RJSHelper::is_QDomText(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDomText: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QDomText::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QEasingCurve(RJSApi& handler, const QEasingCurve* v) {
          QJSEngine* engine = handler.getEngine();
          QEasingCurve_Wrapper* ret;

          if (v==nullptr) {
              ret = new QEasingCurve_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QEasingCurve object:
              ret = new QEasingCurve_Wrapper(handler, new QEasingCurve(*v), true);
          }

          // JS: new QEasingCurve('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QEasingCurve");
          if (cl.isUndefined()) {
              qWarning() << "Class QEasingCurve is undefined. Use QEasingCurve_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QEasingCurve('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QEasingCurve(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QEasingCurve(RJSApi& handler, const QEasingCurve& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QEasingCurve object:
          QEasingCurve_Wrapper* ret = new QEasingCurve_Wrapper(handler, new QEasingCurve(v), true);

          // JS: new QEasingCurve('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QEasingCurve");
          if (cl.isUndefined()) {
              qWarning() << "Class QEasingCurve is undefined. Use QEasingCurve_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QEasingCurve('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QEasingCurve(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QEasingCurve RJSHelper::js2cpp_QEasingCurve(RJSApi& handler, const QJSValue& v) {
          /*
          QEasingCurve_Wrapper* wrapper = getWrapper<QEasingCurve_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QEasingCurve: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QEasingCurve();
          }
          //return *(QEasingCurve*)wrapper->getWrappedVoid();
          QEasingCurve* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QEasingCurve: wrapped pointer is NULL";
              return QEasingCurve();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QEasingCurve: not a QObject";
              return QEasingCurve();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QEasingCurve_ptr: no wrapper";
              handler.trace();
              return QEasingCurve();
          }
          //QEasingCurve* ret = getWrapped_QEasingCurve(wrapper);
          QEasingCurve* ret = QEasingCurve_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QEasingCurve();
          }
          return *ret;
      }

      bool RJSHelper::is_QEasingCurve(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QEasingCurve: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QEasingCurve::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QEventPoint(RJSApi& handler, const QEventPoint* v) {
          QJSEngine* engine = handler.getEngine();
          QEventPoint_Wrapper* ret;

          if (v==nullptr) {
              ret = new QEventPoint_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QEventPoint object:
              ret = new QEventPoint_Wrapper(handler, new QEventPoint(*v), true);
          }

          // JS: new QEventPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QEventPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class QEventPoint is undefined. Use QEventPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QEventPoint('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QEventPoint(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QEventPoint(RJSApi& handler, const QEventPoint& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QEventPoint object:
          QEventPoint_Wrapper* ret = new QEventPoint_Wrapper(handler, new QEventPoint(v), true);

          // JS: new QEventPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QEventPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class QEventPoint is undefined. Use QEventPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QEventPoint('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QEventPoint(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QEventPoint RJSHelper::js2cpp_QEventPoint(RJSApi& handler, const QJSValue& v) {
          /*
          QEventPoint_Wrapper* wrapper = getWrapper<QEventPoint_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QEventPoint: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QEventPoint();
          }
          //return *(QEventPoint*)wrapper->getWrappedVoid();
          QEventPoint* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QEventPoint: wrapped pointer is NULL";
              return QEventPoint();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QEventPoint: not a QObject";
              return QEventPoint();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QEventPoint_ptr: no wrapper";
              handler.trace();
              return QEventPoint();
          }
          //QEventPoint* ret = getWrapped_QEventPoint(wrapper);
          QEventPoint* ret = QEventPoint_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QEventPoint();
          }
          return *ret;
      }

      bool RJSHelper::is_QEventPoint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QEventPoint: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QEventPoint::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QFileInfo(RJSApi& handler, const QFileInfo* v) {
          QJSEngine* engine = handler.getEngine();
          QFileInfo_Wrapper* ret;

          if (v==nullptr) {
              ret = new QFileInfo_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QFileInfo object:
              ret = new QFileInfo_Wrapper(handler, new QFileInfo(*v), true);
          }

          // JS: new QFileInfo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFileInfo");
          if (cl.isUndefined()) {
              qWarning() << "Class QFileInfo is undefined. Use QFileInfo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFileInfo('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFileInfo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFileInfo(RJSApi& handler, const QFileInfo& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QFileInfo object:
          QFileInfo_Wrapper* ret = new QFileInfo_Wrapper(handler, new QFileInfo(v), true);

          // JS: new QFileInfo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFileInfo");
          if (cl.isUndefined()) {
              qWarning() << "Class QFileInfo is undefined. Use QFileInfo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFileInfo('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFileInfo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QFileInfo RJSHelper::js2cpp_QFileInfo(RJSApi& handler, const QJSValue& v) {
          /*
          QFileInfo_Wrapper* wrapper = getWrapper<QFileInfo_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFileInfo: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QFileInfo();
          }
          //return *(QFileInfo*)wrapper->getWrappedVoid();
          QFileInfo* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QFileInfo: wrapped pointer is NULL";
              return QFileInfo();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFileInfo: not a QObject";
              return QFileInfo();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFileInfo_ptr: no wrapper";
              handler.trace();
              return QFileInfo();
          }
          //QFileInfo* ret = getWrapped_QFileInfo(wrapper);
          QFileInfo* ret = QFileInfo_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QFileInfo();
          }
          return *ret;
      }

      bool RJSHelper::is_QFileInfo(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFileInfo: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QFileInfo::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QFont(RJSApi& handler, const QFont* v) {
          QJSEngine* engine = handler.getEngine();
          QFont_Wrapper* ret;

          if (v==nullptr) {
              ret = new QFont_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QFont object:
              ret = new QFont_Wrapper(handler, new QFont(*v), true);
          }

          // JS: new QFont('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFont");
          if (cl.isUndefined()) {
              qWarning() << "Class QFont is undefined. Use QFont_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFont('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFont(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFont(RJSApi& handler, const QFont& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QFont object:
          QFont_Wrapper* ret = new QFont_Wrapper(handler, new QFont(v), true);

          // JS: new QFont('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFont");
          if (cl.isUndefined()) {
              qWarning() << "Class QFont is undefined. Use QFont_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFont('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFont(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QFont RJSHelper::js2cpp_QFont(RJSApi& handler, const QJSValue& v) {
          /*
          QFont_Wrapper* wrapper = getWrapper<QFont_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFont: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QFont();
          }
          //return *(QFont*)wrapper->getWrappedVoid();
          QFont* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QFont: wrapped pointer is NULL";
              return QFont();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFont: not a QObject";
              return QFont();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFont_ptr: no wrapper";
              handler.trace();
              return QFont();
          }
          //QFont* ret = getWrapped_QFont(wrapper);
          QFont* ret = QFont_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QFont();
          }
          return *ret;
      }

      bool RJSHelper::is_QFont(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFont: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QFont::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QFontDatabase(RJSApi& handler, const QFontDatabase* v) {
          QJSEngine* engine = handler.getEngine();
          QFontDatabase_Wrapper* ret;

          if (v==nullptr) {
              ret = new QFontDatabase_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QFontDatabase object:
              ret = new QFontDatabase_Wrapper(handler, new QFontDatabase(*v), true);
          }

          // JS: new QFontDatabase('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFontDatabase");
          if (cl.isUndefined()) {
              qWarning() << "Class QFontDatabase is undefined. Use QFontDatabase_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFontDatabase('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFontDatabase(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFontDatabase(RJSApi& handler, const QFontDatabase& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QFontDatabase object:
          QFontDatabase_Wrapper* ret = new QFontDatabase_Wrapper(handler, new QFontDatabase(v), true);

          // JS: new QFontDatabase('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFontDatabase");
          if (cl.isUndefined()) {
              qWarning() << "Class QFontDatabase is undefined. Use QFontDatabase_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFontDatabase('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFontDatabase(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QFontDatabase RJSHelper::js2cpp_QFontDatabase(RJSApi& handler, const QJSValue& v) {
          /*
          QFontDatabase_Wrapper* wrapper = getWrapper<QFontDatabase_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFontDatabase: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QFontDatabase();
          }
          //return *(QFontDatabase*)wrapper->getWrappedVoid();
          QFontDatabase* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QFontDatabase: wrapped pointer is NULL";
              return QFontDatabase();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFontDatabase: not a QObject";
              return QFontDatabase();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFontDatabase_ptr: no wrapper";
              handler.trace();
              return QFontDatabase();
          }
          //QFontDatabase* ret = getWrapped_QFontDatabase(wrapper);
          QFontDatabase* ret = QFontDatabase_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QFontDatabase();
          }
          return *ret;
      }

      bool RJSHelper::is_QFontDatabase(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFontDatabase: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QFontDatabase::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QGradient(RJSApi& handler, const QGradient* v) {
          QJSEngine* engine = handler.getEngine();
          QGradient_Wrapper* ret;

          if (v==nullptr) {
              ret = new QGradient_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QGradient object:
              ret = new QGradient_Wrapper(handler, new QGradient(*v), true);
          }

          // JS: new QGradient('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGradient");
          if (cl.isUndefined()) {
              qWarning() << "Class QGradient is undefined. Use QGradient_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGradient('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGradient(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGradient(RJSApi& handler, const QGradient& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QGradient object:
          QGradient_Wrapper* ret = new QGradient_Wrapper(handler, new QGradient(v), true);

          // JS: new QGradient('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGradient");
          if (cl.isUndefined()) {
              qWarning() << "Class QGradient is undefined. Use QGradient_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGradient('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGradient(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QGradient RJSHelper::js2cpp_QGradient(RJSApi& handler, const QJSValue& v) {
          /*
          QGradient_Wrapper* wrapper = getWrapper<QGradient_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGradient: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QGradient();
          }
          //return *(QGradient*)wrapper->getWrappedVoid();
          QGradient* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QGradient: wrapped pointer is NULL";
              return QGradient();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGradient: not a QObject";
              return QGradient();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGradient_ptr: no wrapper";
              handler.trace();
              return QGradient();
          }
          //QGradient* ret = getWrapped_QGradient(wrapper);
          QGradient* ret = QGradient_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QGradient();
          }
          return *ret;
      }

      bool RJSHelper::is_QGradient(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGradient: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QGradient::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QIcon(RJSApi& handler, const QIcon* v) {
          QJSEngine* engine = handler.getEngine();
          QIcon_Wrapper* ret;

          if (v==nullptr) {
              ret = new QIcon_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QIcon object:
              ret = new QIcon_Wrapper(handler, new QIcon(*v), true);
          }

          // JS: new QIcon('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QIcon");
          if (cl.isUndefined()) {
              qWarning() << "Class QIcon is undefined. Use QIcon_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QIcon('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QIcon(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QIcon(RJSApi& handler, const QIcon& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QIcon object:
          QIcon_Wrapper* ret = new QIcon_Wrapper(handler, new QIcon(v), true);

          // JS: new QIcon('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QIcon");
          if (cl.isUndefined()) {
              qWarning() << "Class QIcon is undefined. Use QIcon_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QIcon('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QIcon(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QIcon RJSHelper::js2cpp_QIcon(RJSApi& handler, const QJSValue& v) {
          /*
          QIcon_Wrapper* wrapper = getWrapper<QIcon_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QIcon: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QIcon();
          }
          //return *(QIcon*)wrapper->getWrappedVoid();
          QIcon* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QIcon: wrapped pointer is NULL";
              return QIcon();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QIcon: not a QObject";
              return QIcon();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QIcon_ptr: no wrapper";
              handler.trace();
              return QIcon();
          }
          //QIcon* ret = getWrapped_QIcon(wrapper);
          QIcon* ret = QIcon_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QIcon();
          }
          return *ret;
      }

      bool RJSHelper::is_QIcon(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QIcon: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QIcon::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QImage(RJSApi& handler, const QImage* v) {
          QJSEngine* engine = handler.getEngine();
          QImage_Wrapper* ret;

          if (v==nullptr) {
              ret = new QImage_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QImage object:
              ret = new QImage_Wrapper(handler, new QImage(*v), true);
          }

          // JS: new QImage('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QImage");
          if (cl.isUndefined()) {
              qWarning() << "Class QImage is undefined. Use QImage_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QImage('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QImage(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QImage(RJSApi& handler, const QImage& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QImage object:
          QImage_Wrapper* ret = new QImage_Wrapper(handler, new QImage(v), true);

          // JS: new QImage('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QImage");
          if (cl.isUndefined()) {
              qWarning() << "Class QImage is undefined. Use QImage_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QImage('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QImage(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QImage RJSHelper::js2cpp_QImage(RJSApi& handler, const QJSValue& v) {
          /*
          QImage_Wrapper* wrapper = getWrapper<QImage_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QImage: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QImage();
          }
          //return *(QImage*)wrapper->getWrappedVoid();
          QImage* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QImage: wrapped pointer is NULL";
              return QImage();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QImage: not a QObject";
              return QImage();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QImage_ptr: no wrapper";
              handler.trace();
              return QImage();
          }
          //QImage* ret = getWrapped_QImage(wrapper);
          QImage* ret = QImage_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QImage();
          }
          return *ret;
      }

      bool RJSHelper::is_QImage(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QImage: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QImage::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QItemSelection(RJSApi& handler, const QItemSelection* v) {
          QJSEngine* engine = handler.getEngine();
          QItemSelection_Wrapper* ret;

          if (v==nullptr) {
              ret = new QItemSelection_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QItemSelection object:
              ret = new QItemSelection_Wrapper(handler, new QItemSelection(*v), true);
          }

          // JS: new QItemSelection('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QItemSelection");
          if (cl.isUndefined()) {
              qWarning() << "Class QItemSelection is undefined. Use QItemSelection_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QItemSelection('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QItemSelection(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QItemSelection(RJSApi& handler, const QItemSelection& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QItemSelection object:
          QItemSelection_Wrapper* ret = new QItemSelection_Wrapper(handler, new QItemSelection(v), true);

          // JS: new QItemSelection('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QItemSelection");
          if (cl.isUndefined()) {
              qWarning() << "Class QItemSelection is undefined. Use QItemSelection_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QItemSelection('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QItemSelection(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QItemSelection RJSHelper::js2cpp_QItemSelection(RJSApi& handler, const QJSValue& v) {
          /*
          QItemSelection_Wrapper* wrapper = getWrapper<QItemSelection_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QItemSelection: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QItemSelection();
          }
          //return *(QItemSelection*)wrapper->getWrappedVoid();
          QItemSelection* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QItemSelection: wrapped pointer is NULL";
              return QItemSelection();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QItemSelection: not a QObject";
              return QItemSelection();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QItemSelection_ptr: no wrapper";
              handler.trace();
              return QItemSelection();
          }
          //QItemSelection* ret = getWrapped_QItemSelection(wrapper);
          QItemSelection* ret = QItemSelection_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QItemSelection();
          }
          return *ret;
      }

      bool RJSHelper::is_QItemSelection(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QItemSelection: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QItemSelection::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QKeyCombination(RJSApi& handler, const QKeyCombination* v) {
          QJSEngine* engine = handler.getEngine();
          QKeyCombination_Wrapper* ret;

          if (v==nullptr) {
              ret = new QKeyCombination_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QKeyCombination object:
              ret = new QKeyCombination_Wrapper(handler, new QKeyCombination(*v), true);
          }

          // JS: new QKeyCombination('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QKeyCombination");
          if (cl.isUndefined()) {
              qWarning() << "Class QKeyCombination is undefined. Use QKeyCombination_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QKeyCombination('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QKeyCombination(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QKeyCombination(RJSApi& handler, const QKeyCombination& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QKeyCombination object:
          QKeyCombination_Wrapper* ret = new QKeyCombination_Wrapper(handler, new QKeyCombination(v), true);

          // JS: new QKeyCombination('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QKeyCombination");
          if (cl.isUndefined()) {
              qWarning() << "Class QKeyCombination is undefined. Use QKeyCombination_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QKeyCombination('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QKeyCombination(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QKeyCombination RJSHelper::js2cpp_QKeyCombination(RJSApi& handler, const QJSValue& v) {
          /*
          QKeyCombination_Wrapper* wrapper = getWrapper<QKeyCombination_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QKeyCombination: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QKeyCombination();
          }
          //return *(QKeyCombination*)wrapper->getWrappedVoid();
          QKeyCombination* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QKeyCombination: wrapped pointer is NULL";
              return QKeyCombination();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QKeyCombination: not a QObject";
              return QKeyCombination();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QKeyCombination_ptr: no wrapper";
              handler.trace();
              return QKeyCombination();
          }
          //QKeyCombination* ret = getWrapped_QKeyCombination(wrapper);
          QKeyCombination* ret = QKeyCombination_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QKeyCombination();
          }
          return *ret;
      }

      bool RJSHelper::is_QKeyCombination(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QKeyCombination: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QKeyCombination::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QKeySequence(RJSApi& handler, const QKeySequence* v) {
          QJSEngine* engine = handler.getEngine();
          QKeySequence_Wrapper* ret;

          if (v==nullptr) {
              ret = new QKeySequence_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QKeySequence object:
              ret = new QKeySequence_Wrapper(handler, new QKeySequence(*v), true);
          }

          // JS: new QKeySequence('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QKeySequence");
          if (cl.isUndefined()) {
              qWarning() << "Class QKeySequence is undefined. Use QKeySequence_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QKeySequence('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QKeySequence(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QKeySequence(RJSApi& handler, const QKeySequence& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QKeySequence object:
          QKeySequence_Wrapper* ret = new QKeySequence_Wrapper(handler, new QKeySequence(v), true);

          // JS: new QKeySequence('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QKeySequence");
          if (cl.isUndefined()) {
              qWarning() << "Class QKeySequence is undefined. Use QKeySequence_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QKeySequence('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QKeySequence(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QKeySequence RJSHelper::js2cpp_QKeySequence(RJSApi& handler, const QJSValue& v) {
          /*
          QKeySequence_Wrapper* wrapper = getWrapper<QKeySequence_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QKeySequence: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QKeySequence();
          }
          //return *(QKeySequence*)wrapper->getWrappedVoid();
          QKeySequence* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QKeySequence: wrapped pointer is NULL";
              return QKeySequence();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QKeySequence: not a QObject";
              return QKeySequence();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QKeySequence_ptr: no wrapper";
              handler.trace();
              return QKeySequence();
          }
          //QKeySequence* ret = getWrapped_QKeySequence(wrapper);
          QKeySequence* ret = QKeySequence_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QKeySequence();
          }
          return *ret;
      }

      bool RJSHelper::is_QKeySequence(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QKeySequence: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QKeySequence::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QLine(RJSApi& handler, const QLine* v) {
          QJSEngine* engine = handler.getEngine();
          QLine_Wrapper* ret;

          if (v==nullptr) {
              ret = new QLine_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QLine object:
              ret = new QLine_Wrapper(handler, new QLine(*v), true);
          }

          // JS: new QLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLine");
          if (cl.isUndefined()) {
              qWarning() << "Class QLine is undefined. Use QLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QLine(RJSApi& handler, const QLine& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QLine object:
          QLine_Wrapper* ret = new QLine_Wrapper(handler, new QLine(v), true);

          // JS: new QLine('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLine");
          if (cl.isUndefined()) {
              qWarning() << "Class QLine is undefined. Use QLine_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLine('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLine(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QLine RJSHelper::js2cpp_QLine(RJSApi& handler, const QJSValue& v) {
          /*
          QLine_Wrapper* wrapper = getWrapper<QLine_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLine: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QLine();
          }
          //return *(QLine*)wrapper->getWrappedVoid();
          QLine* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QLine: wrapped pointer is NULL";
              return QLine();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QLine: not a QObject";
              return QLine();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLine_ptr: no wrapper";
              handler.trace();
              return QLine();
          }
          //QLine* ret = getWrapped_QLine(wrapper);
          QLine* ret = QLine_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QLine();
          }
          return *ret;
      }

      bool RJSHelper::is_QLine(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QLine: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QLine::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QLineF(RJSApi& handler, const QLineF* v) {
          QJSEngine* engine = handler.getEngine();
          QLineF_Wrapper* ret;

          if (v==nullptr) {
              ret = new QLineF_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QLineF object:
              ret = new QLineF_Wrapper(handler, new QLineF(*v), true);
          }

          // JS: new QLineF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLineF");
          if (cl.isUndefined()) {
              qWarning() << "Class QLineF is undefined. Use QLineF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLineF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLineF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QLineF(RJSApi& handler, const QLineF& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QLineF object:
          QLineF_Wrapper* ret = new QLineF_Wrapper(handler, new QLineF(v), true);

          // JS: new QLineF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLineF");
          if (cl.isUndefined()) {
              qWarning() << "Class QLineF is undefined. Use QLineF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLineF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLineF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QLineF RJSHelper::js2cpp_QLineF(RJSApi& handler, const QJSValue& v) {
          /*
          QLineF_Wrapper* wrapper = getWrapper<QLineF_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLineF: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QLineF();
          }
          //return *(QLineF*)wrapper->getWrappedVoid();
          QLineF* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QLineF: wrapped pointer is NULL";
              return QLineF();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QLineF: not a QObject";
              return QLineF();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLineF_ptr: no wrapper";
              handler.trace();
              return QLineF();
          }
          //QLineF* ret = getWrapped_QLineF(wrapper);
          QLineF* ret = QLineF_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QLineF();
          }
          return *ret;
      }

      bool RJSHelper::is_QLineF(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QLineF: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QLineF::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QLinearGradient(RJSApi& handler, const QLinearGradient* v) {
          QJSEngine* engine = handler.getEngine();
          QLinearGradient_Wrapper* ret;

          if (v==nullptr) {
              ret = new QLinearGradient_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QLinearGradient object:
              ret = new QLinearGradient_Wrapper(handler, new QLinearGradient(*v), true);
          }

          // JS: new QLinearGradient('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLinearGradient");
          if (cl.isUndefined()) {
              qWarning() << "Class QLinearGradient is undefined. Use QLinearGradient_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLinearGradient('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLinearGradient(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QLinearGradient(RJSApi& handler, const QLinearGradient& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QLinearGradient object:
          QLinearGradient_Wrapper* ret = new QLinearGradient_Wrapper(handler, new QLinearGradient(v), true);

          // JS: new QLinearGradient('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLinearGradient");
          if (cl.isUndefined()) {
              qWarning() << "Class QLinearGradient is undefined. Use QLinearGradient_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLinearGradient('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLinearGradient(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QLinearGradient RJSHelper::js2cpp_QLinearGradient(RJSApi& handler, const QJSValue& v) {
          /*
          QLinearGradient_Wrapper* wrapper = getWrapper<QLinearGradient_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLinearGradient: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QLinearGradient();
          }
          //return *(QLinearGradient*)wrapper->getWrappedVoid();
          QLinearGradient* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QLinearGradient: wrapped pointer is NULL";
              return QLinearGradient();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QLinearGradient: not a QObject";
              return QLinearGradient();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLinearGradient_ptr: no wrapper";
              handler.trace();
              return QLinearGradient();
          }
          //QLinearGradient* ret = getWrapped_QLinearGradient(wrapper);
          QLinearGradient* ret = QLinearGradient_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QLinearGradient();
          }
          return *ret;
      }

      bool RJSHelper::is_QLinearGradient(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QLinearGradient: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QLinearGradient::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QLocale(RJSApi& handler, const QLocale* v) {
          QJSEngine* engine = handler.getEngine();
          QLocale_Wrapper* ret;

          if (v==nullptr) {
              ret = new QLocale_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QLocale object:
              ret = new QLocale_Wrapper(handler, new QLocale(*v), true);
          }

          // JS: new QLocale('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLocale");
          if (cl.isUndefined()) {
              qWarning() << "Class QLocale is undefined. Use QLocale_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLocale('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLocale(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QLocale(RJSApi& handler, const QLocale& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QLocale object:
          QLocale_Wrapper* ret = new QLocale_Wrapper(handler, new QLocale(v), true);

          // JS: new QLocale('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLocale");
          if (cl.isUndefined()) {
              qWarning() << "Class QLocale is undefined. Use QLocale_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLocale('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLocale(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QLocale RJSHelper::js2cpp_QLocale(RJSApi& handler, const QJSValue& v) {
          /*
          QLocale_Wrapper* wrapper = getWrapper<QLocale_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLocale: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QLocale();
          }
          //return *(QLocale*)wrapper->getWrappedVoid();
          QLocale* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QLocale: wrapped pointer is NULL";
              return QLocale();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QLocale: not a QObject";
              return QLocale();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLocale_ptr: no wrapper";
              handler.trace();
              return QLocale();
          }
          //QLocale* ret = getWrapped_QLocale(wrapper);
          QLocale* ret = QLocale_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QLocale();
          }
          return *ret;
      }

      bool RJSHelper::is_QLocale(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QLocale: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QLocale::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QMargins(RJSApi& handler, const QMargins* v) {
          QJSEngine* engine = handler.getEngine();
          QMargins_Wrapper* ret;

          if (v==nullptr) {
              ret = new QMargins_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QMargins object:
              ret = new QMargins_Wrapper(handler, new QMargins(*v), true);
          }

          // JS: new QMargins('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMargins");
          if (cl.isUndefined()) {
              qWarning() << "Class QMargins is undefined. Use QMargins_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMargins('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMargins(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMargins(RJSApi& handler, const QMargins& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QMargins object:
          QMargins_Wrapper* ret = new QMargins_Wrapper(handler, new QMargins(v), true);

          // JS: new QMargins('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMargins");
          if (cl.isUndefined()) {
              qWarning() << "Class QMargins is undefined. Use QMargins_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMargins('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMargins(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QMargins RJSHelper::js2cpp_QMargins(RJSApi& handler, const QJSValue& v) {
          /*
          QMargins_Wrapper* wrapper = getWrapper<QMargins_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMargins: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QMargins();
          }
          //return *(QMargins*)wrapper->getWrappedVoid();
          QMargins* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QMargins: wrapped pointer is NULL";
              return QMargins();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMargins: not a QObject";
              return QMargins();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMargins_ptr: no wrapper";
              handler.trace();
              return QMargins();
          }
          //QMargins* ret = getWrapped_QMargins(wrapper);
          QMargins* ret = QMargins_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QMargins();
          }
          return *ret;
      }

      bool RJSHelper::is_QMargins(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMargins: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QMargins::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QMarginsF(RJSApi& handler, const QMarginsF* v) {
          QJSEngine* engine = handler.getEngine();
          QMarginsF_Wrapper* ret;

          if (v==nullptr) {
              ret = new QMarginsF_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QMarginsF object:
              ret = new QMarginsF_Wrapper(handler, new QMarginsF(*v), true);
          }

          // JS: new QMarginsF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMarginsF");
          if (cl.isUndefined()) {
              qWarning() << "Class QMarginsF is undefined. Use QMarginsF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMarginsF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMarginsF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMarginsF(RJSApi& handler, const QMarginsF& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QMarginsF object:
          QMarginsF_Wrapper* ret = new QMarginsF_Wrapper(handler, new QMarginsF(v), true);

          // JS: new QMarginsF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMarginsF");
          if (cl.isUndefined()) {
              qWarning() << "Class QMarginsF is undefined. Use QMarginsF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMarginsF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMarginsF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QMarginsF RJSHelper::js2cpp_QMarginsF(RJSApi& handler, const QJSValue& v) {
          /*
          QMarginsF_Wrapper* wrapper = getWrapper<QMarginsF_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMarginsF: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QMarginsF();
          }
          //return *(QMarginsF*)wrapper->getWrappedVoid();
          QMarginsF* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QMarginsF: wrapped pointer is NULL";
              return QMarginsF();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMarginsF: not a QObject";
              return QMarginsF();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMarginsF_ptr: no wrapper";
              handler.trace();
              return QMarginsF();
          }
          //QMarginsF* ret = getWrapped_QMarginsF(wrapper);
          QMarginsF* ret = QMarginsF_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QMarginsF();
          }
          return *ret;
      }

      bool RJSHelper::is_QMarginsF(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMarginsF: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QMarginsF::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QModelIndex(RJSApi& handler, const QModelIndex* v) {
          QJSEngine* engine = handler.getEngine();
          QModelIndex_Wrapper* ret;

          if (v==nullptr) {
              ret = new QModelIndex_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QModelIndex object:
              ret = new QModelIndex_Wrapper(handler, new QModelIndex(*v), true);
          }

          // JS: new QModelIndex('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QModelIndex");
          if (cl.isUndefined()) {
              qWarning() << "Class QModelIndex is undefined. Use QModelIndex_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QModelIndex('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QModelIndex(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QModelIndex(RJSApi& handler, const QModelIndex& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QModelIndex object:
          QModelIndex_Wrapper* ret = new QModelIndex_Wrapper(handler, new QModelIndex(v), true);

          // JS: new QModelIndex('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QModelIndex");
          if (cl.isUndefined()) {
              qWarning() << "Class QModelIndex is undefined. Use QModelIndex_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QModelIndex('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QModelIndex(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QModelIndex RJSHelper::js2cpp_QModelIndex(RJSApi& handler, const QJSValue& v) {
          /*
          QModelIndex_Wrapper* wrapper = getWrapper<QModelIndex_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QModelIndex: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QModelIndex();
          }
          //return *(QModelIndex*)wrapper->getWrappedVoid();
          QModelIndex* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QModelIndex: wrapped pointer is NULL";
              return QModelIndex();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QModelIndex: not a QObject";
              return QModelIndex();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QModelIndex_ptr: no wrapper";
              handler.trace();
              return QModelIndex();
          }
          //QModelIndex* ret = getWrapped_QModelIndex(wrapper);
          QModelIndex* ret = QModelIndex_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QModelIndex();
          }
          return *ret;
      }

      bool RJSHelper::is_QModelIndex(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QModelIndex: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QModelIndex::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPageLayout(RJSApi& handler, const QPageLayout* v) {
          QJSEngine* engine = handler.getEngine();
          QPageLayout_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPageLayout_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPageLayout object:
              ret = new QPageLayout_Wrapper(handler, new QPageLayout(*v), true);
          }

          // JS: new QPageLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPageLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QPageLayout is undefined. Use QPageLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPageLayout('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPageLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPageLayout(RJSApi& handler, const QPageLayout& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPageLayout object:
          QPageLayout_Wrapper* ret = new QPageLayout_Wrapper(handler, new QPageLayout(v), true);

          // JS: new QPageLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPageLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QPageLayout is undefined. Use QPageLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPageLayout('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPageLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPageLayout RJSHelper::js2cpp_QPageLayout(RJSApi& handler, const QJSValue& v) {
          /*
          QPageLayout_Wrapper* wrapper = getWrapper<QPageLayout_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPageLayout: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPageLayout();
          }
          //return *(QPageLayout*)wrapper->getWrappedVoid();
          QPageLayout* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPageLayout: wrapped pointer is NULL";
              return QPageLayout();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPageLayout: not a QObject";
              return QPageLayout();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPageLayout_ptr: no wrapper";
              handler.trace();
              return QPageLayout();
          }
          //QPageLayout* ret = getWrapped_QPageLayout(wrapper);
          QPageLayout* ret = QPageLayout_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPageLayout();
          }
          return *ret;
      }

      bool RJSHelper::is_QPageLayout(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPageLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPageLayout::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPageRanges(RJSApi& handler, const QPageRanges* v) {
          QJSEngine* engine = handler.getEngine();
          QPageRanges_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPageRanges_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPageRanges object:
              ret = new QPageRanges_Wrapper(handler, new QPageRanges(*v), true);
          }

          // JS: new QPageRanges('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPageRanges");
          if (cl.isUndefined()) {
              qWarning() << "Class QPageRanges is undefined. Use QPageRanges_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPageRanges('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPageRanges(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPageRanges(RJSApi& handler, const QPageRanges& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPageRanges object:
          QPageRanges_Wrapper* ret = new QPageRanges_Wrapper(handler, new QPageRanges(v), true);

          // JS: new QPageRanges('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPageRanges");
          if (cl.isUndefined()) {
              qWarning() << "Class QPageRanges is undefined. Use QPageRanges_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPageRanges('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPageRanges(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPageRanges RJSHelper::js2cpp_QPageRanges(RJSApi& handler, const QJSValue& v) {
          /*
          QPageRanges_Wrapper* wrapper = getWrapper<QPageRanges_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPageRanges: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPageRanges();
          }
          //return *(QPageRanges*)wrapper->getWrappedVoid();
          QPageRanges* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPageRanges: wrapped pointer is NULL";
              return QPageRanges();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPageRanges: not a QObject";
              return QPageRanges();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPageRanges_ptr: no wrapper";
              handler.trace();
              return QPageRanges();
          }
          //QPageRanges* ret = getWrapped_QPageRanges(wrapper);
          QPageRanges* ret = QPageRanges_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPageRanges();
          }
          return *ret;
      }

      bool RJSHelper::is_QPageRanges(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPageRanges: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPageRanges::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPageSize(RJSApi& handler, const QPageSize* v) {
          QJSEngine* engine = handler.getEngine();
          QPageSize_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPageSize_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPageSize object:
              ret = new QPageSize_Wrapper(handler, new QPageSize(*v), true);
          }

          // JS: new QPageSize('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPageSize");
          if (cl.isUndefined()) {
              qWarning() << "Class QPageSize is undefined. Use QPageSize_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPageSize('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPageSize(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPageSize(RJSApi& handler, const QPageSize& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPageSize object:
          QPageSize_Wrapper* ret = new QPageSize_Wrapper(handler, new QPageSize(v), true);

          // JS: new QPageSize('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPageSize");
          if (cl.isUndefined()) {
              qWarning() << "Class QPageSize is undefined. Use QPageSize_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPageSize('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPageSize(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPageSize RJSHelper::js2cpp_QPageSize(RJSApi& handler, const QJSValue& v) {
          /*
          QPageSize_Wrapper* wrapper = getWrapper<QPageSize_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPageSize: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPageSize();
          }
          //return *(QPageSize*)wrapper->getWrappedVoid();
          QPageSize* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPageSize: wrapped pointer is NULL";
              return QPageSize();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPageSize: not a QObject";
              return QPageSize();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPageSize_ptr: no wrapper";
              handler.trace();
              return QPageSize();
          }
          //QPageSize* ret = getWrapped_QPageSize(wrapper);
          QPageSize* ret = QPageSize_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPageSize();
          }
          return *ret;
      }

      bool RJSHelper::is_QPageSize(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPageSize: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPageSize::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPainterPath(RJSApi& handler, const QPainterPath* v) {
          QJSEngine* engine = handler.getEngine();
          QPainterPath_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPainterPath_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPainterPath object:
              ret = new QPainterPath_Wrapper(handler, new QPainterPath(*v), true);
          }

          // JS: new QPainterPath('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPainterPath");
          if (cl.isUndefined()) {
              qWarning() << "Class QPainterPath is undefined. Use QPainterPath_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPainterPath('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPainterPath(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPainterPath(RJSApi& handler, const QPainterPath& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPainterPath object:
          QPainterPath_Wrapper* ret = new QPainterPath_Wrapper(handler, new QPainterPath(v), true);

          // JS: new QPainterPath('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPainterPath");
          if (cl.isUndefined()) {
              qWarning() << "Class QPainterPath is undefined. Use QPainterPath_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPainterPath('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPainterPath(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPainterPath RJSHelper::js2cpp_QPainterPath(RJSApi& handler, const QJSValue& v) {
          /*
          QPainterPath_Wrapper* wrapper = getWrapper<QPainterPath_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPainterPath: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPainterPath();
          }
          //return *(QPainterPath*)wrapper->getWrappedVoid();
          QPainterPath* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPainterPath: wrapped pointer is NULL";
              return QPainterPath();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPainterPath: not a QObject";
              return QPainterPath();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPainterPath_ptr: no wrapper";
              handler.trace();
              return QPainterPath();
          }
          //QPainterPath* ret = getWrapped_QPainterPath(wrapper);
          QPainterPath* ret = QPainterPath_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPainterPath();
          }
          return *ret;
      }

      bool RJSHelper::is_QPainterPath(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPainterPath: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPainterPath::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPalette(RJSApi& handler, const QPalette* v) {
          QJSEngine* engine = handler.getEngine();
          QPalette_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPalette_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPalette object:
              ret = new QPalette_Wrapper(handler, new QPalette(*v), true);
          }

          // JS: new QPalette('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPalette");
          if (cl.isUndefined()) {
              qWarning() << "Class QPalette is undefined. Use QPalette_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPalette('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPalette(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPalette(RJSApi& handler, const QPalette& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPalette object:
          QPalette_Wrapper* ret = new QPalette_Wrapper(handler, new QPalette(v), true);

          // JS: new QPalette('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPalette");
          if (cl.isUndefined()) {
              qWarning() << "Class QPalette is undefined. Use QPalette_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPalette('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPalette(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPalette RJSHelper::js2cpp_QPalette(RJSApi& handler, const QJSValue& v) {
          /*
          QPalette_Wrapper* wrapper = getWrapper<QPalette_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPalette: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPalette();
          }
          //return *(QPalette*)wrapper->getWrappedVoid();
          QPalette* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPalette: wrapped pointer is NULL";
              return QPalette();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPalette: not a QObject";
              return QPalette();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPalette_ptr: no wrapper";
              handler.trace();
              return QPalette();
          }
          //QPalette* ret = getWrapped_QPalette(wrapper);
          QPalette* ret = QPalette_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPalette();
          }
          return *ret;
      }

      bool RJSHelper::is_QPalette(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPalette: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPalette::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPen(RJSApi& handler, const QPen* v) {
          QJSEngine* engine = handler.getEngine();
          QPen_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPen_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPen object:
              ret = new QPen_Wrapper(handler, new QPen(*v), true);
          }

          // JS: new QPen('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPen");
          if (cl.isUndefined()) {
              qWarning() << "Class QPen is undefined. Use QPen_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPen('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPen(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPen(RJSApi& handler, const QPen& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPen object:
          QPen_Wrapper* ret = new QPen_Wrapper(handler, new QPen(v), true);

          // JS: new QPen('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPen");
          if (cl.isUndefined()) {
              qWarning() << "Class QPen is undefined. Use QPen_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPen('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPen(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPen RJSHelper::js2cpp_QPen(RJSApi& handler, const QJSValue& v) {
          /*
          QPen_Wrapper* wrapper = getWrapper<QPen_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPen: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPen();
          }
          //return *(QPen*)wrapper->getWrappedVoid();
          QPen* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPen: wrapped pointer is NULL";
              return QPen();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPen: not a QObject";
              return QPen();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPen_ptr: no wrapper";
              handler.trace();
              return QPen();
          }
          //QPen* ret = getWrapped_QPen(wrapper);
          QPen* ret = QPen_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPen();
          }
          return *ret;
      }

      bool RJSHelper::is_QPen(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPen: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPen::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPicture(RJSApi& handler, const QPicture* v) {
          QJSEngine* engine = handler.getEngine();
          QPicture_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPicture_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPicture object:
              ret = new QPicture_Wrapper(handler, new QPicture(*v), true);
          }

          // JS: new QPicture('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPicture");
          if (cl.isUndefined()) {
              qWarning() << "Class QPicture is undefined. Use QPicture_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPicture('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPicture(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPicture(RJSApi& handler, const QPicture& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPicture object:
          QPicture_Wrapper* ret = new QPicture_Wrapper(handler, new QPicture(v), true);

          // JS: new QPicture('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPicture");
          if (cl.isUndefined()) {
              qWarning() << "Class QPicture is undefined. Use QPicture_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPicture('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPicture(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPicture RJSHelper::js2cpp_QPicture(RJSApi& handler, const QJSValue& v) {
          /*
          QPicture_Wrapper* wrapper = getWrapper<QPicture_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPicture: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPicture();
          }
          //return *(QPicture*)wrapper->getWrappedVoid();
          QPicture* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPicture: wrapped pointer is NULL";
              return QPicture();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPicture: not a QObject";
              return QPicture();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPicture_ptr: no wrapper";
              handler.trace();
              return QPicture();
          }
          //QPicture* ret = getWrapped_QPicture(wrapper);
          QPicture* ret = QPicture_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPicture();
          }
          return *ret;
      }

      bool RJSHelper::is_QPicture(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPicture: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPicture::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPixmap(RJSApi& handler, const QPixmap* v) {
          QJSEngine* engine = handler.getEngine();
          QPixmap_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPixmap_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPixmap object:
              ret = new QPixmap_Wrapper(handler, new QPixmap(*v), true);
          }

          // JS: new QPixmap('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPixmap");
          if (cl.isUndefined()) {
              qWarning() << "Class QPixmap is undefined. Use QPixmap_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPixmap('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPixmap(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPixmap(RJSApi& handler, const QPixmap& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPixmap object:
          QPixmap_Wrapper* ret = new QPixmap_Wrapper(handler, new QPixmap(v), true);

          // JS: new QPixmap('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPixmap");
          if (cl.isUndefined()) {
              qWarning() << "Class QPixmap is undefined. Use QPixmap_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPixmap('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPixmap(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPixmap RJSHelper::js2cpp_QPixmap(RJSApi& handler, const QJSValue& v) {
          /*
          QPixmap_Wrapper* wrapper = getWrapper<QPixmap_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPixmap: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPixmap();
          }
          //return *(QPixmap*)wrapper->getWrappedVoid();
          QPixmap* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPixmap: wrapped pointer is NULL";
              return QPixmap();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPixmap: not a QObject";
              return QPixmap();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPixmap_ptr: no wrapper";
              handler.trace();
              return QPixmap();
          }
          //QPixmap* ret = getWrapped_QPixmap(wrapper);
          QPixmap* ret = QPixmap_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPixmap();
          }
          return *ret;
      }

      bool RJSHelper::is_QPixmap(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPixmap: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPixmap::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPoint(RJSApi& handler, const QPoint* v) {
          QJSEngine* engine = handler.getEngine();
          QPoint_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPoint_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPoint object:
              ret = new QPoint_Wrapper(handler, new QPoint(*v), true);
          }

          // JS: new QPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class QPoint is undefined. Use QPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPoint('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPoint(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPoint(RJSApi& handler, const QPoint& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPoint object:
          QPoint_Wrapper* ret = new QPoint_Wrapper(handler, new QPoint(v), true);

          // JS: new QPoint('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPoint");
          if (cl.isUndefined()) {
              qWarning() << "Class QPoint is undefined. Use QPoint_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPoint('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPoint(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPoint RJSHelper::js2cpp_QPoint(RJSApi& handler, const QJSValue& v) {
          /*
          QPoint_Wrapper* wrapper = getWrapper<QPoint_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPoint: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPoint();
          }
          //return *(QPoint*)wrapper->getWrappedVoid();
          QPoint* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPoint: wrapped pointer is NULL";
              return QPoint();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPoint: not a QObject";
              return QPoint();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPoint_ptr: no wrapper";
              handler.trace();
              return QPoint();
          }
          //QPoint* ret = getWrapped_QPoint(wrapper);
          QPoint* ret = QPoint_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPoint();
          }
          return *ret;
      }

      bool RJSHelper::is_QPoint(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPoint: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPoint::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPointF(RJSApi& handler, const QPointF* v) {
          QJSEngine* engine = handler.getEngine();
          QPointF_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPointF_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPointF object:
              ret = new QPointF_Wrapper(handler, new QPointF(*v), true);
          }

          // JS: new QPointF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPointF");
          if (cl.isUndefined()) {
              qWarning() << "Class QPointF is undefined. Use QPointF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPointF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPointF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPointF(RJSApi& handler, const QPointF& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPointF object:
          QPointF_Wrapper* ret = new QPointF_Wrapper(handler, new QPointF(v), true);

          // JS: new QPointF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPointF");
          if (cl.isUndefined()) {
              qWarning() << "Class QPointF is undefined. Use QPointF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPointF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPointF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPointF RJSHelper::js2cpp_QPointF(RJSApi& handler, const QJSValue& v) {
          /*
          QPointF_Wrapper* wrapper = getWrapper<QPointF_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPointF: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPointF();
          }
          //return *(QPointF*)wrapper->getWrappedVoid();
          QPointF* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPointF: wrapped pointer is NULL";
              return QPointF();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPointF: not a QObject";
              return QPointF();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPointF_ptr: no wrapper";
              handler.trace();
              return QPointF();
          }
          //QPointF* ret = getWrapped_QPointF(wrapper);
          QPointF* ret = QPointF_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPointF();
          }
          return *ret;
      }

      bool RJSHelper::is_QPointF(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPointF: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPointF::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPolygon(RJSApi& handler, const QPolygon* v) {
          QJSEngine* engine = handler.getEngine();
          QPolygon_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPolygon_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPolygon object:
              ret = new QPolygon_Wrapper(handler, new QPolygon(*v), true);
          }

          // JS: new QPolygon('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPolygon");
          if (cl.isUndefined()) {
              qWarning() << "Class QPolygon is undefined. Use QPolygon_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPolygon('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPolygon(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPolygon(RJSApi& handler, const QPolygon& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPolygon object:
          QPolygon_Wrapper* ret = new QPolygon_Wrapper(handler, new QPolygon(v), true);

          // JS: new QPolygon('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPolygon");
          if (cl.isUndefined()) {
              qWarning() << "Class QPolygon is undefined. Use QPolygon_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPolygon('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPolygon(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPolygon RJSHelper::js2cpp_QPolygon(RJSApi& handler, const QJSValue& v) {
          /*
          QPolygon_Wrapper* wrapper = getWrapper<QPolygon_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPolygon: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPolygon();
          }
          //return *(QPolygon*)wrapper->getWrappedVoid();
          QPolygon* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPolygon: wrapped pointer is NULL";
              return QPolygon();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPolygon: not a QObject";
              return QPolygon();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPolygon_ptr: no wrapper";
              handler.trace();
              return QPolygon();
          }
          //QPolygon* ret = getWrapped_QPolygon(wrapper);
          QPolygon* ret = QPolygon_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPolygon();
          }
          return *ret;
      }

      bool RJSHelper::is_QPolygon(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPolygon: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPolygon::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPolygonF(RJSApi& handler, const QPolygonF* v) {
          QJSEngine* engine = handler.getEngine();
          QPolygonF_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPolygonF_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPolygonF object:
              ret = new QPolygonF_Wrapper(handler, new QPolygonF(*v), true);
          }

          // JS: new QPolygonF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPolygonF");
          if (cl.isUndefined()) {
              qWarning() << "Class QPolygonF is undefined. Use QPolygonF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPolygonF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPolygonF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPolygonF(RJSApi& handler, const QPolygonF& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPolygonF object:
          QPolygonF_Wrapper* ret = new QPolygonF_Wrapper(handler, new QPolygonF(v), true);

          // JS: new QPolygonF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPolygonF");
          if (cl.isUndefined()) {
              qWarning() << "Class QPolygonF is undefined. Use QPolygonF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPolygonF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPolygonF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPolygonF RJSHelper::js2cpp_QPolygonF(RJSApi& handler, const QJSValue& v) {
          /*
          QPolygonF_Wrapper* wrapper = getWrapper<QPolygonF_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPolygonF: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPolygonF();
          }
          //return *(QPolygonF*)wrapper->getWrappedVoid();
          QPolygonF* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPolygonF: wrapped pointer is NULL";
              return QPolygonF();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPolygonF: not a QObject";
              return QPolygonF();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPolygonF_ptr: no wrapper";
              handler.trace();
              return QPolygonF();
          }
          //QPolygonF* ret = getWrapped_QPolygonF(wrapper);
          QPolygonF* ret = QPolygonF_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPolygonF();
          }
          return *ret;
      }

      bool RJSHelper::is_QPolygonF(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPolygonF: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPolygonF::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QPrinterInfo(RJSApi& handler, const QPrinterInfo* v) {
          QJSEngine* engine = handler.getEngine();
          QPrinterInfo_Wrapper* ret;

          if (v==nullptr) {
              ret = new QPrinterInfo_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QPrinterInfo object:
              ret = new QPrinterInfo_Wrapper(handler, new QPrinterInfo(*v), true);
          }

          // JS: new QPrinterInfo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPrinterInfo");
          if (cl.isUndefined()) {
              qWarning() << "Class QPrinterInfo is undefined. Use QPrinterInfo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPrinterInfo('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPrinterInfo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPrinterInfo(RJSApi& handler, const QPrinterInfo& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QPrinterInfo object:
          QPrinterInfo_Wrapper* ret = new QPrinterInfo_Wrapper(handler, new QPrinterInfo(v), true);

          // JS: new QPrinterInfo('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPrinterInfo");
          if (cl.isUndefined()) {
              qWarning() << "Class QPrinterInfo is undefined. Use QPrinterInfo_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPrinterInfo('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPrinterInfo(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QPrinterInfo RJSHelper::js2cpp_QPrinterInfo(RJSApi& handler, const QJSValue& v) {
          /*
          QPrinterInfo_Wrapper* wrapper = getWrapper<QPrinterInfo_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPrinterInfo: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QPrinterInfo();
          }
          //return *(QPrinterInfo*)wrapper->getWrappedVoid();
          QPrinterInfo* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QPrinterInfo: wrapped pointer is NULL";
              return QPrinterInfo();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPrinterInfo: not a QObject";
              return QPrinterInfo();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPrinterInfo_ptr: no wrapper";
              handler.trace();
              return QPrinterInfo();
          }
          //QPrinterInfo* ret = getWrapped_QPrinterInfo(wrapper);
          QPrinterInfo* ret = QPrinterInfo_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QPrinterInfo();
          }
          return *ret;
      }

      bool RJSHelper::is_QPrinterInfo(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPrinterInfo: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QPrinterInfo::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QProcessEnvironment(RJSApi& handler, const QProcessEnvironment* v) {
          QJSEngine* engine = handler.getEngine();
          QProcessEnvironment_Wrapper* ret;

          if (v==nullptr) {
              ret = new QProcessEnvironment_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QProcessEnvironment object:
              ret = new QProcessEnvironment_Wrapper(handler, new QProcessEnvironment(*v), true);
          }

          // JS: new QProcessEnvironment('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QProcessEnvironment");
          if (cl.isUndefined()) {
              qWarning() << "Class QProcessEnvironment is undefined. Use QProcessEnvironment_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QProcessEnvironment('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QProcessEnvironment(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QProcessEnvironment(RJSApi& handler, const QProcessEnvironment& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QProcessEnvironment object:
          QProcessEnvironment_Wrapper* ret = new QProcessEnvironment_Wrapper(handler, new QProcessEnvironment(v), true);

          // JS: new QProcessEnvironment('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QProcessEnvironment");
          if (cl.isUndefined()) {
              qWarning() << "Class QProcessEnvironment is undefined. Use QProcessEnvironment_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QProcessEnvironment('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QProcessEnvironment(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QProcessEnvironment RJSHelper::js2cpp_QProcessEnvironment(RJSApi& handler, const QJSValue& v) {
          /*
          QProcessEnvironment_Wrapper* wrapper = getWrapper<QProcessEnvironment_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QProcessEnvironment: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QProcessEnvironment();
          }
          //return *(QProcessEnvironment*)wrapper->getWrappedVoid();
          QProcessEnvironment* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QProcessEnvironment: wrapped pointer is NULL";
              return QProcessEnvironment();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QProcessEnvironment: not a QObject";
              return QProcessEnvironment();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QProcessEnvironment_ptr: no wrapper";
              handler.trace();
              return QProcessEnvironment();
          }
          //QProcessEnvironment* ret = getWrapped_QProcessEnvironment(wrapper);
          QProcessEnvironment* ret = QProcessEnvironment_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QProcessEnvironment();
          }
          return *ret;
      }

      bool RJSHelper::is_QProcessEnvironment(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QProcessEnvironment: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QProcessEnvironment::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QRadialGradient(RJSApi& handler, const QRadialGradient* v) {
          QJSEngine* engine = handler.getEngine();
          QRadialGradient_Wrapper* ret;

          if (v==nullptr) {
              ret = new QRadialGradient_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QRadialGradient object:
              ret = new QRadialGradient_Wrapper(handler, new QRadialGradient(*v), true);
          }

          // JS: new QRadialGradient('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRadialGradient");
          if (cl.isUndefined()) {
              qWarning() << "Class QRadialGradient is undefined. Use QRadialGradient_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRadialGradient('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRadialGradient(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QRadialGradient(RJSApi& handler, const QRadialGradient& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QRadialGradient object:
          QRadialGradient_Wrapper* ret = new QRadialGradient_Wrapper(handler, new QRadialGradient(v), true);

          // JS: new QRadialGradient('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRadialGradient");
          if (cl.isUndefined()) {
              qWarning() << "Class QRadialGradient is undefined. Use QRadialGradient_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRadialGradient('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRadialGradient(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QRadialGradient RJSHelper::js2cpp_QRadialGradient(RJSApi& handler, const QJSValue& v) {
          /*
          QRadialGradient_Wrapper* wrapper = getWrapper<QRadialGradient_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRadialGradient: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QRadialGradient();
          }
          //return *(QRadialGradient*)wrapper->getWrappedVoid();
          QRadialGradient* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QRadialGradient: wrapped pointer is NULL";
              return QRadialGradient();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QRadialGradient: not a QObject";
              return QRadialGradient();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRadialGradient_ptr: no wrapper";
              handler.trace();
              return QRadialGradient();
          }
          //QRadialGradient* ret = getWrapped_QRadialGradient(wrapper);
          QRadialGradient* ret = QRadialGradient_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QRadialGradient();
          }
          return *ret;
      }

      bool RJSHelper::is_QRadialGradient(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QRadialGradient: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QRadialGradient::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QRect(RJSApi& handler, const QRect* v) {
          QJSEngine* engine = handler.getEngine();
          QRect_Wrapper* ret;

          if (v==nullptr) {
              ret = new QRect_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QRect object:
              ret = new QRect_Wrapper(handler, new QRect(*v), true);
          }

          // JS: new QRect('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRect");
          if (cl.isUndefined()) {
              qWarning() << "Class QRect is undefined. Use QRect_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRect('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRect(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QRect(RJSApi& handler, const QRect& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QRect object:
          QRect_Wrapper* ret = new QRect_Wrapper(handler, new QRect(v), true);

          // JS: new QRect('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRect");
          if (cl.isUndefined()) {
              qWarning() << "Class QRect is undefined. Use QRect_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRect('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRect(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QRect RJSHelper::js2cpp_QRect(RJSApi& handler, const QJSValue& v) {
          /*
          QRect_Wrapper* wrapper = getWrapper<QRect_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRect: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QRect();
          }
          //return *(QRect*)wrapper->getWrappedVoid();
          QRect* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QRect: wrapped pointer is NULL";
              return QRect();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QRect: not a QObject";
              return QRect();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRect_ptr: no wrapper";
              handler.trace();
              return QRect();
          }
          //QRect* ret = getWrapped_QRect(wrapper);
          QRect* ret = QRect_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QRect();
          }
          return *ret;
      }

      bool RJSHelper::is_QRect(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QRect: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QRect::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QRectF(RJSApi& handler, const QRectF* v) {
          QJSEngine* engine = handler.getEngine();
          QRectF_Wrapper* ret;

          if (v==nullptr) {
              ret = new QRectF_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QRectF object:
              ret = new QRectF_Wrapper(handler, new QRectF(*v), true);
          }

          // JS: new QRectF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRectF");
          if (cl.isUndefined()) {
              qWarning() << "Class QRectF is undefined. Use QRectF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRectF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRectF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QRectF(RJSApi& handler, const QRectF& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QRectF object:
          QRectF_Wrapper* ret = new QRectF_Wrapper(handler, new QRectF(v), true);

          // JS: new QRectF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRectF");
          if (cl.isUndefined()) {
              qWarning() << "Class QRectF is undefined. Use QRectF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRectF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRectF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QRectF RJSHelper::js2cpp_QRectF(RJSApi& handler, const QJSValue& v) {
          /*
          QRectF_Wrapper* wrapper = getWrapper<QRectF_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRectF: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QRectF();
          }
          //return *(QRectF*)wrapper->getWrappedVoid();
          QRectF* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QRectF: wrapped pointer is NULL";
              return QRectF();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QRectF: not a QObject";
              return QRectF();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRectF_ptr: no wrapper";
              handler.trace();
              return QRectF();
          }
          //QRectF* ret = getWrapped_QRectF(wrapper);
          QRectF* ret = QRectF_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QRectF();
          }
          return *ret;
      }

      bool RJSHelper::is_QRectF(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QRectF: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QRectF::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QRegion(RJSApi& handler, const QRegion* v) {
          QJSEngine* engine = handler.getEngine();
          QRegion_Wrapper* ret;

          if (v==nullptr) {
              ret = new QRegion_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QRegion object:
              ret = new QRegion_Wrapper(handler, new QRegion(*v), true);
          }

          // JS: new QRegion('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRegion");
          if (cl.isUndefined()) {
              qWarning() << "Class QRegion is undefined. Use QRegion_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRegion('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRegion(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QRegion(RJSApi& handler, const QRegion& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QRegion object:
          QRegion_Wrapper* ret = new QRegion_Wrapper(handler, new QRegion(v), true);

          // JS: new QRegion('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRegion");
          if (cl.isUndefined()) {
              qWarning() << "Class QRegion is undefined. Use QRegion_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRegion('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRegion(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QRegion RJSHelper::js2cpp_QRegion(RJSApi& handler, const QJSValue& v) {
          /*
          QRegion_Wrapper* wrapper = getWrapper<QRegion_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRegion: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QRegion();
          }
          //return *(QRegion*)wrapper->getWrappedVoid();
          QRegion* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QRegion: wrapped pointer is NULL";
              return QRegion();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QRegion: not a QObject";
              return QRegion();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRegion_ptr: no wrapper";
              handler.trace();
              return QRegion();
          }
          //QRegion* ret = getWrapped_QRegion(wrapper);
          QRegion* ret = QRegion_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QRegion();
          }
          return *ret;
      }

      bool RJSHelper::is_QRegion(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QRegion: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QRegion::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QRegularExpression(RJSApi& handler, const QRegularExpression* v) {
          QJSEngine* engine = handler.getEngine();
          QRegularExpression_Wrapper* ret;

          if (v==nullptr) {
              ret = new QRegularExpression_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QRegularExpression object:
              ret = new QRegularExpression_Wrapper(handler, new QRegularExpression(*v), true);
          }

          // JS: new QRegularExpression('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRegularExpression");
          if (cl.isUndefined()) {
              qWarning() << "Class QRegularExpression is undefined. Use QRegularExpression_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRegularExpression('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRegularExpression(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QRegularExpression(RJSApi& handler, const QRegularExpression& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QRegularExpression object:
          QRegularExpression_Wrapper* ret = new QRegularExpression_Wrapper(handler, new QRegularExpression(v), true);

          // JS: new QRegularExpression('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRegularExpression");
          if (cl.isUndefined()) {
              qWarning() << "Class QRegularExpression is undefined. Use QRegularExpression_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRegularExpression('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRegularExpression(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QRegularExpression RJSHelper::js2cpp_QRegularExpression(RJSApi& handler, const QJSValue& v) {
          /*
          QRegularExpression_Wrapper* wrapper = getWrapper<QRegularExpression_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRegularExpression: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QRegularExpression();
          }
          //return *(QRegularExpression*)wrapper->getWrappedVoid();
          QRegularExpression* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QRegularExpression: wrapped pointer is NULL";
              return QRegularExpression();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QRegularExpression: not a QObject";
              return QRegularExpression();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRegularExpression_ptr: no wrapper";
              handler.trace();
              return QRegularExpression();
          }
          //QRegularExpression* ret = getWrapped_QRegularExpression(wrapper);
          QRegularExpression* ret = QRegularExpression_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QRegularExpression();
          }
          return *ret;
      }

      bool RJSHelper::is_QRegularExpression(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QRegularExpression: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QRegularExpression::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QRegularExpressionMatch(RJSApi& handler, const QRegularExpressionMatch* v) {
          QJSEngine* engine = handler.getEngine();
          QRegularExpressionMatch_Wrapper* ret;

          if (v==nullptr) {
              ret = new QRegularExpressionMatch_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QRegularExpressionMatch object:
              ret = new QRegularExpressionMatch_Wrapper(handler, new QRegularExpressionMatch(*v), true);
          }

          // JS: new QRegularExpressionMatch('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRegularExpressionMatch");
          if (cl.isUndefined()) {
              qWarning() << "Class QRegularExpressionMatch is undefined. Use QRegularExpressionMatch_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRegularExpressionMatch('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRegularExpressionMatch(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QRegularExpressionMatch(RJSApi& handler, const QRegularExpressionMatch& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QRegularExpressionMatch object:
          QRegularExpressionMatch_Wrapper* ret = new QRegularExpressionMatch_Wrapper(handler, new QRegularExpressionMatch(v), true);

          // JS: new QRegularExpressionMatch('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRegularExpressionMatch");
          if (cl.isUndefined()) {
              qWarning() << "Class QRegularExpressionMatch is undefined. Use QRegularExpressionMatch_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRegularExpressionMatch('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRegularExpressionMatch(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QRegularExpressionMatch RJSHelper::js2cpp_QRegularExpressionMatch(RJSApi& handler, const QJSValue& v) {
          /*
          QRegularExpressionMatch_Wrapper* wrapper = getWrapper<QRegularExpressionMatch_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRegularExpressionMatch: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QRegularExpressionMatch();
          }
          //return *(QRegularExpressionMatch*)wrapper->getWrappedVoid();
          QRegularExpressionMatch* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QRegularExpressionMatch: wrapped pointer is NULL";
              return QRegularExpressionMatch();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QRegularExpressionMatch: not a QObject";
              return QRegularExpressionMatch();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRegularExpressionMatch_ptr: no wrapper";
              handler.trace();
              return QRegularExpressionMatch();
          }
          //QRegularExpressionMatch* ret = getWrapped_QRegularExpressionMatch(wrapper);
          QRegularExpressionMatch* ret = QRegularExpressionMatch_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QRegularExpressionMatch();
          }
          return *ret;
      }

      bool RJSHelper::is_QRegularExpressionMatch(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QRegularExpressionMatch: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QRegularExpressionMatch::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QSize(RJSApi& handler, const QSize* v) {
          QJSEngine* engine = handler.getEngine();
          QSize_Wrapper* ret;

          if (v==nullptr) {
              ret = new QSize_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QSize object:
              ret = new QSize_Wrapper(handler, new QSize(*v), true);
          }

          // JS: new QSize('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSize");
          if (cl.isUndefined()) {
              qWarning() << "Class QSize is undefined. Use QSize_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSize('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSize(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSize(RJSApi& handler, const QSize& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QSize object:
          QSize_Wrapper* ret = new QSize_Wrapper(handler, new QSize(v), true);

          // JS: new QSize('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSize");
          if (cl.isUndefined()) {
              qWarning() << "Class QSize is undefined. Use QSize_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSize('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSize(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QSize RJSHelper::js2cpp_QSize(RJSApi& handler, const QJSValue& v) {
          /*
          QSize_Wrapper* wrapper = getWrapper<QSize_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSize: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QSize();
          }
          //return *(QSize*)wrapper->getWrappedVoid();
          QSize* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QSize: wrapped pointer is NULL";
              return QSize();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSize: not a QObject";
              return QSize();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSize_ptr: no wrapper";
              handler.trace();
              return QSize();
          }
          //QSize* ret = getWrapped_QSize(wrapper);
          QSize* ret = QSize_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QSize();
          }
          return *ret;
      }

      bool RJSHelper::is_QSize(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSize: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QSize::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QSizeF(RJSApi& handler, const QSizeF* v) {
          QJSEngine* engine = handler.getEngine();
          QSizeF_Wrapper* ret;

          if (v==nullptr) {
              ret = new QSizeF_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QSizeF object:
              ret = new QSizeF_Wrapper(handler, new QSizeF(*v), true);
          }

          // JS: new QSizeF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSizeF");
          if (cl.isUndefined()) {
              qWarning() << "Class QSizeF is undefined. Use QSizeF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSizeF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSizeF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSizeF(RJSApi& handler, const QSizeF& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QSizeF object:
          QSizeF_Wrapper* ret = new QSizeF_Wrapper(handler, new QSizeF(v), true);

          // JS: new QSizeF('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSizeF");
          if (cl.isUndefined()) {
              qWarning() << "Class QSizeF is undefined. Use QSizeF_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSizeF('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSizeF(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QSizeF RJSHelper::js2cpp_QSizeF(RJSApi& handler, const QJSValue& v) {
          /*
          QSizeF_Wrapper* wrapper = getWrapper<QSizeF_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSizeF: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QSizeF();
          }
          //return *(QSizeF*)wrapper->getWrappedVoid();
          QSizeF* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QSizeF: wrapped pointer is NULL";
              return QSizeF();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSizeF: not a QObject";
              return QSizeF();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSizeF_ptr: no wrapper";
              handler.trace();
              return QSizeF();
          }
          //QSizeF* ret = getWrapped_QSizeF(wrapper);
          QSizeF* ret = QSizeF_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QSizeF();
          }
          return *ret;
      }

      bool RJSHelper::is_QSizeF(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSizeF: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QSizeF::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QSizePolicy(RJSApi& handler, const QSizePolicy* v) {
          QJSEngine* engine = handler.getEngine();
          QSizePolicy_Wrapper* ret;

          if (v==nullptr) {
              ret = new QSizePolicy_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QSizePolicy object:
              ret = new QSizePolicy_Wrapper(handler, new QSizePolicy(*v), true);
          }

          // JS: new QSizePolicy('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSizePolicy");
          if (cl.isUndefined()) {
              qWarning() << "Class QSizePolicy is undefined. Use QSizePolicy_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSizePolicy('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSizePolicy(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSizePolicy(RJSApi& handler, const QSizePolicy& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QSizePolicy object:
          QSizePolicy_Wrapper* ret = new QSizePolicy_Wrapper(handler, new QSizePolicy(v), true);

          // JS: new QSizePolicy('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSizePolicy");
          if (cl.isUndefined()) {
              qWarning() << "Class QSizePolicy is undefined. Use QSizePolicy_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSizePolicy('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSizePolicy(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QSizePolicy RJSHelper::js2cpp_QSizePolicy(RJSApi& handler, const QJSValue& v) {
          /*
          QSizePolicy_Wrapper* wrapper = getWrapper<QSizePolicy_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSizePolicy: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QSizePolicy();
          }
          //return *(QSizePolicy*)wrapper->getWrappedVoid();
          QSizePolicy* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QSizePolicy: wrapped pointer is NULL";
              return QSizePolicy();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSizePolicy: not a QObject";
              return QSizePolicy();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSizePolicy_ptr: no wrapper";
              handler.trace();
              return QSizePolicy();
          }
          //QSizePolicy* ret = getWrapped_QSizePolicy(wrapper);
          QSizePolicy* ret = QSizePolicy_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QSizePolicy();
          }
          return *ret;
      }

      bool RJSHelper::is_QSizePolicy(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSizePolicy: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QSizePolicy::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QSurfaceFormat(RJSApi& handler, const QSurfaceFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QSurfaceFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QSurfaceFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QSurfaceFormat object:
              ret = new QSurfaceFormat_Wrapper(handler, new QSurfaceFormat(*v), true);
          }

          // JS: new QSurfaceFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSurfaceFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QSurfaceFormat is undefined. Use QSurfaceFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSurfaceFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSurfaceFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSurfaceFormat(RJSApi& handler, const QSurfaceFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QSurfaceFormat object:
          QSurfaceFormat_Wrapper* ret = new QSurfaceFormat_Wrapper(handler, new QSurfaceFormat(v), true);

          // JS: new QSurfaceFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSurfaceFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QSurfaceFormat is undefined. Use QSurfaceFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSurfaceFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSurfaceFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QSurfaceFormat RJSHelper::js2cpp_QSurfaceFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QSurfaceFormat_Wrapper* wrapper = getWrapper<QSurfaceFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSurfaceFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QSurfaceFormat();
          }
          //return *(QSurfaceFormat*)wrapper->getWrappedVoid();
          QSurfaceFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QSurfaceFormat: wrapped pointer is NULL";
              return QSurfaceFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSurfaceFormat: not a QObject";
              return QSurfaceFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSurfaceFormat_ptr: no wrapper";
              handler.trace();
              return QSurfaceFormat();
          }
          //QSurfaceFormat* ret = getWrapped_QSurfaceFormat(wrapper);
          QSurfaceFormat* ret = QSurfaceFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QSurfaceFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QSurfaceFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSurfaceFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QSurfaceFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextBlockFormat(RJSApi& handler, const QTextBlockFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QTextBlockFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextBlockFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextBlockFormat object:
              ret = new QTextBlockFormat_Wrapper(handler, new QTextBlockFormat(*v), true);
          }

          // JS: new QTextBlockFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextBlockFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextBlockFormat is undefined. Use QTextBlockFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextBlockFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextBlockFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextBlockFormat(RJSApi& handler, const QTextBlockFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextBlockFormat object:
          QTextBlockFormat_Wrapper* ret = new QTextBlockFormat_Wrapper(handler, new QTextBlockFormat(v), true);

          // JS: new QTextBlockFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextBlockFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextBlockFormat is undefined. Use QTextBlockFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextBlockFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextBlockFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextBlockFormat RJSHelper::js2cpp_QTextBlockFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QTextBlockFormat_Wrapper* wrapper = getWrapper<QTextBlockFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextBlockFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextBlockFormat();
          }
          //return *(QTextBlockFormat*)wrapper->getWrappedVoid();
          QTextBlockFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextBlockFormat: wrapped pointer is NULL";
              return QTextBlockFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextBlockFormat: not a QObject";
              return QTextBlockFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextBlockFormat_ptr: no wrapper";
              handler.trace();
              return QTextBlockFormat();
          }
          //QTextBlockFormat* ret = getWrapped_QTextBlockFormat(wrapper);
          QTextBlockFormat* ret = QTextBlockFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextBlockFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextBlockFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextBlockFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextBlockFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextCharFormat(RJSApi& handler, const QTextCharFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QTextCharFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextCharFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextCharFormat object:
              ret = new QTextCharFormat_Wrapper(handler, new QTextCharFormat(*v), true);
          }

          // JS: new QTextCharFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextCharFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextCharFormat is undefined. Use QTextCharFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextCharFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextCharFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextCharFormat(RJSApi& handler, const QTextCharFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextCharFormat object:
          QTextCharFormat_Wrapper* ret = new QTextCharFormat_Wrapper(handler, new QTextCharFormat(v), true);

          // JS: new QTextCharFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextCharFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextCharFormat is undefined. Use QTextCharFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextCharFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextCharFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextCharFormat RJSHelper::js2cpp_QTextCharFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QTextCharFormat_Wrapper* wrapper = getWrapper<QTextCharFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextCharFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextCharFormat();
          }
          //return *(QTextCharFormat*)wrapper->getWrappedVoid();
          QTextCharFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextCharFormat: wrapped pointer is NULL";
              return QTextCharFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextCharFormat: not a QObject";
              return QTextCharFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextCharFormat_ptr: no wrapper";
              handler.trace();
              return QTextCharFormat();
          }
          //QTextCharFormat* ret = getWrapped_QTextCharFormat(wrapper);
          QTextCharFormat* ret = QTextCharFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextCharFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextCharFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextCharFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextCharFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextCursor(RJSApi& handler, const QTextCursor* v) {
          QJSEngine* engine = handler.getEngine();
          QTextCursor_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextCursor_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextCursor object:
              ret = new QTextCursor_Wrapper(handler, new QTextCursor(*v), true);
          }

          // JS: new QTextCursor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextCursor");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextCursor is undefined. Use QTextCursor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextCursor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextCursor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextCursor(RJSApi& handler, const QTextCursor& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextCursor object:
          QTextCursor_Wrapper* ret = new QTextCursor_Wrapper(handler, new QTextCursor(v), true);

          // JS: new QTextCursor('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextCursor");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextCursor is undefined. Use QTextCursor_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextCursor('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextCursor(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextCursor RJSHelper::js2cpp_QTextCursor(RJSApi& handler, const QJSValue& v) {
          /*
          QTextCursor_Wrapper* wrapper = getWrapper<QTextCursor_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextCursor: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextCursor();
          }
          //return *(QTextCursor*)wrapper->getWrappedVoid();
          QTextCursor* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextCursor: wrapped pointer is NULL";
              return QTextCursor();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextCursor: not a QObject";
              return QTextCursor();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextCursor_ptr: no wrapper";
              handler.trace();
              return QTextCursor();
          }
          //QTextCursor* ret = getWrapped_QTextCursor(wrapper);
          QTextCursor* ret = QTextCursor_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextCursor();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextCursor(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextCursor: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextCursor::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextFormat(RJSApi& handler, const QTextFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QTextFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextFormat object:
              ret = new QTextFormat_Wrapper(handler, new QTextFormat(*v), true);
          }

          // JS: new QTextFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextFormat is undefined. Use QTextFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextFormat(RJSApi& handler, const QTextFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextFormat object:
          QTextFormat_Wrapper* ret = new QTextFormat_Wrapper(handler, new QTextFormat(v), true);

          // JS: new QTextFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextFormat is undefined. Use QTextFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextFormat RJSHelper::js2cpp_QTextFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QTextFormat_Wrapper* wrapper = getWrapper<QTextFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextFormat();
          }
          //return *(QTextFormat*)wrapper->getWrappedVoid();
          QTextFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextFormat: wrapped pointer is NULL";
              return QTextFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextFormat: not a QObject";
              return QTextFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextFormat_ptr: no wrapper";
              handler.trace();
              return QTextFormat();
          }
          //QTextFormat* ret = getWrapped_QTextFormat(wrapper);
          QTextFormat* ret = QTextFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextFrameFormat(RJSApi& handler, const QTextFrameFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QTextFrameFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextFrameFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextFrameFormat object:
              ret = new QTextFrameFormat_Wrapper(handler, new QTextFrameFormat(*v), true);
          }

          // JS: new QTextFrameFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextFrameFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextFrameFormat is undefined. Use QTextFrameFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextFrameFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextFrameFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextFrameFormat(RJSApi& handler, const QTextFrameFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextFrameFormat object:
          QTextFrameFormat_Wrapper* ret = new QTextFrameFormat_Wrapper(handler, new QTextFrameFormat(v), true);

          // JS: new QTextFrameFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextFrameFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextFrameFormat is undefined. Use QTextFrameFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextFrameFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextFrameFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextFrameFormat RJSHelper::js2cpp_QTextFrameFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QTextFrameFormat_Wrapper* wrapper = getWrapper<QTextFrameFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextFrameFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextFrameFormat();
          }
          //return *(QTextFrameFormat*)wrapper->getWrappedVoid();
          QTextFrameFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextFrameFormat: wrapped pointer is NULL";
              return QTextFrameFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextFrameFormat: not a QObject";
              return QTextFrameFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextFrameFormat_ptr: no wrapper";
              handler.trace();
              return QTextFrameFormat();
          }
          //QTextFrameFormat* ret = getWrapped_QTextFrameFormat(wrapper);
          QTextFrameFormat* ret = QTextFrameFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextFrameFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextFrameFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextFrameFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextFrameFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextImageFormat(RJSApi& handler, const QTextImageFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QTextImageFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextImageFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextImageFormat object:
              ret = new QTextImageFormat_Wrapper(handler, new QTextImageFormat(*v), true);
          }

          // JS: new QTextImageFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextImageFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextImageFormat is undefined. Use QTextImageFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextImageFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextImageFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextImageFormat(RJSApi& handler, const QTextImageFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextImageFormat object:
          QTextImageFormat_Wrapper* ret = new QTextImageFormat_Wrapper(handler, new QTextImageFormat(v), true);

          // JS: new QTextImageFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextImageFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextImageFormat is undefined. Use QTextImageFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextImageFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextImageFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextImageFormat RJSHelper::js2cpp_QTextImageFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QTextImageFormat_Wrapper* wrapper = getWrapper<QTextImageFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextImageFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextImageFormat();
          }
          //return *(QTextImageFormat*)wrapper->getWrappedVoid();
          QTextImageFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextImageFormat: wrapped pointer is NULL";
              return QTextImageFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextImageFormat: not a QObject";
              return QTextImageFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextImageFormat_ptr: no wrapper";
              handler.trace();
              return QTextImageFormat();
          }
          //QTextImageFormat* ret = getWrapped_QTextImageFormat(wrapper);
          QTextImageFormat* ret = QTextImageFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextImageFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextImageFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextImageFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextImageFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextLength(RJSApi& handler, const QTextLength* v) {
          QJSEngine* engine = handler.getEngine();
          QTextLength_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextLength_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextLength object:
              ret = new QTextLength_Wrapper(handler, new QTextLength(*v), true);
          }

          // JS: new QTextLength('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextLength");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextLength is undefined. Use QTextLength_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextLength('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextLength(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextLength(RJSApi& handler, const QTextLength& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextLength object:
          QTextLength_Wrapper* ret = new QTextLength_Wrapper(handler, new QTextLength(v), true);

          // JS: new QTextLength('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextLength");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextLength is undefined. Use QTextLength_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextLength('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextLength(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextLength RJSHelper::js2cpp_QTextLength(RJSApi& handler, const QJSValue& v) {
          /*
          QTextLength_Wrapper* wrapper = getWrapper<QTextLength_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextLength: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextLength();
          }
          //return *(QTextLength*)wrapper->getWrappedVoid();
          QTextLength* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextLength: wrapped pointer is NULL";
              return QTextLength();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextLength: not a QObject";
              return QTextLength();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextLength_ptr: no wrapper";
              handler.trace();
              return QTextLength();
          }
          //QTextLength* ret = getWrapped_QTextLength(wrapper);
          QTextLength* ret = QTextLength_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextLength();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextLength(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextLength: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextLength::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextListFormat(RJSApi& handler, const QTextListFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QTextListFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextListFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextListFormat object:
              ret = new QTextListFormat_Wrapper(handler, new QTextListFormat(*v), true);
          }

          // JS: new QTextListFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextListFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextListFormat is undefined. Use QTextListFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextListFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextListFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextListFormat(RJSApi& handler, const QTextListFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextListFormat object:
          QTextListFormat_Wrapper* ret = new QTextListFormat_Wrapper(handler, new QTextListFormat(v), true);

          // JS: new QTextListFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextListFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextListFormat is undefined. Use QTextListFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextListFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextListFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextListFormat RJSHelper::js2cpp_QTextListFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QTextListFormat_Wrapper* wrapper = getWrapper<QTextListFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextListFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextListFormat();
          }
          //return *(QTextListFormat*)wrapper->getWrappedVoid();
          QTextListFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextListFormat: wrapped pointer is NULL";
              return QTextListFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextListFormat: not a QObject";
              return QTextListFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextListFormat_ptr: no wrapper";
              handler.trace();
              return QTextListFormat();
          }
          //QTextListFormat* ret = getWrapped_QTextListFormat(wrapper);
          QTextListFormat* ret = QTextListFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextListFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextListFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextListFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextListFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextTableCellFormat(RJSApi& handler, const QTextTableCellFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QTextTableCellFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextTableCellFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextTableCellFormat object:
              ret = new QTextTableCellFormat_Wrapper(handler, new QTextTableCellFormat(*v), true);
          }

          // JS: new QTextTableCellFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextTableCellFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextTableCellFormat is undefined. Use QTextTableCellFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextTableCellFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextTableCellFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextTableCellFormat(RJSApi& handler, const QTextTableCellFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextTableCellFormat object:
          QTextTableCellFormat_Wrapper* ret = new QTextTableCellFormat_Wrapper(handler, new QTextTableCellFormat(v), true);

          // JS: new QTextTableCellFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextTableCellFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextTableCellFormat is undefined. Use QTextTableCellFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextTableCellFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextTableCellFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextTableCellFormat RJSHelper::js2cpp_QTextTableCellFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QTextTableCellFormat_Wrapper* wrapper = getWrapper<QTextTableCellFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextTableCellFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextTableCellFormat();
          }
          //return *(QTextTableCellFormat*)wrapper->getWrappedVoid();
          QTextTableCellFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextTableCellFormat: wrapped pointer is NULL";
              return QTextTableCellFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextTableCellFormat: not a QObject";
              return QTextTableCellFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextTableCellFormat_ptr: no wrapper";
              handler.trace();
              return QTextTableCellFormat();
          }
          //QTextTableCellFormat* ret = getWrapped_QTextTableCellFormat(wrapper);
          QTextTableCellFormat* ret = QTextTableCellFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextTableCellFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextTableCellFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextTableCellFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextTableCellFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTextTableFormat(RJSApi& handler, const QTextTableFormat* v) {
          QJSEngine* engine = handler.getEngine();
          QTextTableFormat_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTextTableFormat_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTextTableFormat object:
              ret = new QTextTableFormat_Wrapper(handler, new QTextTableFormat(*v), true);
          }

          // JS: new QTextTableFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextTableFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextTableFormat is undefined. Use QTextTableFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextTableFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextTableFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextTableFormat(RJSApi& handler, const QTextTableFormat& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTextTableFormat object:
          QTextTableFormat_Wrapper* ret = new QTextTableFormat_Wrapper(handler, new QTextTableFormat(v), true);

          // JS: new QTextTableFormat('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextTableFormat");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextTableFormat is undefined. Use QTextTableFormat_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextTableFormat('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextTableFormat(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTextTableFormat RJSHelper::js2cpp_QTextTableFormat(RJSApi& handler, const QJSValue& v) {
          /*
          QTextTableFormat_Wrapper* wrapper = getWrapper<QTextTableFormat_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextTableFormat: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTextTableFormat();
          }
          //return *(QTextTableFormat*)wrapper->getWrappedVoid();
          QTextTableFormat* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTextTableFormat: wrapped pointer is NULL";
              return QTextTableFormat();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextTableFormat: not a QObject";
              return QTextTableFormat();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextTableFormat_ptr: no wrapper";
              handler.trace();
              return QTextTableFormat();
          }
          //QTextTableFormat* ret = getWrapped_QTextTableFormat(wrapper);
          QTextTableFormat* ret = QTextTableFormat_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTextTableFormat();
          }
          return *ret;
      }

      bool RJSHelper::is_QTextTableFormat(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextTableFormat: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextTableFormat::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTime(RJSApi& handler, const QTime* v) {
          QJSEngine* engine = handler.getEngine();
          QTime_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTime_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTime object:
              ret = new QTime_Wrapper(handler, new QTime(*v), true);
          }

          // JS: new QTime('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTime");
          if (cl.isUndefined()) {
              qWarning() << "Class QTime is undefined. Use QTime_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTime('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTime(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTime(RJSApi& handler, const QTime& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTime object:
          QTime_Wrapper* ret = new QTime_Wrapper(handler, new QTime(v), true);

          // JS: new QTime('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTime");
          if (cl.isUndefined()) {
              qWarning() << "Class QTime is undefined. Use QTime_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTime('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTime(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTime RJSHelper::js2cpp_QTime(RJSApi& handler, const QJSValue& v) {
          /*
          QTime_Wrapper* wrapper = getWrapper<QTime_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTime: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTime();
          }
          //return *(QTime*)wrapper->getWrappedVoid();
          QTime* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTime: wrapped pointer is NULL";
              return QTime();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTime: not a QObject";
              return QTime();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTime_ptr: no wrapper";
              handler.trace();
              return QTime();
          }
          //QTime* ret = getWrapped_QTime(wrapper);
          QTime* ret = QTime_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTime();
          }
          return *ret;
      }

      bool RJSHelper::is_QTime(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTime: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTime::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QTransform(RJSApi& handler, const QTransform* v) {
          QJSEngine* engine = handler.getEngine();
          QTransform_Wrapper* ret;

          if (v==nullptr) {
              ret = new QTransform_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QTransform object:
              ret = new QTransform_Wrapper(handler, new QTransform(*v), true);
          }

          // JS: new QTransform('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTransform");
          if (cl.isUndefined()) {
              qWarning() << "Class QTransform is undefined. Use QTransform_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTransform('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTransform(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTransform(RJSApi& handler, const QTransform& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QTransform object:
          QTransform_Wrapper* ret = new QTransform_Wrapper(handler, new QTransform(v), true);

          // JS: new QTransform('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTransform");
          if (cl.isUndefined()) {
              qWarning() << "Class QTransform is undefined. Use QTransform_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTransform('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTransform(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QTransform RJSHelper::js2cpp_QTransform(RJSApi& handler, const QJSValue& v) {
          /*
          QTransform_Wrapper* wrapper = getWrapper<QTransform_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTransform: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QTransform();
          }
          //return *(QTransform*)wrapper->getWrappedVoid();
          QTransform* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QTransform: wrapped pointer is NULL";
              return QTransform();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTransform: not a QObject";
              return QTransform();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTransform_ptr: no wrapper";
              handler.trace();
              return QTransform();
          }
          //QTransform* ret = getWrapped_QTransform(wrapper);
          QTransform* ret = QTransform_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QTransform();
          }
          return *ret;
      }

      bool RJSHelper::is_QTransform(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTransform: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QTransform::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QUrl(RJSApi& handler, const QUrl* v) {
          QJSEngine* engine = handler.getEngine();
          QUrl_Wrapper* ret;

          if (v==nullptr) {
              ret = new QUrl_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QUrl object:
              ret = new QUrl_Wrapper(handler, new QUrl(*v), true);
          }

          // JS: new QUrl('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QUrl");
          if (cl.isUndefined()) {
              qWarning() << "Class QUrl is undefined. Use QUrl_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QUrl('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QUrl(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QUrl(RJSApi& handler, const QUrl& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QUrl object:
          QUrl_Wrapper* ret = new QUrl_Wrapper(handler, new QUrl(v), true);

          // JS: new QUrl('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QUrl");
          if (cl.isUndefined()) {
              qWarning() << "Class QUrl is undefined. Use QUrl_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QUrl('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QUrl(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QUrl RJSHelper::js2cpp_QUrl(RJSApi& handler, const QJSValue& v) {
          /*
          QUrl_Wrapper* wrapper = getWrapper<QUrl_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QUrl: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QUrl();
          }
          //return *(QUrl*)wrapper->getWrappedVoid();
          QUrl* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QUrl: wrapped pointer is NULL";
              return QUrl();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QUrl: not a QObject";
              return QUrl();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QUrl_ptr: no wrapper";
              handler.trace();
              return QUrl();
          }
          //QUrl* ret = getWrapped_QUrl(wrapper);
          QUrl* ret = QUrl_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QUrl();
          }
          return *ret;
      }

      bool RJSHelper::is_QUrl(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QUrl: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QUrl::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QUrlQuery(RJSApi& handler, const QUrlQuery* v) {
          QJSEngine* engine = handler.getEngine();
          QUrlQuery_Wrapper* ret;

          if (v==nullptr) {
              ret = new QUrlQuery_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QUrlQuery object:
              ret = new QUrlQuery_Wrapper(handler, new QUrlQuery(*v), true);
          }

          // JS: new QUrlQuery('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QUrlQuery");
          if (cl.isUndefined()) {
              qWarning() << "Class QUrlQuery is undefined. Use QUrlQuery_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QUrlQuery('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QUrlQuery(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QUrlQuery(RJSApi& handler, const QUrlQuery& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QUrlQuery object:
          QUrlQuery_Wrapper* ret = new QUrlQuery_Wrapper(handler, new QUrlQuery(v), true);

          // JS: new QUrlQuery('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QUrlQuery");
          if (cl.isUndefined()) {
              qWarning() << "Class QUrlQuery is undefined. Use QUrlQuery_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QUrlQuery('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QUrlQuery(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QUrlQuery RJSHelper::js2cpp_QUrlQuery(RJSApi& handler, const QJSValue& v) {
          /*
          QUrlQuery_Wrapper* wrapper = getWrapper<QUrlQuery_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QUrlQuery: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QUrlQuery();
          }
          //return *(QUrlQuery*)wrapper->getWrappedVoid();
          QUrlQuery* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QUrlQuery: wrapped pointer is NULL";
              return QUrlQuery();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QUrlQuery: not a QObject";
              return QUrlQuery();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QUrlQuery_ptr: no wrapper";
              handler.trace();
              return QUrlQuery();
          }
          //QUrlQuery* ret = getWrapped_QUrlQuery(wrapper);
          QUrlQuery* ret = QUrlQuery_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QUrlQuery();
          }
          return *ret;
      }

      bool RJSHelper::is_QUrlQuery(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QUrlQuery: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QUrlQuery::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlAttributes(RJSApi& handler, const QXmlAttributes* v) {
          QJSEngine* engine = handler.getEngine();
          QXmlAttributes_Wrapper* ret;

          if (v==nullptr) {
              ret = new QXmlAttributes_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QXmlAttributes object:
              ret = new QXmlAttributes_Wrapper(handler, new QXmlAttributes(*v), true);
          }

          // JS: new QXmlAttributes('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlAttributes");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlAttributes is undefined. Use QXmlAttributes_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlAttributes('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlAttributes(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QXmlAttributes(RJSApi& handler, const QXmlAttributes& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QXmlAttributes object:
          QXmlAttributes_Wrapper* ret = new QXmlAttributes_Wrapper(handler, new QXmlAttributes(v), true);

          // JS: new QXmlAttributes('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlAttributes");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlAttributes is undefined. Use QXmlAttributes_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlAttributes('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlAttributes(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QXmlAttributes RJSHelper::js2cpp_QXmlAttributes(RJSApi& handler, const QJSValue& v) {
          /*
          QXmlAttributes_Wrapper* wrapper = getWrapper<QXmlAttributes_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlAttributes: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QXmlAttributes();
          }
          //return *(QXmlAttributes*)wrapper->getWrappedVoid();
          QXmlAttributes* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QXmlAttributes: wrapped pointer is NULL";
              return QXmlAttributes();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlAttributes: not a QObject";
              return QXmlAttributes();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlAttributes_ptr: no wrapper";
              handler.trace();
              return QXmlAttributes();
          }
          //QXmlAttributes* ret = getWrapped_QXmlAttributes(wrapper);
          QXmlAttributes* ret = QXmlAttributes_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QXmlAttributes();
          }
          return *ret;
      }

      bool RJSHelper::is_QXmlAttributes(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlAttributes: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlAttributes::getIdStatic())).toBool();
      }
    
      QJSValue RJSHelper::cpp2js_QXmlStreamAttributes(RJSApi& handler, const QXmlStreamAttributes* v) {
          QJSEngine* engine = handler.getEngine();
          QXmlStreamAttributes_Wrapper* ret;

          if (v==nullptr) {
              ret = new QXmlStreamAttributes_Wrapper(handler, nullptr, false);
          }
          else {
              // wrapper takes ownership of QXmlStreamAttributes object:
              ret = new QXmlStreamAttributes_Wrapper(handler, new QXmlStreamAttributes(*v), true);
          }

          // JS: new QXmlStreamAttributes('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlStreamAttributes");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlStreamAttributes is undefined. Use QXmlStreamAttributes_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlStreamAttributes('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlStreamAttributes(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QXmlStreamAttributes(RJSApi& handler, const QXmlStreamAttributes& v) {
          QJSEngine* engine = handler.getEngine();
          // wrapper takes ownership of the QXmlStreamAttributes object:
          QXmlStreamAttributes_Wrapper* ret = new QXmlStreamAttributes_Wrapper(handler, new QXmlStreamAttributes(v), true);

          // JS: new QXmlStreamAttributes('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QXmlStreamAttributes");
          if (cl.isUndefined()) {
              qWarning() << "Class QXmlStreamAttributes is undefined. Use QXmlStreamAttributes_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(false));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("wrapper", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QXmlStreamAttributes('__GOT_WRAPPER__', wrapper);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QXmlStreamAttributes(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QXmlStreamAttributes RJSHelper::js2cpp_QXmlStreamAttributes(RJSApi& handler, const QJSValue& v) {
          /*
          QXmlStreamAttributes_Wrapper* wrapper = getWrapper<QXmlStreamAttributes_Wrapper>(v);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlStreamAttributes: no wrapper";
              handler.trace();
              Q_ASSERT(false);
              return QXmlStreamAttributes();
          }
          //return *(QXmlStreamAttributes*)wrapper->getWrappedVoid();
          QXmlStreamAttributes* ret = wrapper->getWrapped();
          if (ret==nullptr) {
              qWarning() << "js2cpp_QXmlStreamAttributes: wrapped pointer is NULL";
              return QXmlStreamAttributes();
          }
          return *ret;
          */

          QJSValue jwrapper = getWrapperQJSValue(v);
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QXmlStreamAttributes: not a QObject";
              return QXmlStreamAttributes();
          }
          QObject* obj = jwrapper.toQObject();
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QXmlStreamAttributes_ptr: no wrapper";
              handler.trace();
              return QXmlStreamAttributes();
          }
          //QXmlStreamAttributes* ret = getWrapped_QXmlStreamAttributes(wrapper);
          QXmlStreamAttributes* ret = QXmlStreamAttributes_Wrapper::getWrappedBase(wrapper);
          if (ret==nullptr) {
              return QXmlStreamAttributes();
          }
          return *ret;
      }

      bool RJSHelper::is_QXmlStreamAttributes(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QXmlStreamAttributes: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }

          return fun.call(QJSValueList() << QJSValue(RJSType_QXmlStreamAttributes::getIdStatic())).toBool();
      }
    