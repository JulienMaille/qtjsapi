
  // Automatically generated, do not edit
  
          #include "RJSHelper.h"
        
          #include "header_cpp.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qcoreapplication_wrapper.h"
        
          #include "qguiapplication_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qpixmap_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qboxlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qboxlayout_wrapper.h"
        
          #include "qgradient_wrapper.h"
        
          #include "qgradient_wrapper.h"
        
          #include "qgradient_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qiodevicebase_wrapper.h"
        
          #include "qiodevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomcharacterdata_wrapper.h"
        
          #include "qdomcharacterdata_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomcharacterdata_wrapper.h"
        
          #include "qdomtext_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qdomnode_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qpointerevent_wrapper.h"
        
          #include "qsinglepointevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qdropevent_wrapper.h"
        
          #include "qdragmoveevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qinputevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qdropevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qevent_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qfiledevice_wrapper.h"
        
          #include "qiodevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qiodevicebase_wrapper.h"
        
          #include "qiodevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
          #include "qabstractfileiconprovider_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qcombobox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qgesture_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qgesture_wrapper.h"
        
          #include "qgesture_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qgraphicseffect_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qgraphicseffect_wrapper.h"
        
          #include "qgraphicseffect_wrapper.h"
        
          #include "qgraphicseffect_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qcoreapplication_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qiodevicebase_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemdelegate_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qlistview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
          #include "qabstractprintdialog_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qpagedpaintdevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qiodevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qdialog_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qqmlengine_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qjsengine_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwindow_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractslider_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractslider_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qabstractproxymodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractspinbox_wrapper.h"
        
          #include "qabstractspinbox_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qlayoutitem_wrapper.h"
        
          #include "qlayout_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qabstractitemmodel_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qstringconverterbase_wrapper.h"
        
          #include "qstringconverter_wrapper.h"
        
          #include "qstringconverter_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qtableview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qtextedit_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qtextformat_wrapper.h"
        
          #include "qtextformat_wrapper.h"
        
          #include "qtextformat_wrapper.h"
        
          #include "qtextcharformat_wrapper.h"
        
          #include "qtextformat_wrapper.h"
        
          #include "qtextframeformat_wrapper.h"
        
          #include "qtextcharformat_wrapper.h"
        
          #include "qiodevicebase_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qabstractbutton_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qwidget_wrapper.h"
        
          #include "qframe_wrapper.h"
        
          #include "qabstractscrollarea_wrapper.h"
        
          #include "qabstractitemview_wrapper.h"
        
          #include "qtreeview_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qvalidator_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qvalidator_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qvalidator_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qpaintdevice_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qaction_wrapper.h"
        
          #include "qobject_wrapper.h"
        
          #include "qsurface_wrapper.h"
        
          #include "qxmlreader_wrapper.h"
        
          #include "qxmlcontenthandler_wrapper.h"
        
          #include "qxmlerrorhandler_wrapper.h"
        
          #include "qxmldtdhandler_wrapper.h"
        
          #include "qxmlentityresolver_wrapper.h"
        
          #include "qxmllexicalhandler_wrapper.h"
        
          #include "qxmldeclhandler_wrapper.h"
        
  // ------------------------------
  // wrapped QObject pointer types:
  // ------------------------------
  
      QJSValue RJSHelper::cpp2js_QAbstractButton(RJSApi& handler, QAbstractButton* v) {
          
            // downcast to QCheckBox:
            {
                QCheckBox* o = qobject_cast<QCheckBox*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QCheckBox(handler, o);
                }
            }
          
            // downcast to QPushButton:
            {
                QPushButton* o = qobject_cast<QPushButton*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPushButton(handler, o);
                }
            }
          
            // downcast to QRadioButton:
            {
                QRadioButton* o = qobject_cast<QRadioButton*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QRadioButton(handler, o);
                }
            }
          
            // downcast to QToolButton:
            {
                QToolButton* o = qobject_cast<QToolButton*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QToolButton(handler, o);
                }
            }
          QAbstractButton_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAbstractButton_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAbstractButton: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAbstractButton_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAbstractButton_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAbstractButton('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractButton");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractButton is undefined. Use QAbstractButton_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractButton('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractButton(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAbstractButton(RJSApi& handler, const QAbstractButton* v) {
          return RJSHelper::cpp2js_QAbstractButton(handler, const_cast<QAbstractButton*>(v));
      }

      QAbstractButton* RJSHelper::js2cpp_QAbstractButton_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractButton: not a QObject";
              return nullptr;
          }
          //QAbstractButton_Wrapper* wrapper = getWrapper<QAbstractButton_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAbstractButton_Wrapper* wrapper = qobject_cast<QAbstractButton_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractButton_Wrapper* wrapper = dynamic_cast<QAbstractButton_Wrapper*>(obj);
          //QAbstractButton_Wrapper* wrapper = (QAbstractButton_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractButton: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAbstractButton*)wrapper->getWrappedVoid();
          //return getWrapped_QAbstractButton(wrapper);
          return QAbstractButton_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractButton_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractButton: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAbstractButton_Type);
          //return fun.call().toInt()==RJSType::QAbstractButton_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractButton::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QAbstractItemDelegate(RJSApi& handler, QAbstractItemDelegate* v) {
          
            // downcast to QItemDelegate:
            {
                QItemDelegate* o = qobject_cast<QItemDelegate*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QItemDelegate(handler, o);
                }
            }
          QAbstractItemDelegate_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAbstractItemDelegate_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAbstractItemDelegate: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAbstractItemDelegate_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAbstractItemDelegate_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAbstractItemDelegate('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractItemDelegate");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractItemDelegate is undefined. Use QAbstractItemDelegate_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractItemDelegate('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractItemDelegate(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAbstractItemDelegate(RJSApi& handler, const QAbstractItemDelegate* v) {
          return RJSHelper::cpp2js_QAbstractItemDelegate(handler, const_cast<QAbstractItemDelegate*>(v));
      }

      QAbstractItemDelegate* RJSHelper::js2cpp_QAbstractItemDelegate_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractItemDelegate: not a QObject";
              return nullptr;
          }
          //QAbstractItemDelegate_Wrapper* wrapper = getWrapper<QAbstractItemDelegate_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAbstractItemDelegate_Wrapper* wrapper = qobject_cast<QAbstractItemDelegate_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractItemDelegate_Wrapper* wrapper = dynamic_cast<QAbstractItemDelegate_Wrapper*>(obj);
          //QAbstractItemDelegate_Wrapper* wrapper = (QAbstractItemDelegate_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractItemDelegate: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAbstractItemDelegate*)wrapper->getWrappedVoid();
          //return getWrapped_QAbstractItemDelegate(wrapper);
          return QAbstractItemDelegate_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractItemDelegate_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractItemDelegate: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAbstractItemDelegate_Type);
          //return fun.call().toInt()==RJSType::QAbstractItemDelegate_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractItemDelegate::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QAbstractItemModel(RJSApi& handler, QAbstractItemModel* v) {
          
            // downcast to QAbstractTableModel:
            {
                QAbstractTableModel* o = qobject_cast<QAbstractTableModel*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QAbstractTableModel(handler, o);
                }
            }
          
            // downcast to QAbstractListModel:
            {
                QAbstractListModel* o = qobject_cast<QAbstractListModel*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QAbstractListModel(handler, o);
                }
            }
          
            // downcast to QFileSystemModel:
            {
                QFileSystemModel* o = qobject_cast<QFileSystemModel*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QFileSystemModel(handler, o);
                }
            }
          
            // downcast to QStandardItemModel:
            {
                QStandardItemModel* o = qobject_cast<QStandardItemModel*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QStandardItemModel(handler, o);
                }
            }
          QAbstractItemModel_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAbstractItemModel_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAbstractItemModel: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAbstractItemModel_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAbstractItemModel_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAbstractItemModel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractItemModel");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractItemModel is undefined. Use QAbstractItemModel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractItemModel('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractItemModel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAbstractItemModel(RJSApi& handler, const QAbstractItemModel* v) {
          return RJSHelper::cpp2js_QAbstractItemModel(handler, const_cast<QAbstractItemModel*>(v));
      }

      QAbstractItemModel* RJSHelper::js2cpp_QAbstractItemModel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractItemModel: not a QObject";
              return nullptr;
          }
          //QAbstractItemModel_Wrapper* wrapper = getWrapper<QAbstractItemModel_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAbstractItemModel_Wrapper* wrapper = qobject_cast<QAbstractItemModel_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractItemModel_Wrapper* wrapper = dynamic_cast<QAbstractItemModel_Wrapper*>(obj);
          //QAbstractItemModel_Wrapper* wrapper = (QAbstractItemModel_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractItemModel: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAbstractItemModel*)wrapper->getWrappedVoid();
          //return getWrapped_QAbstractItemModel(wrapper);
          return QAbstractItemModel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractItemModel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractItemModel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAbstractItemModel_Type);
          //return fun.call().toInt()==RJSType::QAbstractItemModel_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractItemModel::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QAbstractItemView(RJSApi& handler, QAbstractItemView* v) {
          
            // downcast to QHeaderView:
            {
                QHeaderView* o = qobject_cast<QHeaderView*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QHeaderView(handler, o);
                }
            }
          
            // downcast to QListView:
            {
                QListView* o = qobject_cast<QListView*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QListView(handler, o);
                }
            }
          
            // downcast to QTableView:
            {
                QTableView* o = qobject_cast<QTableView*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QTableView(handler, o);
                }
            }
          
            // downcast to QTreeView:
            {
                QTreeView* o = qobject_cast<QTreeView*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QTreeView(handler, o);
                }
            }
          QAbstractItemView_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAbstractItemView_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAbstractItemView: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAbstractItemView_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAbstractItemView_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAbstractItemView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractItemView");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractItemView is undefined. Use QAbstractItemView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractItemView('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractItemView(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAbstractItemView(RJSApi& handler, const QAbstractItemView* v) {
          return RJSHelper::cpp2js_QAbstractItemView(handler, const_cast<QAbstractItemView*>(v));
      }

      QAbstractItemView* RJSHelper::js2cpp_QAbstractItemView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractItemView: not a QObject";
              return nullptr;
          }
          //QAbstractItemView_Wrapper* wrapper = getWrapper<QAbstractItemView_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAbstractItemView_Wrapper* wrapper = qobject_cast<QAbstractItemView_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractItemView_Wrapper* wrapper = dynamic_cast<QAbstractItemView_Wrapper*>(obj);
          //QAbstractItemView_Wrapper* wrapper = (QAbstractItemView_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractItemView: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAbstractItemView*)wrapper->getWrappedVoid();
          //return getWrapped_QAbstractItemView(wrapper);
          return QAbstractItemView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractItemView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractItemView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAbstractItemView_Type);
          //return fun.call().toInt()==RJSType::QAbstractItemView_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractItemView::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QAbstractPrintDialog(RJSApi& handler, QAbstractPrintDialog* v) {
          
            // downcast to QPrintDialog:
            {
                QPrintDialog* o = qobject_cast<QPrintDialog*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPrintDialog(handler, o);
                }
            }
          QAbstractPrintDialog_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAbstractPrintDialog_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAbstractPrintDialog: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAbstractPrintDialog_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAbstractPrintDialog_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAbstractPrintDialog('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractPrintDialog");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractPrintDialog is undefined. Use QAbstractPrintDialog_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractPrintDialog('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractPrintDialog(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAbstractPrintDialog(RJSApi& handler, const QAbstractPrintDialog* v) {
          return RJSHelper::cpp2js_QAbstractPrintDialog(handler, const_cast<QAbstractPrintDialog*>(v));
      }

      QAbstractPrintDialog* RJSHelper::js2cpp_QAbstractPrintDialog_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractPrintDialog: not a QObject";
              return nullptr;
          }
          //QAbstractPrintDialog_Wrapper* wrapper = getWrapper<QAbstractPrintDialog_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAbstractPrintDialog_Wrapper* wrapper = qobject_cast<QAbstractPrintDialog_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractPrintDialog_Wrapper* wrapper = dynamic_cast<QAbstractPrintDialog_Wrapper*>(obj);
          //QAbstractPrintDialog_Wrapper* wrapper = (QAbstractPrintDialog_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractPrintDialog: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAbstractPrintDialog*)wrapper->getWrappedVoid();
          //return getWrapped_QAbstractPrintDialog(wrapper);
          return QAbstractPrintDialog_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractPrintDialog_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractPrintDialog: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAbstractPrintDialog_Type);
          //return fun.call().toInt()==RJSType::QAbstractPrintDialog_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractPrintDialog::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QAbstractScrollArea(RJSApi& handler, QAbstractScrollArea* v) {
          
            // downcast to QAbstractItemView:
            {
                QAbstractItemView* o = qobject_cast<QAbstractItemView*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QAbstractItemView(handler, o);
                }
            }
          
            // downcast to QMdiArea:
            {
                QMdiArea* o = qobject_cast<QMdiArea*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QMdiArea(handler, o);
                }
            }
          
            // downcast to QPlainTextEdit:
            {
                QPlainTextEdit* o = qobject_cast<QPlainTextEdit*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QPlainTextEdit(handler, o);
                }
            }
          
            // downcast to QScrollArea:
            {
                QScrollArea* o = qobject_cast<QScrollArea*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QScrollArea(handler, o);
                }
            }
          
            // downcast to QTextEdit:
            {
                QTextEdit* o = qobject_cast<QTextEdit*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QTextEdit(handler, o);
                }
            }
          QAbstractScrollArea_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAbstractScrollArea_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAbstractScrollArea: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAbstractScrollArea_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAbstractScrollArea_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAbstractScrollArea('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractScrollArea");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractScrollArea is undefined. Use QAbstractScrollArea_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractScrollArea('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractScrollArea(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAbstractScrollArea(RJSApi& handler, const QAbstractScrollArea* v) {
          return RJSHelper::cpp2js_QAbstractScrollArea(handler, const_cast<QAbstractScrollArea*>(v));
      }

      QAbstractScrollArea* RJSHelper::js2cpp_QAbstractScrollArea_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractScrollArea: not a QObject";
              return nullptr;
          }
          //QAbstractScrollArea_Wrapper* wrapper = getWrapper<QAbstractScrollArea_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAbstractScrollArea_Wrapper* wrapper = qobject_cast<QAbstractScrollArea_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractScrollArea_Wrapper* wrapper = dynamic_cast<QAbstractScrollArea_Wrapper*>(obj);
          //QAbstractScrollArea_Wrapper* wrapper = (QAbstractScrollArea_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractScrollArea: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAbstractScrollArea*)wrapper->getWrappedVoid();
          //return getWrapped_QAbstractScrollArea(wrapper);
          return QAbstractScrollArea_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractScrollArea_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractScrollArea: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAbstractScrollArea_Type);
          //return fun.call().toInt()==RJSType::QAbstractScrollArea_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractScrollArea::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QAbstractSlider(RJSApi& handler, QAbstractSlider* v) {
          
            // downcast to QScrollBar:
            {
                QScrollBar* o = qobject_cast<QScrollBar*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QScrollBar(handler, o);
                }
            }
          
            // downcast to QSlider:
            {
                QSlider* o = qobject_cast<QSlider*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QSlider(handler, o);
                }
            }
          QAbstractSlider_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAbstractSlider_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAbstractSlider: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAbstractSlider_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAbstractSlider_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAbstractSlider('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractSlider");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractSlider is undefined. Use QAbstractSlider_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractSlider('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractSlider(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAbstractSlider(RJSApi& handler, const QAbstractSlider* v) {
          return RJSHelper::cpp2js_QAbstractSlider(handler, const_cast<QAbstractSlider*>(v));
      }

      QAbstractSlider* RJSHelper::js2cpp_QAbstractSlider_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractSlider: not a QObject";
              return nullptr;
          }
          //QAbstractSlider_Wrapper* wrapper = getWrapper<QAbstractSlider_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAbstractSlider_Wrapper* wrapper = qobject_cast<QAbstractSlider_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractSlider_Wrapper* wrapper = dynamic_cast<QAbstractSlider_Wrapper*>(obj);
          //QAbstractSlider_Wrapper* wrapper = (QAbstractSlider_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractSlider: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAbstractSlider*)wrapper->getWrappedVoid();
          //return getWrapped_QAbstractSlider(wrapper);
          return QAbstractSlider_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractSlider_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractSlider: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAbstractSlider_Type);
          //return fun.call().toInt()==RJSType::QAbstractSlider_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractSlider::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QAbstractSpinBox(RJSApi& handler, QAbstractSpinBox* v) {
          
            // downcast to QSpinBox:
            {
                QSpinBox* o = qobject_cast<QSpinBox*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QSpinBox(handler, o);
                }
            }
          
            // downcast to QDoubleSpinBox:
            {
                QDoubleSpinBox* o = qobject_cast<QDoubleSpinBox*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QDoubleSpinBox(handler, o);
                }
            }
          QAbstractSpinBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAbstractSpinBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAbstractSpinBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAbstractSpinBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAbstractSpinBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAbstractSpinBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAbstractSpinBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QAbstractSpinBox is undefined. Use QAbstractSpinBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAbstractSpinBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAbstractSpinBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAbstractSpinBox(RJSApi& handler, const QAbstractSpinBox* v) {
          return RJSHelper::cpp2js_QAbstractSpinBox(handler, const_cast<QAbstractSpinBox*>(v));
      }

      QAbstractSpinBox* RJSHelper::js2cpp_QAbstractSpinBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAbstractSpinBox: not a QObject";
              return nullptr;
          }
          //QAbstractSpinBox_Wrapper* wrapper = getWrapper<QAbstractSpinBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAbstractSpinBox_Wrapper* wrapper = qobject_cast<QAbstractSpinBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAbstractSpinBox_Wrapper* wrapper = dynamic_cast<QAbstractSpinBox_Wrapper*>(obj);
          //QAbstractSpinBox_Wrapper* wrapper = (QAbstractSpinBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAbstractSpinBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAbstractSpinBox*)wrapper->getWrappedVoid();
          //return getWrapped_QAbstractSpinBox(wrapper);
          return QAbstractSpinBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAbstractSpinBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAbstractSpinBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAbstractSpinBox_Type);
          //return fun.call().toInt()==RJSType::QAbstractSpinBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAbstractSpinBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QAction(RJSApi& handler, QAction* v) {
          
            // downcast to QWidgetAction:
            {
                QWidgetAction* o = qobject_cast<QWidgetAction*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QWidgetAction(handler, o);
                }
            }
          
            // downcast to types derrived from QAction but defined in other modules:
            for (int i=0; i<downcasters_QAction.length(); i++) {
                QJSValue dc = downcasters_QAction[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QAction_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QAction_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QAction: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QAction_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QAction_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QAction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QAction");
          if (cl.isUndefined()) {
              qWarning() << "Class QAction is undefined. Use QAction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QAction('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QAction(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QAction(RJSApi& handler, const QAction* v) {
          return RJSHelper::cpp2js_QAction(handler, const_cast<QAction*>(v));
      }

      QAction* RJSHelper::js2cpp_QAction_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QAction: not a QObject";
              return nullptr;
          }
          //QAction_Wrapper* wrapper = getWrapper<QAction_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QAction_Wrapper* wrapper = qobject_cast<QAction_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QAction_Wrapper* wrapper = dynamic_cast<QAction_Wrapper*>(obj);
          //QAction_Wrapper* wrapper = (QAction_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QAction: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QAction*)wrapper->getWrappedVoid();
          //return getWrapped_QAction(wrapper);
          return QAction_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QAction_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QAction: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QAction_Type);
          //return fun.call().toInt()==RJSType::QAction_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QAction::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QActionGroup(RJSApi& handler, QActionGroup* v) {
          QActionGroup_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QActionGroup_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QActionGroup: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QActionGroup_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QActionGroup_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QActionGroup('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QActionGroup");
          if (cl.isUndefined()) {
              qWarning() << "Class QActionGroup is undefined. Use QActionGroup_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QActionGroup('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QActionGroup(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QActionGroup(RJSApi& handler, const QActionGroup* v) {
          return RJSHelper::cpp2js_QActionGroup(handler, const_cast<QActionGroup*>(v));
      }

      QActionGroup* RJSHelper::js2cpp_QActionGroup_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QActionGroup: not a QObject";
              return nullptr;
          }
          //QActionGroup_Wrapper* wrapper = getWrapper<QActionGroup_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QActionGroup_Wrapper* wrapper = qobject_cast<QActionGroup_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QActionGroup_Wrapper* wrapper = dynamic_cast<QActionGroup_Wrapper*>(obj);
          //QActionGroup_Wrapper* wrapper = (QActionGroup_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QActionGroup: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QActionGroup*)wrapper->getWrappedVoid();
          //return getWrapped_QActionGroup(wrapper);
          return QActionGroup_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QActionGroup_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QActionGroup: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QActionGroup_Type);
          //return fun.call().toInt()==RJSType::QActionGroup_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QActionGroup::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QApplication(RJSApi& handler, QApplication* v) {
          
            // downcast to types derrived from QApplication but defined in other modules:
            for (int i=0; i<downcasters_QApplication.length(); i++) {
                QJSValue dc = downcasters_QApplication[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QApplication_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QApplication_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QApplication: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QApplication_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QApplication_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QApplication('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QApplication");
          if (cl.isUndefined()) {
              qWarning() << "Class QApplication is undefined. Use QApplication_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QApplication('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QApplication(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QApplication(RJSApi& handler, const QApplication* v) {
          return RJSHelper::cpp2js_QApplication(handler, const_cast<QApplication*>(v));
      }

      QApplication* RJSHelper::js2cpp_QApplication_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QApplication: not a QObject";
              return nullptr;
          }
          //QApplication_Wrapper* wrapper = getWrapper<QApplication_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QApplication_Wrapper* wrapper = qobject_cast<QApplication_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QApplication_Wrapper* wrapper = dynamic_cast<QApplication_Wrapper*>(obj);
          //QApplication_Wrapper* wrapper = (QApplication_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QApplication: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QApplication*)wrapper->getWrappedVoid();
          //return getWrapped_QApplication(wrapper);
          return QApplication_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QApplication_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QApplication: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QApplication_Type);
          //return fun.call().toInt()==RJSType::QApplication_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QApplication::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QBoxLayout(RJSApi& handler, QBoxLayout* v) {
          
            // downcast to QHBoxLayout:
            {
                QHBoxLayout* o = qobject_cast<QHBoxLayout*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QHBoxLayout(handler, o);
                }
            }
          
            // downcast to QVBoxLayout:
            {
                QVBoxLayout* o = qobject_cast<QVBoxLayout*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QVBoxLayout(handler, o);
                }
            }
          QBoxLayout_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QBoxLayout_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QBoxLayout: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QBoxLayout_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QBoxLayout_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QBoxLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QBoxLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QBoxLayout is undefined. Use QBoxLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QBoxLayout('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QBoxLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QBoxLayout(RJSApi& handler, const QBoxLayout* v) {
          return RJSHelper::cpp2js_QBoxLayout(handler, const_cast<QBoxLayout*>(v));
      }

      QBoxLayout* RJSHelper::js2cpp_QBoxLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QBoxLayout: not a QObject";
              return nullptr;
          }
          //QBoxLayout_Wrapper* wrapper = getWrapper<QBoxLayout_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QBoxLayout_Wrapper* wrapper = qobject_cast<QBoxLayout_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QBoxLayout_Wrapper* wrapper = dynamic_cast<QBoxLayout_Wrapper*>(obj);
          //QBoxLayout_Wrapper* wrapper = (QBoxLayout_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QBoxLayout: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QBoxLayout*)wrapper->getWrappedVoid();
          //return getWrapped_QBoxLayout(wrapper);
          return QBoxLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QBoxLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QBoxLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QBoxLayout_Type);
          //return fun.call().toInt()==RJSType::QBoxLayout_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QBoxLayout::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QBuffer(RJSApi& handler, QBuffer* v) {
          QBuffer_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QBuffer_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QBuffer: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QBuffer_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QBuffer_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QBuffer('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QBuffer");
          if (cl.isUndefined()) {
              qWarning() << "Class QBuffer is undefined. Use QBuffer_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QBuffer('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QBuffer(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QBuffer(RJSApi& handler, const QBuffer* v) {
          return RJSHelper::cpp2js_QBuffer(handler, const_cast<QBuffer*>(v));
      }

      QBuffer* RJSHelper::js2cpp_QBuffer_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QBuffer: not a QObject";
              return nullptr;
          }
          //QBuffer_Wrapper* wrapper = getWrapper<QBuffer_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QBuffer_Wrapper* wrapper = qobject_cast<QBuffer_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QBuffer_Wrapper* wrapper = dynamic_cast<QBuffer_Wrapper*>(obj);
          //QBuffer_Wrapper* wrapper = (QBuffer_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QBuffer: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QBuffer*)wrapper->getWrappedVoid();
          //return getWrapped_QBuffer(wrapper);
          return QBuffer_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QBuffer_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QBuffer: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QBuffer_Type);
          //return fun.call().toInt()==RJSType::QBuffer_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QBuffer::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QButtonGroup(RJSApi& handler, QButtonGroup* v) {
          QButtonGroup_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QButtonGroup_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QButtonGroup: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QButtonGroup_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QButtonGroup_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QButtonGroup('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QButtonGroup");
          if (cl.isUndefined()) {
              qWarning() << "Class QButtonGroup is undefined. Use QButtonGroup_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QButtonGroup('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QButtonGroup(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QButtonGroup(RJSApi& handler, const QButtonGroup* v) {
          return RJSHelper::cpp2js_QButtonGroup(handler, const_cast<QButtonGroup*>(v));
      }

      QButtonGroup* RJSHelper::js2cpp_QButtonGroup_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QButtonGroup: not a QObject";
              return nullptr;
          }
          //QButtonGroup_Wrapper* wrapper = getWrapper<QButtonGroup_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QButtonGroup_Wrapper* wrapper = qobject_cast<QButtonGroup_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QButtonGroup_Wrapper* wrapper = dynamic_cast<QButtonGroup_Wrapper*>(obj);
          //QButtonGroup_Wrapper* wrapper = (QButtonGroup_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QButtonGroup: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QButtonGroup*)wrapper->getWrappedVoid();
          //return getWrapped_QButtonGroup(wrapper);
          return QButtonGroup_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QButtonGroup_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QButtonGroup: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QButtonGroup_Type);
          //return fun.call().toInt()==RJSType::QButtonGroup_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QButtonGroup::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QCheckBox(RJSApi& handler, QCheckBox* v) {
          QCheckBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QCheckBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QCheckBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QCheckBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QCheckBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QCheckBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QCheckBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QCheckBox is undefined. Use QCheckBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QCheckBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QCheckBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QCheckBox(RJSApi& handler, const QCheckBox* v) {
          return RJSHelper::cpp2js_QCheckBox(handler, const_cast<QCheckBox*>(v));
      }

      QCheckBox* RJSHelper::js2cpp_QCheckBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QCheckBox: not a QObject";
              return nullptr;
          }
          //QCheckBox_Wrapper* wrapper = getWrapper<QCheckBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QCheckBox_Wrapper* wrapper = qobject_cast<QCheckBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QCheckBox_Wrapper* wrapper = dynamic_cast<QCheckBox_Wrapper*>(obj);
          //QCheckBox_Wrapper* wrapper = (QCheckBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QCheckBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QCheckBox*)wrapper->getWrappedVoid();
          //return getWrapped_QCheckBox(wrapper);
          return QCheckBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QCheckBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QCheckBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QCheckBox_Type);
          //return fun.call().toInt()==RJSType::QCheckBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QCheckBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QClipboard(RJSApi& handler, QClipboard* v) {
          QClipboard_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QClipboard_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QClipboard: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QClipboard_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QClipboard_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QClipboard('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QClipboard");
          if (cl.isUndefined()) {
              qWarning() << "Class QClipboard is undefined. Use QClipboard_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QClipboard('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QClipboard(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QClipboard(RJSApi& handler, const QClipboard* v) {
          return RJSHelper::cpp2js_QClipboard(handler, const_cast<QClipboard*>(v));
      }

      QClipboard* RJSHelper::js2cpp_QClipboard_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QClipboard: not a QObject";
              return nullptr;
          }
          //QClipboard_Wrapper* wrapper = getWrapper<QClipboard_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QClipboard_Wrapper* wrapper = qobject_cast<QClipboard_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QClipboard_Wrapper* wrapper = dynamic_cast<QClipboard_Wrapper*>(obj);
          //QClipboard_Wrapper* wrapper = (QClipboard_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QClipboard: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QClipboard*)wrapper->getWrappedVoid();
          //return getWrapped_QClipboard(wrapper);
          return QClipboard_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QClipboard_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QClipboard: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QClipboard_Type);
          //return fun.call().toInt()==RJSType::QClipboard_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QClipboard::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QColorDialog(RJSApi& handler, QColorDialog* v) {
          QColorDialog_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QColorDialog_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QColorDialog: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QColorDialog_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QColorDialog_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QColorDialog('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QColorDialog");
          if (cl.isUndefined()) {
              qWarning() << "Class QColorDialog is undefined. Use QColorDialog_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QColorDialog('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QColorDialog(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QColorDialog(RJSApi& handler, const QColorDialog* v) {
          return RJSHelper::cpp2js_QColorDialog(handler, const_cast<QColorDialog*>(v));
      }

      QColorDialog* RJSHelper::js2cpp_QColorDialog_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QColorDialog: not a QObject";
              return nullptr;
          }
          //QColorDialog_Wrapper* wrapper = getWrapper<QColorDialog_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QColorDialog_Wrapper* wrapper = qobject_cast<QColorDialog_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QColorDialog_Wrapper* wrapper = dynamic_cast<QColorDialog_Wrapper*>(obj);
          //QColorDialog_Wrapper* wrapper = (QColorDialog_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QColorDialog: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QColorDialog*)wrapper->getWrappedVoid();
          //return getWrapped_QColorDialog(wrapper);
          return QColorDialog_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QColorDialog_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QColorDialog: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QColorDialog_Type);
          //return fun.call().toInt()==RJSType::QColorDialog_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QColorDialog::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QComboBox(RJSApi& handler, QComboBox* v) {
          
            // downcast to QFontComboBox:
            {
                QFontComboBox* o = qobject_cast<QFontComboBox*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QFontComboBox(handler, o);
                }
            }
          
            // downcast to types derrived from QComboBox but defined in other modules:
            for (int i=0; i<downcasters_QComboBox.length(); i++) {
                QJSValue dc = downcasters_QComboBox[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QComboBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QComboBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QComboBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QComboBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QComboBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QComboBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QComboBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QComboBox is undefined. Use QComboBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QComboBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QComboBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QComboBox(RJSApi& handler, const QComboBox* v) {
          return RJSHelper::cpp2js_QComboBox(handler, const_cast<QComboBox*>(v));
      }

      QComboBox* RJSHelper::js2cpp_QComboBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QComboBox: not a QObject";
              return nullptr;
          }
          //QComboBox_Wrapper* wrapper = getWrapper<QComboBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QComboBox_Wrapper* wrapper = qobject_cast<QComboBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QComboBox_Wrapper* wrapper = dynamic_cast<QComboBox_Wrapper*>(obj);
          //QComboBox_Wrapper* wrapper = (QComboBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QComboBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QComboBox*)wrapper->getWrappedVoid();
          //return getWrapped_QComboBox(wrapper);
          return QComboBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QComboBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QComboBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QComboBox_Type);
          //return fun.call().toInt()==RJSType::QComboBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QComboBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QCoreApplication(RJSApi& handler, QCoreApplication* v) {
          
            // downcast to QGuiApplication:
            {
                QGuiApplication* o = qobject_cast<QGuiApplication*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QGuiApplication(handler, o);
                }
            }
          QCoreApplication_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QCoreApplication_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QCoreApplication: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QCoreApplication_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QCoreApplication_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QCoreApplication('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QCoreApplication");
          if (cl.isUndefined()) {
              qWarning() << "Class QCoreApplication is undefined. Use QCoreApplication_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QCoreApplication('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QCoreApplication(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QCoreApplication(RJSApi& handler, const QCoreApplication* v) {
          return RJSHelper::cpp2js_QCoreApplication(handler, const_cast<QCoreApplication*>(v));
      }

      QCoreApplication* RJSHelper::js2cpp_QCoreApplication_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QCoreApplication: not a QObject";
              return nullptr;
          }
          //QCoreApplication_Wrapper* wrapper = getWrapper<QCoreApplication_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QCoreApplication_Wrapper* wrapper = qobject_cast<QCoreApplication_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QCoreApplication_Wrapper* wrapper = dynamic_cast<QCoreApplication_Wrapper*>(obj);
          //QCoreApplication_Wrapper* wrapper = (QCoreApplication_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QCoreApplication: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QCoreApplication*)wrapper->getWrappedVoid();
          //return getWrapped_QCoreApplication(wrapper);
          return QCoreApplication_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QCoreApplication_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QCoreApplication: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QCoreApplication_Type);
          //return fun.call().toInt()==RJSType::QCoreApplication_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QCoreApplication::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QDialog(RJSApi& handler, QDialog* v) {
          
            // downcast to QAbstractPrintDialog:
            {
                QAbstractPrintDialog* o = qobject_cast<QAbstractPrintDialog*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QAbstractPrintDialog(handler, o);
                }
            }
          
            // downcast to QColorDialog:
            {
                QColorDialog* o = qobject_cast<QColorDialog*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QColorDialog(handler, o);
                }
            }
          
            // downcast to QFileDialog:
            {
                QFileDialog* o = qobject_cast<QFileDialog*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QFileDialog(handler, o);
                }
            }
          
            // downcast to QMessageBox:
            {
                QMessageBox* o = qobject_cast<QMessageBox*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QMessageBox(handler, o);
                }
            }
          
            // downcast to QProgressDialog:
            {
                QProgressDialog* o = qobject_cast<QProgressDialog*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QProgressDialog(handler, o);
                }
            }
          QDialog_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QDialog_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QDialog: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QDialog_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QDialog_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QDialog('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDialog");
          if (cl.isUndefined()) {
              qWarning() << "Class QDialog is undefined. Use QDialog_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDialog('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDialog(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDialog(RJSApi& handler, const QDialog* v) {
          return RJSHelper::cpp2js_QDialog(handler, const_cast<QDialog*>(v));
      }

      QDialog* RJSHelper::js2cpp_QDialog_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDialog: not a QObject";
              return nullptr;
          }
          //QDialog_Wrapper* wrapper = getWrapper<QDialog_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QDialog_Wrapper* wrapper = qobject_cast<QDialog_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDialog_Wrapper* wrapper = dynamic_cast<QDialog_Wrapper*>(obj);
          //QDialog_Wrapper* wrapper = (QDialog_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDialog: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QDialog*)wrapper->getWrappedVoid();
          //return getWrapped_QDialog(wrapper);
          return QDialog_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDialog_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDialog: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QDialog_Type);
          //return fun.call().toInt()==RJSType::QDialog_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QDialog::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QDialogButtonBox(RJSApi& handler, QDialogButtonBox* v) {
          QDialogButtonBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QDialogButtonBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QDialogButtonBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QDialogButtonBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QDialogButtonBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QDialogButtonBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDialogButtonBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QDialogButtonBox is undefined. Use QDialogButtonBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDialogButtonBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDialogButtonBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDialogButtonBox(RJSApi& handler, const QDialogButtonBox* v) {
          return RJSHelper::cpp2js_QDialogButtonBox(handler, const_cast<QDialogButtonBox*>(v));
      }

      QDialogButtonBox* RJSHelper::js2cpp_QDialogButtonBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDialogButtonBox: not a QObject";
              return nullptr;
          }
          //QDialogButtonBox_Wrapper* wrapper = getWrapper<QDialogButtonBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QDialogButtonBox_Wrapper* wrapper = qobject_cast<QDialogButtonBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDialogButtonBox_Wrapper* wrapper = dynamic_cast<QDialogButtonBox_Wrapper*>(obj);
          //QDialogButtonBox_Wrapper* wrapper = (QDialogButtonBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDialogButtonBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QDialogButtonBox*)wrapper->getWrappedVoid();
          //return getWrapped_QDialogButtonBox(wrapper);
          return QDialogButtonBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDialogButtonBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDialogButtonBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QDialogButtonBox_Type);
          //return fun.call().toInt()==RJSType::QDialogButtonBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QDialogButtonBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QDockWidget(RJSApi& handler, QDockWidget* v) {
          
            // downcast to types derrived from QDockWidget but defined in other modules:
            for (int i=0; i<downcasters_QDockWidget.length(); i++) {
                QJSValue dc = downcasters_QDockWidget[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QDockWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QDockWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QDockWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QDockWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QDockWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QDockWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDockWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class QDockWidget is undefined. Use QDockWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDockWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDockWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDockWidget(RJSApi& handler, const QDockWidget* v) {
          return RJSHelper::cpp2js_QDockWidget(handler, const_cast<QDockWidget*>(v));
      }

      QDockWidget* RJSHelper::js2cpp_QDockWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDockWidget: not a QObject";
              return nullptr;
          }
          //QDockWidget_Wrapper* wrapper = getWrapper<QDockWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QDockWidget_Wrapper* wrapper = qobject_cast<QDockWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDockWidget_Wrapper* wrapper = dynamic_cast<QDockWidget_Wrapper*>(obj);
          //QDockWidget_Wrapper* wrapper = (QDockWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDockWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QDockWidget*)wrapper->getWrappedVoid();
          //return getWrapped_QDockWidget(wrapper);
          return QDockWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDockWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDockWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QDockWidget_Type);
          //return fun.call().toInt()==RJSType::QDockWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QDockWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QDoubleSpinBox(RJSApi& handler, QDoubleSpinBox* v) {
          QDoubleSpinBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QDoubleSpinBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QDoubleSpinBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QDoubleSpinBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QDoubleSpinBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QDoubleSpinBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDoubleSpinBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QDoubleSpinBox is undefined. Use QDoubleSpinBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDoubleSpinBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDoubleSpinBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDoubleSpinBox(RJSApi& handler, const QDoubleSpinBox* v) {
          return RJSHelper::cpp2js_QDoubleSpinBox(handler, const_cast<QDoubleSpinBox*>(v));
      }

      QDoubleSpinBox* RJSHelper::js2cpp_QDoubleSpinBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDoubleSpinBox: not a QObject";
              return nullptr;
          }
          //QDoubleSpinBox_Wrapper* wrapper = getWrapper<QDoubleSpinBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QDoubleSpinBox_Wrapper* wrapper = qobject_cast<QDoubleSpinBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDoubleSpinBox_Wrapper* wrapper = dynamic_cast<QDoubleSpinBox_Wrapper*>(obj);
          //QDoubleSpinBox_Wrapper* wrapper = (QDoubleSpinBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDoubleSpinBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QDoubleSpinBox*)wrapper->getWrappedVoid();
          //return getWrapped_QDoubleSpinBox(wrapper);
          return QDoubleSpinBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDoubleSpinBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDoubleSpinBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QDoubleSpinBox_Type);
          //return fun.call().toInt()==RJSType::QDoubleSpinBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QDoubleSpinBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QDoubleValidator(RJSApi& handler, QDoubleValidator* v) {
          QDoubleValidator_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QDoubleValidator_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QDoubleValidator: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QDoubleValidator_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QDoubleValidator_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QDoubleValidator('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDoubleValidator");
          if (cl.isUndefined()) {
              qWarning() << "Class QDoubleValidator is undefined. Use QDoubleValidator_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDoubleValidator('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDoubleValidator(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDoubleValidator(RJSApi& handler, const QDoubleValidator* v) {
          return RJSHelper::cpp2js_QDoubleValidator(handler, const_cast<QDoubleValidator*>(v));
      }

      QDoubleValidator* RJSHelper::js2cpp_QDoubleValidator_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDoubleValidator: not a QObject";
              return nullptr;
          }
          //QDoubleValidator_Wrapper* wrapper = getWrapper<QDoubleValidator_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QDoubleValidator_Wrapper* wrapper = qobject_cast<QDoubleValidator_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDoubleValidator_Wrapper* wrapper = dynamic_cast<QDoubleValidator_Wrapper*>(obj);
          //QDoubleValidator_Wrapper* wrapper = (QDoubleValidator_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDoubleValidator: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QDoubleValidator*)wrapper->getWrappedVoid();
          //return getWrapped_QDoubleValidator(wrapper);
          return QDoubleValidator_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDoubleValidator_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDoubleValidator: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QDoubleValidator_Type);
          //return fun.call().toInt()==RJSType::QDoubleValidator_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QDoubleValidator::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QDrag(RJSApi& handler, QDrag* v) {
          QDrag_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QDrag_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QDrag: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QDrag_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QDrag_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QDrag('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QDrag");
          if (cl.isUndefined()) {
              qWarning() << "Class QDrag is undefined. Use QDrag_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QDrag('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QDrag(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QDrag(RJSApi& handler, const QDrag* v) {
          return RJSHelper::cpp2js_QDrag(handler, const_cast<QDrag*>(v));
      }

      QDrag* RJSHelper::js2cpp_QDrag_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QDrag: not a QObject";
              return nullptr;
          }
          //QDrag_Wrapper* wrapper = getWrapper<QDrag_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QDrag_Wrapper* wrapper = qobject_cast<QDrag_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QDrag_Wrapper* wrapper = dynamic_cast<QDrag_Wrapper*>(obj);
          //QDrag_Wrapper* wrapper = (QDrag_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QDrag: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QDrag*)wrapper->getWrappedVoid();
          //return getWrapped_QDrag(wrapper);
          return QDrag_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QDrag_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QDrag: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QDrag_Type);
          //return fun.call().toInt()==RJSType::QDrag_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QDrag::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QEventLoop(RJSApi& handler, QEventLoop* v) {
          QEventLoop_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QEventLoop_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QEventLoop: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QEventLoop_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QEventLoop_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QEventLoop('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QEventLoop");
          if (cl.isUndefined()) {
              qWarning() << "Class QEventLoop is undefined. Use QEventLoop_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QEventLoop('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QEventLoop(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QEventLoop(RJSApi& handler, const QEventLoop* v) {
          return RJSHelper::cpp2js_QEventLoop(handler, const_cast<QEventLoop*>(v));
      }

      QEventLoop* RJSHelper::js2cpp_QEventLoop_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QEventLoop: not a QObject";
              return nullptr;
          }
          //QEventLoop_Wrapper* wrapper = getWrapper<QEventLoop_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QEventLoop_Wrapper* wrapper = qobject_cast<QEventLoop_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QEventLoop_Wrapper* wrapper = dynamic_cast<QEventLoop_Wrapper*>(obj);
          //QEventLoop_Wrapper* wrapper = (QEventLoop_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QEventLoop: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QEventLoop*)wrapper->getWrappedVoid();
          //return getWrapped_QEventLoop(wrapper);
          return QEventLoop_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QEventLoop_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QEventLoop: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QEventLoop_Type);
          //return fun.call().toInt()==RJSType::QEventLoop_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QEventLoop::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QFile(RJSApi& handler, QFile* v) {
          QFile_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QFile_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QFile: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QFile_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QFile_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QFile('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFile");
          if (cl.isUndefined()) {
              qWarning() << "Class QFile is undefined. Use QFile_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFile('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFile(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFile(RJSApi& handler, const QFile* v) {
          return RJSHelper::cpp2js_QFile(handler, const_cast<QFile*>(v));
      }

      QFile* RJSHelper::js2cpp_QFile_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFile: not a QObject";
              return nullptr;
          }
          //QFile_Wrapper* wrapper = getWrapper<QFile_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QFile_Wrapper* wrapper = qobject_cast<QFile_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFile_Wrapper* wrapper = dynamic_cast<QFile_Wrapper*>(obj);
          //QFile_Wrapper* wrapper = (QFile_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFile: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QFile*)wrapper->getWrappedVoid();
          //return getWrapped_QFile(wrapper);
          return QFile_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFile_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFile: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QFile_Type);
          //return fun.call().toInt()==RJSType::QFile_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QFile::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QFileDevice(RJSApi& handler, QFileDevice* v) {
          QFileDevice_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QFileDevice_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QFileDevice: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QFileDevice_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QFileDevice_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QFileDevice('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFileDevice");
          if (cl.isUndefined()) {
              qWarning() << "Class QFileDevice is undefined. Use QFileDevice_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFileDevice('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFileDevice(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFileDevice(RJSApi& handler, const QFileDevice* v) {
          return RJSHelper::cpp2js_QFileDevice(handler, const_cast<QFileDevice*>(v));
      }

      QFileDevice* RJSHelper::js2cpp_QFileDevice_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFileDevice: not a QObject";
              return nullptr;
          }
          //QFileDevice_Wrapper* wrapper = getWrapper<QFileDevice_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QFileDevice_Wrapper* wrapper = qobject_cast<QFileDevice_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFileDevice_Wrapper* wrapper = dynamic_cast<QFileDevice_Wrapper*>(obj);
          //QFileDevice_Wrapper* wrapper = (QFileDevice_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFileDevice: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QFileDevice*)wrapper->getWrappedVoid();
          //return getWrapped_QFileDevice(wrapper);
          return QFileDevice_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFileDevice_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFileDevice: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QFileDevice_Type);
          //return fun.call().toInt()==RJSType::QFileDevice_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QFileDevice::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QFileDialog(RJSApi& handler, QFileDialog* v) {
          QFileDialog_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QFileDialog_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QFileDialog: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QFileDialog_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QFileDialog_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QFileDialog('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFileDialog");
          if (cl.isUndefined()) {
              qWarning() << "Class QFileDialog is undefined. Use QFileDialog_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFileDialog('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFileDialog(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFileDialog(RJSApi& handler, const QFileDialog* v) {
          return RJSHelper::cpp2js_QFileDialog(handler, const_cast<QFileDialog*>(v));
      }

      QFileDialog* RJSHelper::js2cpp_QFileDialog_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFileDialog: not a QObject";
              return nullptr;
          }
          //QFileDialog_Wrapper* wrapper = getWrapper<QFileDialog_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QFileDialog_Wrapper* wrapper = qobject_cast<QFileDialog_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFileDialog_Wrapper* wrapper = dynamic_cast<QFileDialog_Wrapper*>(obj);
          //QFileDialog_Wrapper* wrapper = (QFileDialog_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFileDialog: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QFileDialog*)wrapper->getWrappedVoid();
          //return getWrapped_QFileDialog(wrapper);
          return QFileDialog_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFileDialog_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFileDialog: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QFileDialog_Type);
          //return fun.call().toInt()==RJSType::QFileDialog_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QFileDialog::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QFileSystemModel(RJSApi& handler, QFileSystemModel* v) {
          
            // downcast to types derrived from QFileSystemModel but defined in other modules:
            for (int i=0; i<downcasters_QFileSystemModel.length(); i++) {
                QJSValue dc = downcasters_QFileSystemModel[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QFileSystemModel_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QFileSystemModel_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QFileSystemModel: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QFileSystemModel_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QFileSystemModel_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QFileSystemModel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFileSystemModel");
          if (cl.isUndefined()) {
              qWarning() << "Class QFileSystemModel is undefined. Use QFileSystemModel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFileSystemModel('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFileSystemModel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFileSystemModel(RJSApi& handler, const QFileSystemModel* v) {
          return RJSHelper::cpp2js_QFileSystemModel(handler, const_cast<QFileSystemModel*>(v));
      }

      QFileSystemModel* RJSHelper::js2cpp_QFileSystemModel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFileSystemModel: not a QObject";
              return nullptr;
          }
          //QFileSystemModel_Wrapper* wrapper = getWrapper<QFileSystemModel_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QFileSystemModel_Wrapper* wrapper = qobject_cast<QFileSystemModel_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFileSystemModel_Wrapper* wrapper = dynamic_cast<QFileSystemModel_Wrapper*>(obj);
          //QFileSystemModel_Wrapper* wrapper = (QFileSystemModel_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFileSystemModel: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QFileSystemModel*)wrapper->getWrappedVoid();
          //return getWrapped_QFileSystemModel(wrapper);
          return QFileSystemModel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFileSystemModel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFileSystemModel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QFileSystemModel_Type);
          //return fun.call().toInt()==RJSType::QFileSystemModel_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QFileSystemModel::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QFileSystemWatcher(RJSApi& handler, QFileSystemWatcher* v) {
          QFileSystemWatcher_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QFileSystemWatcher_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QFileSystemWatcher: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QFileSystemWatcher_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QFileSystemWatcher_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QFileSystemWatcher('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFileSystemWatcher");
          if (cl.isUndefined()) {
              qWarning() << "Class QFileSystemWatcher is undefined. Use QFileSystemWatcher_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFileSystemWatcher('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFileSystemWatcher(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFileSystemWatcher(RJSApi& handler, const QFileSystemWatcher* v) {
          return RJSHelper::cpp2js_QFileSystemWatcher(handler, const_cast<QFileSystemWatcher*>(v));
      }

      QFileSystemWatcher* RJSHelper::js2cpp_QFileSystemWatcher_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFileSystemWatcher: not a QObject";
              return nullptr;
          }
          //QFileSystemWatcher_Wrapper* wrapper = getWrapper<QFileSystemWatcher_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QFileSystemWatcher_Wrapper* wrapper = qobject_cast<QFileSystemWatcher_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFileSystemWatcher_Wrapper* wrapper = dynamic_cast<QFileSystemWatcher_Wrapper*>(obj);
          //QFileSystemWatcher_Wrapper* wrapper = (QFileSystemWatcher_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFileSystemWatcher: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QFileSystemWatcher*)wrapper->getWrappedVoid();
          //return getWrapped_QFileSystemWatcher(wrapper);
          return QFileSystemWatcher_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFileSystemWatcher_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFileSystemWatcher: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QFileSystemWatcher_Type);
          //return fun.call().toInt()==RJSType::QFileSystemWatcher_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QFileSystemWatcher::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QFontComboBox(RJSApi& handler, QFontComboBox* v) {
          QFontComboBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QFontComboBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QFontComboBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QFontComboBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QFontComboBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QFontComboBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFontComboBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QFontComboBox is undefined. Use QFontComboBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFontComboBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFontComboBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFontComboBox(RJSApi& handler, const QFontComboBox* v) {
          return RJSHelper::cpp2js_QFontComboBox(handler, const_cast<QFontComboBox*>(v));
      }

      QFontComboBox* RJSHelper::js2cpp_QFontComboBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFontComboBox: not a QObject";
              return nullptr;
          }
          //QFontComboBox_Wrapper* wrapper = getWrapper<QFontComboBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QFontComboBox_Wrapper* wrapper = qobject_cast<QFontComboBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFontComboBox_Wrapper* wrapper = dynamic_cast<QFontComboBox_Wrapper*>(obj);
          //QFontComboBox_Wrapper* wrapper = (QFontComboBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFontComboBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QFontComboBox*)wrapper->getWrappedVoid();
          //return getWrapped_QFontComboBox(wrapper);
          return QFontComboBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFontComboBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFontComboBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QFontComboBox_Type);
          //return fun.call().toInt()==RJSType::QFontComboBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QFontComboBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QFormLayout(RJSApi& handler, QFormLayout* v) {
          QFormLayout_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QFormLayout_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QFormLayout: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QFormLayout_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QFormLayout_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QFormLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFormLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QFormLayout is undefined. Use QFormLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFormLayout('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFormLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFormLayout(RJSApi& handler, const QFormLayout* v) {
          return RJSHelper::cpp2js_QFormLayout(handler, const_cast<QFormLayout*>(v));
      }

      QFormLayout* RJSHelper::js2cpp_QFormLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFormLayout: not a QObject";
              return nullptr;
          }
          //QFormLayout_Wrapper* wrapper = getWrapper<QFormLayout_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QFormLayout_Wrapper* wrapper = qobject_cast<QFormLayout_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFormLayout_Wrapper* wrapper = dynamic_cast<QFormLayout_Wrapper*>(obj);
          //QFormLayout_Wrapper* wrapper = (QFormLayout_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFormLayout: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QFormLayout*)wrapper->getWrappedVoid();
          //return getWrapped_QFormLayout(wrapper);
          return QFormLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFormLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFormLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QFormLayout_Type);
          //return fun.call().toInt()==RJSType::QFormLayout_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QFormLayout::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QFrame(RJSApi& handler, QFrame* v) {
          
            // downcast to QAbstractScrollArea:
            {
                QAbstractScrollArea* o = qobject_cast<QAbstractScrollArea*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QAbstractScrollArea(handler, o);
                }
            }
          
            // downcast to QLabel:
            {
                QLabel* o = qobject_cast<QLabel*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QLabel(handler, o);
                }
            }
          
            // downcast to QSplitter:
            {
                QSplitter* o = qobject_cast<QSplitter*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QSplitter(handler, o);
                }
            }
          
            // downcast to QStackedWidget:
            {
                QStackedWidget* o = qobject_cast<QStackedWidget*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QStackedWidget(handler, o);
                }
            }
          
            // downcast to types derrived from QFrame but defined in other modules:
            for (int i=0; i<downcasters_QFrame.length(); i++) {
                QJSValue dc = downcasters_QFrame[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QFrame_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QFrame_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QFrame: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QFrame_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QFrame_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QFrame('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QFrame");
          if (cl.isUndefined()) {
              qWarning() << "Class QFrame is undefined. Use QFrame_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QFrame('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QFrame(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QFrame(RJSApi& handler, const QFrame* v) {
          return RJSHelper::cpp2js_QFrame(handler, const_cast<QFrame*>(v));
      }

      QFrame* RJSHelper::js2cpp_QFrame_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QFrame: not a QObject";
              return nullptr;
          }
          //QFrame_Wrapper* wrapper = getWrapper<QFrame_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QFrame_Wrapper* wrapper = qobject_cast<QFrame_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QFrame_Wrapper* wrapper = dynamic_cast<QFrame_Wrapper*>(obj);
          //QFrame_Wrapper* wrapper = (QFrame_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QFrame: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QFrame*)wrapper->getWrappedVoid();
          //return getWrapped_QFrame(wrapper);
          return QFrame_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QFrame_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QFrame: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QFrame_Type);
          //return fun.call().toInt()==RJSType::QFrame_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QFrame::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QGraphicsBlurEffect(RJSApi& handler, QGraphicsBlurEffect* v) {
          QGraphicsBlurEffect_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QGraphicsBlurEffect_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QGraphicsBlurEffect: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QGraphicsBlurEffect_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QGraphicsBlurEffect_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QGraphicsBlurEffect('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGraphicsBlurEffect");
          if (cl.isUndefined()) {
              qWarning() << "Class QGraphicsBlurEffect is undefined. Use QGraphicsBlurEffect_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGraphicsBlurEffect('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGraphicsBlurEffect(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGraphicsBlurEffect(RJSApi& handler, const QGraphicsBlurEffect* v) {
          return RJSHelper::cpp2js_QGraphicsBlurEffect(handler, const_cast<QGraphicsBlurEffect*>(v));
      }

      QGraphicsBlurEffect* RJSHelper::js2cpp_QGraphicsBlurEffect_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGraphicsBlurEffect: not a QObject";
              return nullptr;
          }
          //QGraphicsBlurEffect_Wrapper* wrapper = getWrapper<QGraphicsBlurEffect_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QGraphicsBlurEffect_Wrapper* wrapper = qobject_cast<QGraphicsBlurEffect_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QGraphicsBlurEffect_Wrapper* wrapper = dynamic_cast<QGraphicsBlurEffect_Wrapper*>(obj);
          //QGraphicsBlurEffect_Wrapper* wrapper = (QGraphicsBlurEffect_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGraphicsBlurEffect: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QGraphicsBlurEffect*)wrapper->getWrappedVoid();
          //return getWrapped_QGraphicsBlurEffect(wrapper);
          return QGraphicsBlurEffect_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QGraphicsBlurEffect_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGraphicsBlurEffect: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QGraphicsBlurEffect_Type);
          //return fun.call().toInt()==RJSType::QGraphicsBlurEffect_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QGraphicsBlurEffect::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QGraphicsColorizeEffect(RJSApi& handler, QGraphicsColorizeEffect* v) {
          QGraphicsColorizeEffect_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QGraphicsColorizeEffect_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QGraphicsColorizeEffect: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QGraphicsColorizeEffect_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QGraphicsColorizeEffect_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QGraphicsColorizeEffect('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGraphicsColorizeEffect");
          if (cl.isUndefined()) {
              qWarning() << "Class QGraphicsColorizeEffect is undefined. Use QGraphicsColorizeEffect_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGraphicsColorizeEffect('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGraphicsColorizeEffect(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGraphicsColorizeEffect(RJSApi& handler, const QGraphicsColorizeEffect* v) {
          return RJSHelper::cpp2js_QGraphicsColorizeEffect(handler, const_cast<QGraphicsColorizeEffect*>(v));
      }

      QGraphicsColorizeEffect* RJSHelper::js2cpp_QGraphicsColorizeEffect_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGraphicsColorizeEffect: not a QObject";
              return nullptr;
          }
          //QGraphicsColorizeEffect_Wrapper* wrapper = getWrapper<QGraphicsColorizeEffect_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QGraphicsColorizeEffect_Wrapper* wrapper = qobject_cast<QGraphicsColorizeEffect_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QGraphicsColorizeEffect_Wrapper* wrapper = dynamic_cast<QGraphicsColorizeEffect_Wrapper*>(obj);
          //QGraphicsColorizeEffect_Wrapper* wrapper = (QGraphicsColorizeEffect_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGraphicsColorizeEffect: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QGraphicsColorizeEffect*)wrapper->getWrappedVoid();
          //return getWrapped_QGraphicsColorizeEffect(wrapper);
          return QGraphicsColorizeEffect_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QGraphicsColorizeEffect_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGraphicsColorizeEffect: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QGraphicsColorizeEffect_Type);
          //return fun.call().toInt()==RJSType::QGraphicsColorizeEffect_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QGraphicsColorizeEffect::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QGraphicsDropShadowEffect(RJSApi& handler, QGraphicsDropShadowEffect* v) {
          QGraphicsDropShadowEffect_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QGraphicsDropShadowEffect_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QGraphicsDropShadowEffect: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QGraphicsDropShadowEffect_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QGraphicsDropShadowEffect_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QGraphicsDropShadowEffect('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGraphicsDropShadowEffect");
          if (cl.isUndefined()) {
              qWarning() << "Class QGraphicsDropShadowEffect is undefined. Use QGraphicsDropShadowEffect_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGraphicsDropShadowEffect('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGraphicsDropShadowEffect(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGraphicsDropShadowEffect(RJSApi& handler, const QGraphicsDropShadowEffect* v) {
          return RJSHelper::cpp2js_QGraphicsDropShadowEffect(handler, const_cast<QGraphicsDropShadowEffect*>(v));
      }

      QGraphicsDropShadowEffect* RJSHelper::js2cpp_QGraphicsDropShadowEffect_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGraphicsDropShadowEffect: not a QObject";
              return nullptr;
          }
          //QGraphicsDropShadowEffect_Wrapper* wrapper = getWrapper<QGraphicsDropShadowEffect_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QGraphicsDropShadowEffect_Wrapper* wrapper = qobject_cast<QGraphicsDropShadowEffect_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QGraphicsDropShadowEffect_Wrapper* wrapper = dynamic_cast<QGraphicsDropShadowEffect_Wrapper*>(obj);
          //QGraphicsDropShadowEffect_Wrapper* wrapper = (QGraphicsDropShadowEffect_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGraphicsDropShadowEffect: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QGraphicsDropShadowEffect*)wrapper->getWrappedVoid();
          //return getWrapped_QGraphicsDropShadowEffect(wrapper);
          return QGraphicsDropShadowEffect_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QGraphicsDropShadowEffect_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGraphicsDropShadowEffect: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QGraphicsDropShadowEffect_Type);
          //return fun.call().toInt()==RJSType::QGraphicsDropShadowEffect_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QGraphicsDropShadowEffect::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QGraphicsEffect(RJSApi& handler, QGraphicsEffect* v) {
          
            // downcast to QGraphicsColorizeEffect:
            {
                QGraphicsColorizeEffect* o = qobject_cast<QGraphicsColorizeEffect*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QGraphicsColorizeEffect(handler, o);
                }
            }
          
            // downcast to QGraphicsBlurEffect:
            {
                QGraphicsBlurEffect* o = qobject_cast<QGraphicsBlurEffect*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QGraphicsBlurEffect(handler, o);
                }
            }
          
            // downcast to QGraphicsDropShadowEffect:
            {
                QGraphicsDropShadowEffect* o = qobject_cast<QGraphicsDropShadowEffect*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QGraphicsDropShadowEffect(handler, o);
                }
            }
          
            // downcast to QGraphicsOpacityEffect:
            {
                QGraphicsOpacityEffect* o = qobject_cast<QGraphicsOpacityEffect*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QGraphicsOpacityEffect(handler, o);
                }
            }
          QGraphicsEffect_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QGraphicsEffect_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QGraphicsEffect: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QGraphicsEffect_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QGraphicsEffect_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QGraphicsEffect('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGraphicsEffect");
          if (cl.isUndefined()) {
              qWarning() << "Class QGraphicsEffect is undefined. Use QGraphicsEffect_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGraphicsEffect('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGraphicsEffect(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGraphicsEffect(RJSApi& handler, const QGraphicsEffect* v) {
          return RJSHelper::cpp2js_QGraphicsEffect(handler, const_cast<QGraphicsEffect*>(v));
      }

      QGraphicsEffect* RJSHelper::js2cpp_QGraphicsEffect_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGraphicsEffect: not a QObject";
              return nullptr;
          }
          //QGraphicsEffect_Wrapper* wrapper = getWrapper<QGraphicsEffect_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QGraphicsEffect_Wrapper* wrapper = qobject_cast<QGraphicsEffect_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QGraphicsEffect_Wrapper* wrapper = dynamic_cast<QGraphicsEffect_Wrapper*>(obj);
          //QGraphicsEffect_Wrapper* wrapper = (QGraphicsEffect_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGraphicsEffect: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QGraphicsEffect*)wrapper->getWrappedVoid();
          //return getWrapped_QGraphicsEffect(wrapper);
          return QGraphicsEffect_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QGraphicsEffect_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGraphicsEffect: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QGraphicsEffect_Type);
          //return fun.call().toInt()==RJSType::QGraphicsEffect_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QGraphicsEffect::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QGraphicsOpacityEffect(RJSApi& handler, QGraphicsOpacityEffect* v) {
          QGraphicsOpacityEffect_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QGraphicsOpacityEffect_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QGraphicsOpacityEffect: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QGraphicsOpacityEffect_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QGraphicsOpacityEffect_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QGraphicsOpacityEffect('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGraphicsOpacityEffect");
          if (cl.isUndefined()) {
              qWarning() << "Class QGraphicsOpacityEffect is undefined. Use QGraphicsOpacityEffect_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGraphicsOpacityEffect('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGraphicsOpacityEffect(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGraphicsOpacityEffect(RJSApi& handler, const QGraphicsOpacityEffect* v) {
          return RJSHelper::cpp2js_QGraphicsOpacityEffect(handler, const_cast<QGraphicsOpacityEffect*>(v));
      }

      QGraphicsOpacityEffect* RJSHelper::js2cpp_QGraphicsOpacityEffect_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGraphicsOpacityEffect: not a QObject";
              return nullptr;
          }
          //QGraphicsOpacityEffect_Wrapper* wrapper = getWrapper<QGraphicsOpacityEffect_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QGraphicsOpacityEffect_Wrapper* wrapper = qobject_cast<QGraphicsOpacityEffect_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QGraphicsOpacityEffect_Wrapper* wrapper = dynamic_cast<QGraphicsOpacityEffect_Wrapper*>(obj);
          //QGraphicsOpacityEffect_Wrapper* wrapper = (QGraphicsOpacityEffect_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGraphicsOpacityEffect: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QGraphicsOpacityEffect*)wrapper->getWrappedVoid();
          //return getWrapped_QGraphicsOpacityEffect(wrapper);
          return QGraphicsOpacityEffect_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QGraphicsOpacityEffect_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGraphicsOpacityEffect: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QGraphicsOpacityEffect_Type);
          //return fun.call().toInt()==RJSType::QGraphicsOpacityEffect_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QGraphicsOpacityEffect::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QGridLayout(RJSApi& handler, QGridLayout* v) {
          QGridLayout_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QGridLayout_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QGridLayout: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QGridLayout_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QGridLayout_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QGridLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGridLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QGridLayout is undefined. Use QGridLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGridLayout('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGridLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGridLayout(RJSApi& handler, const QGridLayout* v) {
          return RJSHelper::cpp2js_QGridLayout(handler, const_cast<QGridLayout*>(v));
      }

      QGridLayout* RJSHelper::js2cpp_QGridLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGridLayout: not a QObject";
              return nullptr;
          }
          //QGridLayout_Wrapper* wrapper = getWrapper<QGridLayout_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QGridLayout_Wrapper* wrapper = qobject_cast<QGridLayout_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QGridLayout_Wrapper* wrapper = dynamic_cast<QGridLayout_Wrapper*>(obj);
          //QGridLayout_Wrapper* wrapper = (QGridLayout_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGridLayout: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QGridLayout*)wrapper->getWrappedVoid();
          //return getWrapped_QGridLayout(wrapper);
          return QGridLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QGridLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGridLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QGridLayout_Type);
          //return fun.call().toInt()==RJSType::QGridLayout_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QGridLayout::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QGroupBox(RJSApi& handler, QGroupBox* v) {
          QGroupBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QGroupBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QGroupBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QGroupBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QGroupBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QGroupBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGroupBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QGroupBox is undefined. Use QGroupBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGroupBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGroupBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGroupBox(RJSApi& handler, const QGroupBox* v) {
          return RJSHelper::cpp2js_QGroupBox(handler, const_cast<QGroupBox*>(v));
      }

      QGroupBox* RJSHelper::js2cpp_QGroupBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGroupBox: not a QObject";
              return nullptr;
          }
          //QGroupBox_Wrapper* wrapper = getWrapper<QGroupBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QGroupBox_Wrapper* wrapper = qobject_cast<QGroupBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QGroupBox_Wrapper* wrapper = dynamic_cast<QGroupBox_Wrapper*>(obj);
          //QGroupBox_Wrapper* wrapper = (QGroupBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGroupBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QGroupBox*)wrapper->getWrappedVoid();
          //return getWrapped_QGroupBox(wrapper);
          return QGroupBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QGroupBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGroupBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QGroupBox_Type);
          //return fun.call().toInt()==RJSType::QGroupBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QGroupBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QGuiApplication(RJSApi& handler, QGuiApplication* v) {
          
            // downcast to QApplication:
            {
                QApplication* o = qobject_cast<QApplication*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QApplication(handler, o);
                }
            }
          QGuiApplication_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QGuiApplication_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QGuiApplication: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QGuiApplication_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QGuiApplication_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QGuiApplication('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QGuiApplication");
          if (cl.isUndefined()) {
              qWarning() << "Class QGuiApplication is undefined. Use QGuiApplication_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QGuiApplication('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QGuiApplication(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QGuiApplication(RJSApi& handler, const QGuiApplication* v) {
          return RJSHelper::cpp2js_QGuiApplication(handler, const_cast<QGuiApplication*>(v));
      }

      QGuiApplication* RJSHelper::js2cpp_QGuiApplication_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QGuiApplication: not a QObject";
              return nullptr;
          }
          //QGuiApplication_Wrapper* wrapper = getWrapper<QGuiApplication_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QGuiApplication_Wrapper* wrapper = qobject_cast<QGuiApplication_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QGuiApplication_Wrapper* wrapper = dynamic_cast<QGuiApplication_Wrapper*>(obj);
          //QGuiApplication_Wrapper* wrapper = (QGuiApplication_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QGuiApplication: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QGuiApplication*)wrapper->getWrappedVoid();
          //return getWrapped_QGuiApplication(wrapper);
          return QGuiApplication_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QGuiApplication_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QGuiApplication: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QGuiApplication_Type);
          //return fun.call().toInt()==RJSType::QGuiApplication_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QGuiApplication::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QHBoxLayout(RJSApi& handler, QHBoxLayout* v) {
          QHBoxLayout_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QHBoxLayout_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QHBoxLayout: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QHBoxLayout_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QHBoxLayout_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QHBoxLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QHBoxLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QHBoxLayout is undefined. Use QHBoxLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QHBoxLayout('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QHBoxLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QHBoxLayout(RJSApi& handler, const QHBoxLayout* v) {
          return RJSHelper::cpp2js_QHBoxLayout(handler, const_cast<QHBoxLayout*>(v));
      }

      QHBoxLayout* RJSHelper::js2cpp_QHBoxLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QHBoxLayout: not a QObject";
              return nullptr;
          }
          //QHBoxLayout_Wrapper* wrapper = getWrapper<QHBoxLayout_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QHBoxLayout_Wrapper* wrapper = qobject_cast<QHBoxLayout_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QHBoxLayout_Wrapper* wrapper = dynamic_cast<QHBoxLayout_Wrapper*>(obj);
          //QHBoxLayout_Wrapper* wrapper = (QHBoxLayout_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QHBoxLayout: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QHBoxLayout*)wrapper->getWrappedVoid();
          //return getWrapped_QHBoxLayout(wrapper);
          return QHBoxLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QHBoxLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QHBoxLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QHBoxLayout_Type);
          //return fun.call().toInt()==RJSType::QHBoxLayout_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QHBoxLayout::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QHeaderView(RJSApi& handler, QHeaderView* v) {
          QHeaderView_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QHeaderView_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QHeaderView: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QHeaderView_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QHeaderView_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QHeaderView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QHeaderView");
          if (cl.isUndefined()) {
              qWarning() << "Class QHeaderView is undefined. Use QHeaderView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QHeaderView('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QHeaderView(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QHeaderView(RJSApi& handler, const QHeaderView* v) {
          return RJSHelper::cpp2js_QHeaderView(handler, const_cast<QHeaderView*>(v));
      }

      QHeaderView* RJSHelper::js2cpp_QHeaderView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QHeaderView: not a QObject";
              return nullptr;
          }
          //QHeaderView_Wrapper* wrapper = getWrapper<QHeaderView_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QHeaderView_Wrapper* wrapper = qobject_cast<QHeaderView_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QHeaderView_Wrapper* wrapper = dynamic_cast<QHeaderView_Wrapper*>(obj);
          //QHeaderView_Wrapper* wrapper = (QHeaderView_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QHeaderView: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QHeaderView*)wrapper->getWrappedVoid();
          //return getWrapped_QHeaderView(wrapper);
          return QHeaderView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QHeaderView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QHeaderView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QHeaderView_Type);
          //return fun.call().toInt()==RJSType::QHeaderView_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QHeaderView::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QIODevice(RJSApi& handler, QIODevice* v) {
          
            // downcast to QBuffer:
            {
                QBuffer* o = qobject_cast<QBuffer*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QBuffer(handler, o);
                }
            }
          
            // downcast to QFile:
            {
                QFile* o = qobject_cast<QFile*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QFile(handler, o);
                }
            }
          
            // downcast to QFileDevice:
            {
                QFileDevice* o = qobject_cast<QFileDevice*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QFileDevice(handler, o);
                }
            }
          
            // downcast to QProcess:
            {
                QProcess* o = qobject_cast<QProcess*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QProcess(handler, o);
                }
            }
          QIODevice_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QIODevice_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QIODevice: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QIODevice_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QIODevice_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QIODevice('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QIODevice");
          if (cl.isUndefined()) {
              qWarning() << "Class QIODevice is undefined. Use QIODevice_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QIODevice('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QIODevice(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QIODevice(RJSApi& handler, const QIODevice* v) {
          return RJSHelper::cpp2js_QIODevice(handler, const_cast<QIODevice*>(v));
      }

      QIODevice* RJSHelper::js2cpp_QIODevice_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QIODevice: not a QObject";
              return nullptr;
          }
          //QIODevice_Wrapper* wrapper = getWrapper<QIODevice_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QIODevice_Wrapper* wrapper = qobject_cast<QIODevice_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QIODevice_Wrapper* wrapper = dynamic_cast<QIODevice_Wrapper*>(obj);
          //QIODevice_Wrapper* wrapper = (QIODevice_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QIODevice: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QIODevice*)wrapper->getWrappedVoid();
          //return getWrapped_QIODevice(wrapper);
          return QIODevice_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QIODevice_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QIODevice: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QIODevice_Type);
          //return fun.call().toInt()==RJSType::QIODevice_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QIODevice::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QInputDevice(RJSApi& handler, QInputDevice* v) {
          QInputDevice_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QInputDevice_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QInputDevice: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QInputDevice_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QInputDevice_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QInputDevice('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QInputDevice");
          if (cl.isUndefined()) {
              qWarning() << "Class QInputDevice is undefined. Use QInputDevice_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QInputDevice('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QInputDevice(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QInputDevice(RJSApi& handler, const QInputDevice* v) {
          return RJSHelper::cpp2js_QInputDevice(handler, const_cast<QInputDevice*>(v));
      }

      QInputDevice* RJSHelper::js2cpp_QInputDevice_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QInputDevice: not a QObject";
              return nullptr;
          }
          //QInputDevice_Wrapper* wrapper = getWrapper<QInputDevice_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QInputDevice_Wrapper* wrapper = qobject_cast<QInputDevice_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QInputDevice_Wrapper* wrapper = dynamic_cast<QInputDevice_Wrapper*>(obj);
          //QInputDevice_Wrapper* wrapper = (QInputDevice_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QInputDevice: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QInputDevice*)wrapper->getWrappedVoid();
          //return getWrapped_QInputDevice(wrapper);
          return QInputDevice_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QInputDevice_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QInputDevice: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QInputDevice_Type);
          //return fun.call().toInt()==RJSType::QInputDevice_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QInputDevice::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QIntValidator(RJSApi& handler, QIntValidator* v) {
          QIntValidator_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QIntValidator_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QIntValidator: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QIntValidator_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QIntValidator_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QIntValidator('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QIntValidator");
          if (cl.isUndefined()) {
              qWarning() << "Class QIntValidator is undefined. Use QIntValidator_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QIntValidator('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QIntValidator(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QIntValidator(RJSApi& handler, const QIntValidator* v) {
          return RJSHelper::cpp2js_QIntValidator(handler, const_cast<QIntValidator*>(v));
      }

      QIntValidator* RJSHelper::js2cpp_QIntValidator_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QIntValidator: not a QObject";
              return nullptr;
          }
          //QIntValidator_Wrapper* wrapper = getWrapper<QIntValidator_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QIntValidator_Wrapper* wrapper = qobject_cast<QIntValidator_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QIntValidator_Wrapper* wrapper = dynamic_cast<QIntValidator_Wrapper*>(obj);
          //QIntValidator_Wrapper* wrapper = (QIntValidator_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QIntValidator: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QIntValidator*)wrapper->getWrappedVoid();
          //return getWrapped_QIntValidator(wrapper);
          return QIntValidator_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QIntValidator_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QIntValidator: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QIntValidator_Type);
          //return fun.call().toInt()==RJSType::QIntValidator_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QIntValidator::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QItemDelegate(RJSApi& handler, QItemDelegate* v) {
          
            // downcast to types derrived from QItemDelegate but defined in other modules:
            for (int i=0; i<downcasters_QItemDelegate.length(); i++) {
                QJSValue dc = downcasters_QItemDelegate[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QItemDelegate_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QItemDelegate_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QItemDelegate: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QItemDelegate_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QItemDelegate_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QItemDelegate('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QItemDelegate");
          if (cl.isUndefined()) {
              qWarning() << "Class QItemDelegate is undefined. Use QItemDelegate_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QItemDelegate('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QItemDelegate(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QItemDelegate(RJSApi& handler, const QItemDelegate* v) {
          return RJSHelper::cpp2js_QItemDelegate(handler, const_cast<QItemDelegate*>(v));
      }

      QItemDelegate* RJSHelper::js2cpp_QItemDelegate_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QItemDelegate: not a QObject";
              return nullptr;
          }
          //QItemDelegate_Wrapper* wrapper = getWrapper<QItemDelegate_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QItemDelegate_Wrapper* wrapper = qobject_cast<QItemDelegate_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QItemDelegate_Wrapper* wrapper = dynamic_cast<QItemDelegate_Wrapper*>(obj);
          //QItemDelegate_Wrapper* wrapper = (QItemDelegate_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QItemDelegate: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QItemDelegate*)wrapper->getWrappedVoid();
          //return getWrapped_QItemDelegate(wrapper);
          return QItemDelegate_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QItemDelegate_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QItemDelegate: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QItemDelegate_Type);
          //return fun.call().toInt()==RJSType::QItemDelegate_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QItemDelegate::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QItemSelectionModel(RJSApi& handler, QItemSelectionModel* v) {
          QItemSelectionModel_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QItemSelectionModel_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QItemSelectionModel: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QItemSelectionModel_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QItemSelectionModel_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QItemSelectionModel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QItemSelectionModel");
          if (cl.isUndefined()) {
              qWarning() << "Class QItemSelectionModel is undefined. Use QItemSelectionModel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QItemSelectionModel('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QItemSelectionModel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QItemSelectionModel(RJSApi& handler, const QItemSelectionModel* v) {
          return RJSHelper::cpp2js_QItemSelectionModel(handler, const_cast<QItemSelectionModel*>(v));
      }

      QItemSelectionModel* RJSHelper::js2cpp_QItemSelectionModel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QItemSelectionModel: not a QObject";
              return nullptr;
          }
          //QItemSelectionModel_Wrapper* wrapper = getWrapper<QItemSelectionModel_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QItemSelectionModel_Wrapper* wrapper = qobject_cast<QItemSelectionModel_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QItemSelectionModel_Wrapper* wrapper = dynamic_cast<QItemSelectionModel_Wrapper*>(obj);
          //QItemSelectionModel_Wrapper* wrapper = (QItemSelectionModel_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QItemSelectionModel: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QItemSelectionModel*)wrapper->getWrappedVoid();
          //return getWrapped_QItemSelectionModel(wrapper);
          return QItemSelectionModel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QItemSelectionModel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QItemSelectionModel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QItemSelectionModel_Type);
          //return fun.call().toInt()==RJSType::QItemSelectionModel_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QItemSelectionModel::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QLabel(RJSApi& handler, QLabel* v) {
          QLabel_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QLabel_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QLabel: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QLabel_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QLabel_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QLabel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLabel");
          if (cl.isUndefined()) {
              qWarning() << "Class QLabel is undefined. Use QLabel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLabel('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLabel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QLabel(RJSApi& handler, const QLabel* v) {
          return RJSHelper::cpp2js_QLabel(handler, const_cast<QLabel*>(v));
      }

      QLabel* RJSHelper::js2cpp_QLabel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QLabel: not a QObject";
              return nullptr;
          }
          //QLabel_Wrapper* wrapper = getWrapper<QLabel_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QLabel_Wrapper* wrapper = qobject_cast<QLabel_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QLabel_Wrapper* wrapper = dynamic_cast<QLabel_Wrapper*>(obj);
          //QLabel_Wrapper* wrapper = (QLabel_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLabel: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QLabel*)wrapper->getWrappedVoid();
          //return getWrapped_QLabel(wrapper);
          return QLabel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QLabel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QLabel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QLabel_Type);
          //return fun.call().toInt()==RJSType::QLabel_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QLabel::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QLayout(RJSApi& handler, QLayout* v) {
          
            // downcast to QBoxLayout:
            {
                QBoxLayout* o = qobject_cast<QBoxLayout*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QBoxLayout(handler, o);
                }
            }
          
            // downcast to QFormLayout:
            {
                QFormLayout* o = qobject_cast<QFormLayout*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QFormLayout(handler, o);
                }
            }
          
            // downcast to QGridLayout:
            {
                QGridLayout* o = qobject_cast<QGridLayout*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QGridLayout(handler, o);
                }
            }
          
            // downcast to QStackedLayout:
            {
                QStackedLayout* o = qobject_cast<QStackedLayout*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QStackedLayout(handler, o);
                }
            }
          
            // downcast to types derrived from QLayout but defined in other modules:
            for (int i=0; i<downcasters_QLayout.length(); i++) {
                QJSValue dc = downcasters_QLayout[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QLayout_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QLayout_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QLayout: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QLayout_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QLayout_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QLayout is undefined. Use QLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLayout('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QLayout(RJSApi& handler, const QLayout* v) {
          return RJSHelper::cpp2js_QLayout(handler, const_cast<QLayout*>(v));
      }

      QLayout* RJSHelper::js2cpp_QLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QLayout: not a QObject";
              return nullptr;
          }
          //QLayout_Wrapper* wrapper = getWrapper<QLayout_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QLayout_Wrapper* wrapper = qobject_cast<QLayout_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QLayout_Wrapper* wrapper = dynamic_cast<QLayout_Wrapper*>(obj);
          //QLayout_Wrapper* wrapper = (QLayout_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLayout: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QLayout*)wrapper->getWrappedVoid();
          //return getWrapped_QLayout(wrapper);
          return QLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QLayout_Type);
          //return fun.call().toInt()==RJSType::QLayout_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QLayout::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QLineEdit(RJSApi& handler, QLineEdit* v) {
          
            // downcast to types derrived from QLineEdit but defined in other modules:
            for (int i=0; i<downcasters_QLineEdit.length(); i++) {
                QJSValue dc = downcasters_QLineEdit[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QLineEdit_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QLineEdit_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QLineEdit: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QLineEdit_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QLineEdit_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QLineEdit('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QLineEdit");
          if (cl.isUndefined()) {
              qWarning() << "Class QLineEdit is undefined. Use QLineEdit_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QLineEdit('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QLineEdit(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QLineEdit(RJSApi& handler, const QLineEdit* v) {
          return RJSHelper::cpp2js_QLineEdit(handler, const_cast<QLineEdit*>(v));
      }

      QLineEdit* RJSHelper::js2cpp_QLineEdit_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QLineEdit: not a QObject";
              return nullptr;
          }
          //QLineEdit_Wrapper* wrapper = getWrapper<QLineEdit_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QLineEdit_Wrapper* wrapper = qobject_cast<QLineEdit_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QLineEdit_Wrapper* wrapper = dynamic_cast<QLineEdit_Wrapper*>(obj);
          //QLineEdit_Wrapper* wrapper = (QLineEdit_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QLineEdit: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QLineEdit*)wrapper->getWrappedVoid();
          //return getWrapped_QLineEdit(wrapper);
          return QLineEdit_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QLineEdit_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QLineEdit: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QLineEdit_Type);
          //return fun.call().toInt()==RJSType::QLineEdit_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QLineEdit::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QListView(RJSApi& handler, QListView* v) {
          
            // downcast to QListWidget:
            {
                QListWidget* o = qobject_cast<QListWidget*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QListWidget(handler, o);
                }
            }
          
            // downcast to types derrived from QListView but defined in other modules:
            for (int i=0; i<downcasters_QListView.length(); i++) {
                QJSValue dc = downcasters_QListView[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QListView_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QListView_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QListView: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QListView_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QListView_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QListView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QListView");
          if (cl.isUndefined()) {
              qWarning() << "Class QListView is undefined. Use QListView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QListView('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QListView(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QListView(RJSApi& handler, const QListView* v) {
          return RJSHelper::cpp2js_QListView(handler, const_cast<QListView*>(v));
      }

      QListView* RJSHelper::js2cpp_QListView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QListView: not a QObject";
              return nullptr;
          }
          //QListView_Wrapper* wrapper = getWrapper<QListView_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QListView_Wrapper* wrapper = qobject_cast<QListView_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QListView_Wrapper* wrapper = dynamic_cast<QListView_Wrapper*>(obj);
          //QListView_Wrapper* wrapper = (QListView_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QListView: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QListView*)wrapper->getWrappedVoid();
          //return getWrapped_QListView(wrapper);
          return QListView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QListView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QListView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QListView_Type);
          //return fun.call().toInt()==RJSType::QListView_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QListView::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QListWidget(RJSApi& handler, QListWidget* v) {
          
            // downcast to types derrived from QListWidget but defined in other modules:
            for (int i=0; i<downcasters_QListWidget.length(); i++) {
                QJSValue dc = downcasters_QListWidget[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QListWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QListWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QListWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QListWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QListWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QListWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QListWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class QListWidget is undefined. Use QListWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QListWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QListWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QListWidget(RJSApi& handler, const QListWidget* v) {
          return RJSHelper::cpp2js_QListWidget(handler, const_cast<QListWidget*>(v));
      }

      QListWidget* RJSHelper::js2cpp_QListWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QListWidget: not a QObject";
              return nullptr;
          }
          //QListWidget_Wrapper* wrapper = getWrapper<QListWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QListWidget_Wrapper* wrapper = qobject_cast<QListWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QListWidget_Wrapper* wrapper = dynamic_cast<QListWidget_Wrapper*>(obj);
          //QListWidget_Wrapper* wrapper = (QListWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QListWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QListWidget*)wrapper->getWrappedVoid();
          //return getWrapped_QListWidget(wrapper);
          return QListWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QListWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QListWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QListWidget_Type);
          //return fun.call().toInt()==RJSType::QListWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QListWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QMainWindow(RJSApi& handler, QMainWindow* v) {
          
            // downcast to types derrived from QMainWindow but defined in other modules:
            for (int i=0; i<downcasters_QMainWindow.length(); i++) {
                QJSValue dc = downcasters_QMainWindow[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QMainWindow_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QMainWindow_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QMainWindow: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QMainWindow_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QMainWindow_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QMainWindow('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMainWindow");
          if (cl.isUndefined()) {
              qWarning() << "Class QMainWindow is undefined. Use QMainWindow_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMainWindow('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMainWindow(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMainWindow(RJSApi& handler, const QMainWindow* v) {
          return RJSHelper::cpp2js_QMainWindow(handler, const_cast<QMainWindow*>(v));
      }

      QMainWindow* RJSHelper::js2cpp_QMainWindow_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMainWindow: not a QObject";
              return nullptr;
          }
          //QMainWindow_Wrapper* wrapper = getWrapper<QMainWindow_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QMainWindow_Wrapper* wrapper = qobject_cast<QMainWindow_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QMainWindow_Wrapper* wrapper = dynamic_cast<QMainWindow_Wrapper*>(obj);
          //QMainWindow_Wrapper* wrapper = (QMainWindow_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMainWindow: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QMainWindow*)wrapper->getWrappedVoid();
          //return getWrapped_QMainWindow(wrapper);
          return QMainWindow_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QMainWindow_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMainWindow: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QMainWindow_Type);
          //return fun.call().toInt()==RJSType::QMainWindow_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QMainWindow::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QMdiArea(RJSApi& handler, QMdiArea* v) {
          
            // downcast to types derrived from QMdiArea but defined in other modules:
            for (int i=0; i<downcasters_QMdiArea.length(); i++) {
                QJSValue dc = downcasters_QMdiArea[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QMdiArea_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QMdiArea_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QMdiArea: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QMdiArea_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QMdiArea_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QMdiArea('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMdiArea");
          if (cl.isUndefined()) {
              qWarning() << "Class QMdiArea is undefined. Use QMdiArea_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMdiArea('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMdiArea(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMdiArea(RJSApi& handler, const QMdiArea* v) {
          return RJSHelper::cpp2js_QMdiArea(handler, const_cast<QMdiArea*>(v));
      }

      QMdiArea* RJSHelper::js2cpp_QMdiArea_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMdiArea: not a QObject";
              return nullptr;
          }
          //QMdiArea_Wrapper* wrapper = getWrapper<QMdiArea_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QMdiArea_Wrapper* wrapper = qobject_cast<QMdiArea_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QMdiArea_Wrapper* wrapper = dynamic_cast<QMdiArea_Wrapper*>(obj);
          //QMdiArea_Wrapper* wrapper = (QMdiArea_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMdiArea: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QMdiArea*)wrapper->getWrappedVoid();
          //return getWrapped_QMdiArea(wrapper);
          return QMdiArea_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QMdiArea_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMdiArea: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QMdiArea_Type);
          //return fun.call().toInt()==RJSType::QMdiArea_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QMdiArea::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QMdiSubWindow(RJSApi& handler, QMdiSubWindow* v) {
          
            // downcast to types derrived from QMdiSubWindow but defined in other modules:
            for (int i=0; i<downcasters_QMdiSubWindow.length(); i++) {
                QJSValue dc = downcasters_QMdiSubWindow[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QMdiSubWindow_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QMdiSubWindow_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QMdiSubWindow: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QMdiSubWindow_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QMdiSubWindow_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QMdiSubWindow('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMdiSubWindow");
          if (cl.isUndefined()) {
              qWarning() << "Class QMdiSubWindow is undefined. Use QMdiSubWindow_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMdiSubWindow('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMdiSubWindow(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMdiSubWindow(RJSApi& handler, const QMdiSubWindow* v) {
          return RJSHelper::cpp2js_QMdiSubWindow(handler, const_cast<QMdiSubWindow*>(v));
      }

      QMdiSubWindow* RJSHelper::js2cpp_QMdiSubWindow_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMdiSubWindow: not a QObject";
              return nullptr;
          }
          //QMdiSubWindow_Wrapper* wrapper = getWrapper<QMdiSubWindow_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QMdiSubWindow_Wrapper* wrapper = qobject_cast<QMdiSubWindow_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QMdiSubWindow_Wrapper* wrapper = dynamic_cast<QMdiSubWindow_Wrapper*>(obj);
          //QMdiSubWindow_Wrapper* wrapper = (QMdiSubWindow_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMdiSubWindow: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QMdiSubWindow*)wrapper->getWrappedVoid();
          //return getWrapped_QMdiSubWindow(wrapper);
          return QMdiSubWindow_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QMdiSubWindow_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMdiSubWindow: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QMdiSubWindow_Type);
          //return fun.call().toInt()==RJSType::QMdiSubWindow_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QMdiSubWindow::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QMenu(RJSApi& handler, QMenu* v) {
          QMenu_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QMenu_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QMenu: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QMenu_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QMenu_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QMenu('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMenu");
          if (cl.isUndefined()) {
              qWarning() << "Class QMenu is undefined. Use QMenu_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMenu('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMenu(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMenu(RJSApi& handler, const QMenu* v) {
          return RJSHelper::cpp2js_QMenu(handler, const_cast<QMenu*>(v));
      }

      QMenu* RJSHelper::js2cpp_QMenu_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMenu: not a QObject";
              return nullptr;
          }
          //QMenu_Wrapper* wrapper = getWrapper<QMenu_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QMenu_Wrapper* wrapper = qobject_cast<QMenu_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QMenu_Wrapper* wrapper = dynamic_cast<QMenu_Wrapper*>(obj);
          //QMenu_Wrapper* wrapper = (QMenu_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMenu: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QMenu*)wrapper->getWrappedVoid();
          //return getWrapped_QMenu(wrapper);
          return QMenu_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QMenu_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMenu: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QMenu_Type);
          //return fun.call().toInt()==RJSType::QMenu_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QMenu::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QMenuBar(RJSApi& handler, QMenuBar* v) {
          QMenuBar_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QMenuBar_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QMenuBar: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QMenuBar_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QMenuBar_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QMenuBar('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMenuBar");
          if (cl.isUndefined()) {
              qWarning() << "Class QMenuBar is undefined. Use QMenuBar_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMenuBar('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMenuBar(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMenuBar(RJSApi& handler, const QMenuBar* v) {
          return RJSHelper::cpp2js_QMenuBar(handler, const_cast<QMenuBar*>(v));
      }

      QMenuBar* RJSHelper::js2cpp_QMenuBar_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMenuBar: not a QObject";
              return nullptr;
          }
          //QMenuBar_Wrapper* wrapper = getWrapper<QMenuBar_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QMenuBar_Wrapper* wrapper = qobject_cast<QMenuBar_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QMenuBar_Wrapper* wrapper = dynamic_cast<QMenuBar_Wrapper*>(obj);
          //QMenuBar_Wrapper* wrapper = (QMenuBar_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMenuBar: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QMenuBar*)wrapper->getWrappedVoid();
          //return getWrapped_QMenuBar(wrapper);
          return QMenuBar_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QMenuBar_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMenuBar: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QMenuBar_Type);
          //return fun.call().toInt()==RJSType::QMenuBar_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QMenuBar::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QMessageBox(RJSApi& handler, QMessageBox* v) {
          QMessageBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QMessageBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QMessageBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QMessageBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QMessageBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QMessageBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMessageBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QMessageBox is undefined. Use QMessageBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMessageBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMessageBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMessageBox(RJSApi& handler, const QMessageBox* v) {
          return RJSHelper::cpp2js_QMessageBox(handler, const_cast<QMessageBox*>(v));
      }

      QMessageBox* RJSHelper::js2cpp_QMessageBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMessageBox: not a QObject";
              return nullptr;
          }
          //QMessageBox_Wrapper* wrapper = getWrapper<QMessageBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QMessageBox_Wrapper* wrapper = qobject_cast<QMessageBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QMessageBox_Wrapper* wrapper = dynamic_cast<QMessageBox_Wrapper*>(obj);
          //QMessageBox_Wrapper* wrapper = (QMessageBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMessageBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QMessageBox*)wrapper->getWrappedVoid();
          //return getWrapped_QMessageBox(wrapper);
          return QMessageBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QMessageBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMessageBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QMessageBox_Type);
          //return fun.call().toInt()==RJSType::QMessageBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QMessageBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QMimeData(RJSApi& handler, QMimeData* v) {
          QMimeData_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QMimeData_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QMimeData: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QMimeData_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QMimeData_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QMimeData('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QMimeData");
          if (cl.isUndefined()) {
              qWarning() << "Class QMimeData is undefined. Use QMimeData_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QMimeData('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QMimeData(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QMimeData(RJSApi& handler, const QMimeData* v) {
          return RJSHelper::cpp2js_QMimeData(handler, const_cast<QMimeData*>(v));
      }

      QMimeData* RJSHelper::js2cpp_QMimeData_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QMimeData: not a QObject";
              return nullptr;
          }
          //QMimeData_Wrapper* wrapper = getWrapper<QMimeData_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QMimeData_Wrapper* wrapper = qobject_cast<QMimeData_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QMimeData_Wrapper* wrapper = dynamic_cast<QMimeData_Wrapper*>(obj);
          //QMimeData_Wrapper* wrapper = (QMimeData_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QMimeData: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QMimeData*)wrapper->getWrappedVoid();
          //return getWrapped_QMimeData(wrapper);
          return QMimeData_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QMimeData_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QMimeData: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QMimeData_Type);
          //return fun.call().toInt()==RJSType::QMimeData_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QMimeData::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QPlainTextEdit(RJSApi& handler, QPlainTextEdit* v) {
          QPlainTextEdit_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QPlainTextEdit_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QPlainTextEdit: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QPlainTextEdit_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QPlainTextEdit_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QPlainTextEdit('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPlainTextEdit");
          if (cl.isUndefined()) {
              qWarning() << "Class QPlainTextEdit is undefined. Use QPlainTextEdit_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPlainTextEdit('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPlainTextEdit(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPlainTextEdit(RJSApi& handler, const QPlainTextEdit* v) {
          return RJSHelper::cpp2js_QPlainTextEdit(handler, const_cast<QPlainTextEdit*>(v));
      }

      QPlainTextEdit* RJSHelper::js2cpp_QPlainTextEdit_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPlainTextEdit: not a QObject";
              return nullptr;
          }
          //QPlainTextEdit_Wrapper* wrapper = getWrapper<QPlainTextEdit_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QPlainTextEdit_Wrapper* wrapper = qobject_cast<QPlainTextEdit_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPlainTextEdit_Wrapper* wrapper = dynamic_cast<QPlainTextEdit_Wrapper*>(obj);
          //QPlainTextEdit_Wrapper* wrapper = (QPlainTextEdit_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPlainTextEdit: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QPlainTextEdit*)wrapper->getWrappedVoid();
          //return getWrapped_QPlainTextEdit(wrapper);
          return QPlainTextEdit_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPlainTextEdit_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPlainTextEdit: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QPlainTextEdit_Type);
          //return fun.call().toInt()==RJSType::QPlainTextEdit_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QPlainTextEdit::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QPrintDialog(RJSApi& handler, QPrintDialog* v) {
          QPrintDialog_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QPrintDialog_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QPrintDialog: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QPrintDialog_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QPrintDialog_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QPrintDialog('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPrintDialog");
          if (cl.isUndefined()) {
              qWarning() << "Class QPrintDialog is undefined. Use QPrintDialog_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPrintDialog('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPrintDialog(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPrintDialog(RJSApi& handler, const QPrintDialog* v) {
          return RJSHelper::cpp2js_QPrintDialog(handler, const_cast<QPrintDialog*>(v));
      }

      QPrintDialog* RJSHelper::js2cpp_QPrintDialog_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPrintDialog: not a QObject";
              return nullptr;
          }
          //QPrintDialog_Wrapper* wrapper = getWrapper<QPrintDialog_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QPrintDialog_Wrapper* wrapper = qobject_cast<QPrintDialog_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPrintDialog_Wrapper* wrapper = dynamic_cast<QPrintDialog_Wrapper*>(obj);
          //QPrintDialog_Wrapper* wrapper = (QPrintDialog_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPrintDialog: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QPrintDialog*)wrapper->getWrappedVoid();
          //return getWrapped_QPrintDialog(wrapper);
          return QPrintDialog_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPrintDialog_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPrintDialog: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QPrintDialog_Type);
          //return fun.call().toInt()==RJSType::QPrintDialog_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QPrintDialog::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QProgressBar(RJSApi& handler, QProgressBar* v) {
          QProgressBar_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QProgressBar_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QProgressBar: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QProgressBar_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QProgressBar_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QProgressBar('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QProgressBar");
          if (cl.isUndefined()) {
              qWarning() << "Class QProgressBar is undefined. Use QProgressBar_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QProgressBar('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QProgressBar(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QProgressBar(RJSApi& handler, const QProgressBar* v) {
          return RJSHelper::cpp2js_QProgressBar(handler, const_cast<QProgressBar*>(v));
      }

      QProgressBar* RJSHelper::js2cpp_QProgressBar_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QProgressBar: not a QObject";
              return nullptr;
          }
          //QProgressBar_Wrapper* wrapper = getWrapper<QProgressBar_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QProgressBar_Wrapper* wrapper = qobject_cast<QProgressBar_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QProgressBar_Wrapper* wrapper = dynamic_cast<QProgressBar_Wrapper*>(obj);
          //QProgressBar_Wrapper* wrapper = (QProgressBar_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QProgressBar: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QProgressBar*)wrapper->getWrappedVoid();
          //return getWrapped_QProgressBar(wrapper);
          return QProgressBar_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QProgressBar_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QProgressBar: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QProgressBar_Type);
          //return fun.call().toInt()==RJSType::QProgressBar_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QProgressBar::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QProgressDialog(RJSApi& handler, QProgressDialog* v) {
          QProgressDialog_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QProgressDialog_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QProgressDialog: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QProgressDialog_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QProgressDialog_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QProgressDialog('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QProgressDialog");
          if (cl.isUndefined()) {
              qWarning() << "Class QProgressDialog is undefined. Use QProgressDialog_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QProgressDialog('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QProgressDialog(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QProgressDialog(RJSApi& handler, const QProgressDialog* v) {
          return RJSHelper::cpp2js_QProgressDialog(handler, const_cast<QProgressDialog*>(v));
      }

      QProgressDialog* RJSHelper::js2cpp_QProgressDialog_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QProgressDialog: not a QObject";
              return nullptr;
          }
          //QProgressDialog_Wrapper* wrapper = getWrapper<QProgressDialog_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QProgressDialog_Wrapper* wrapper = qobject_cast<QProgressDialog_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QProgressDialog_Wrapper* wrapper = dynamic_cast<QProgressDialog_Wrapper*>(obj);
          //QProgressDialog_Wrapper* wrapper = (QProgressDialog_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QProgressDialog: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QProgressDialog*)wrapper->getWrappedVoid();
          //return getWrapped_QProgressDialog(wrapper);
          return QProgressDialog_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QProgressDialog_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QProgressDialog: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QProgressDialog_Type);
          //return fun.call().toInt()==RJSType::QProgressDialog_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QProgressDialog::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QPushButton(RJSApi& handler, QPushButton* v) {
          QPushButton_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QPushButton_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QPushButton: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QPushButton_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QPushButton_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QPushButton('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QPushButton");
          if (cl.isUndefined()) {
              qWarning() << "Class QPushButton is undefined. Use QPushButton_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QPushButton('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QPushButton(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QPushButton(RJSApi& handler, const QPushButton* v) {
          return RJSHelper::cpp2js_QPushButton(handler, const_cast<QPushButton*>(v));
      }

      QPushButton* RJSHelper::js2cpp_QPushButton_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QPushButton: not a QObject";
              return nullptr;
          }
          //QPushButton_Wrapper* wrapper = getWrapper<QPushButton_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QPushButton_Wrapper* wrapper = qobject_cast<QPushButton_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QPushButton_Wrapper* wrapper = dynamic_cast<QPushButton_Wrapper*>(obj);
          //QPushButton_Wrapper* wrapper = (QPushButton_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QPushButton: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QPushButton*)wrapper->getWrappedVoid();
          //return getWrapped_QPushButton(wrapper);
          return QPushButton_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QPushButton_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QPushButton: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QPushButton_Type);
          //return fun.call().toInt()==RJSType::QPushButton_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QPushButton::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QQuickView(RJSApi& handler, QQuickView* v) {
          QQuickView_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QQuickView_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QQuickView: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QQuickView_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QQuickView_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QQuickView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QQuickView");
          if (cl.isUndefined()) {
              qWarning() << "Class QQuickView is undefined. Use QQuickView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QQuickView('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QQuickView(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QQuickView(RJSApi& handler, const QQuickView* v) {
          return RJSHelper::cpp2js_QQuickView(handler, const_cast<QQuickView*>(v));
      }

      QQuickView* RJSHelper::js2cpp_QQuickView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QQuickView: not a QObject";
              return nullptr;
          }
          //QQuickView_Wrapper* wrapper = getWrapper<QQuickView_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QQuickView_Wrapper* wrapper = qobject_cast<QQuickView_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QQuickView_Wrapper* wrapper = dynamic_cast<QQuickView_Wrapper*>(obj);
          //QQuickView_Wrapper* wrapper = (QQuickView_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QQuickView: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QQuickView*)wrapper->getWrappedVoid();
          //return getWrapped_QQuickView(wrapper);
          return QQuickView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QQuickView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QQuickView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QQuickView_Type);
          //return fun.call().toInt()==RJSType::QQuickView_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QQuickView::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QQuickWidget(RJSApi& handler, QQuickWidget* v) {
          QQuickWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QQuickWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QQuickWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QQuickWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QQuickWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QQuickWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QQuickWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class QQuickWidget is undefined. Use QQuickWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QQuickWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QQuickWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QQuickWidget(RJSApi& handler, const QQuickWidget* v) {
          return RJSHelper::cpp2js_QQuickWidget(handler, const_cast<QQuickWidget*>(v));
      }

      QQuickWidget* RJSHelper::js2cpp_QQuickWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QQuickWidget: not a QObject";
              return nullptr;
          }
          //QQuickWidget_Wrapper* wrapper = getWrapper<QQuickWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QQuickWidget_Wrapper* wrapper = qobject_cast<QQuickWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QQuickWidget_Wrapper* wrapper = dynamic_cast<QQuickWidget_Wrapper*>(obj);
          //QQuickWidget_Wrapper* wrapper = (QQuickWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QQuickWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QQuickWidget*)wrapper->getWrappedVoid();
          //return getWrapped_QQuickWidget(wrapper);
          return QQuickWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QQuickWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QQuickWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QQuickWidget_Type);
          //return fun.call().toInt()==RJSType::QQuickWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QQuickWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QRadioButton(RJSApi& handler, QRadioButton* v) {
          QRadioButton_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QRadioButton_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QRadioButton: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QRadioButton_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QRadioButton_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QRadioButton('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRadioButton");
          if (cl.isUndefined()) {
              qWarning() << "Class QRadioButton is undefined. Use QRadioButton_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRadioButton('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRadioButton(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QRadioButton(RJSApi& handler, const QRadioButton* v) {
          return RJSHelper::cpp2js_QRadioButton(handler, const_cast<QRadioButton*>(v));
      }

      QRadioButton* RJSHelper::js2cpp_QRadioButton_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QRadioButton: not a QObject";
              return nullptr;
          }
          //QRadioButton_Wrapper* wrapper = getWrapper<QRadioButton_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QRadioButton_Wrapper* wrapper = qobject_cast<QRadioButton_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QRadioButton_Wrapper* wrapper = dynamic_cast<QRadioButton_Wrapper*>(obj);
          //QRadioButton_Wrapper* wrapper = (QRadioButton_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRadioButton: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QRadioButton*)wrapper->getWrappedVoid();
          //return getWrapped_QRadioButton(wrapper);
          return QRadioButton_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QRadioButton_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QRadioButton: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QRadioButton_Type);
          //return fun.call().toInt()==RJSType::QRadioButton_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QRadioButton::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QRegularExpressionValidator(RJSApi& handler, QRegularExpressionValidator* v) {
          QRegularExpressionValidator_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QRegularExpressionValidator_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QRegularExpressionValidator: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QRegularExpressionValidator_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QRegularExpressionValidator_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QRegularExpressionValidator('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QRegularExpressionValidator");
          if (cl.isUndefined()) {
              qWarning() << "Class QRegularExpressionValidator is undefined. Use QRegularExpressionValidator_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QRegularExpressionValidator('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QRegularExpressionValidator(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QRegularExpressionValidator(RJSApi& handler, const QRegularExpressionValidator* v) {
          return RJSHelper::cpp2js_QRegularExpressionValidator(handler, const_cast<QRegularExpressionValidator*>(v));
      }

      QRegularExpressionValidator* RJSHelper::js2cpp_QRegularExpressionValidator_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QRegularExpressionValidator: not a QObject";
              return nullptr;
          }
          //QRegularExpressionValidator_Wrapper* wrapper = getWrapper<QRegularExpressionValidator_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QRegularExpressionValidator_Wrapper* wrapper = qobject_cast<QRegularExpressionValidator_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QRegularExpressionValidator_Wrapper* wrapper = dynamic_cast<QRegularExpressionValidator_Wrapper*>(obj);
          //QRegularExpressionValidator_Wrapper* wrapper = (QRegularExpressionValidator_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QRegularExpressionValidator: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QRegularExpressionValidator*)wrapper->getWrappedVoid();
          //return getWrapped_QRegularExpressionValidator(wrapper);
          return QRegularExpressionValidator_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QRegularExpressionValidator_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QRegularExpressionValidator: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QRegularExpressionValidator_Type);
          //return fun.call().toInt()==RJSType::QRegularExpressionValidator_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QRegularExpressionValidator::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QScreen(RJSApi& handler, QScreen* v) {
          QScreen_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QScreen_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QScreen: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QScreen_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QScreen_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QScreen('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QScreen");
          if (cl.isUndefined()) {
              qWarning() << "Class QScreen is undefined. Use QScreen_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QScreen('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QScreen(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QScreen(RJSApi& handler, const QScreen* v) {
          return RJSHelper::cpp2js_QScreen(handler, const_cast<QScreen*>(v));
      }

      QScreen* RJSHelper::js2cpp_QScreen_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QScreen: not a QObject";
              return nullptr;
          }
          //QScreen_Wrapper* wrapper = getWrapper<QScreen_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QScreen_Wrapper* wrapper = qobject_cast<QScreen_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QScreen_Wrapper* wrapper = dynamic_cast<QScreen_Wrapper*>(obj);
          //QScreen_Wrapper* wrapper = (QScreen_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QScreen: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QScreen*)wrapper->getWrappedVoid();
          //return getWrapped_QScreen(wrapper);
          return QScreen_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QScreen_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QScreen: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QScreen_Type);
          //return fun.call().toInt()==RJSType::QScreen_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QScreen::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QScrollArea(RJSApi& handler, QScrollArea* v) {
          QScrollArea_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QScrollArea_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QScrollArea: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QScrollArea_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QScrollArea_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QScrollArea('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QScrollArea");
          if (cl.isUndefined()) {
              qWarning() << "Class QScrollArea is undefined. Use QScrollArea_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QScrollArea('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QScrollArea(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QScrollArea(RJSApi& handler, const QScrollArea* v) {
          return RJSHelper::cpp2js_QScrollArea(handler, const_cast<QScrollArea*>(v));
      }

      QScrollArea* RJSHelper::js2cpp_QScrollArea_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QScrollArea: not a QObject";
              return nullptr;
          }
          //QScrollArea_Wrapper* wrapper = getWrapper<QScrollArea_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QScrollArea_Wrapper* wrapper = qobject_cast<QScrollArea_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QScrollArea_Wrapper* wrapper = dynamic_cast<QScrollArea_Wrapper*>(obj);
          //QScrollArea_Wrapper* wrapper = (QScrollArea_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QScrollArea: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QScrollArea*)wrapper->getWrappedVoid();
          //return getWrapped_QScrollArea(wrapper);
          return QScrollArea_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QScrollArea_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QScrollArea: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QScrollArea_Type);
          //return fun.call().toInt()==RJSType::QScrollArea_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QScrollArea::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QScrollBar(RJSApi& handler, QScrollBar* v) {
          QScrollBar_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QScrollBar_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QScrollBar: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QScrollBar_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QScrollBar_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QScrollBar('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QScrollBar");
          if (cl.isUndefined()) {
              qWarning() << "Class QScrollBar is undefined. Use QScrollBar_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QScrollBar('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QScrollBar(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QScrollBar(RJSApi& handler, const QScrollBar* v) {
          return RJSHelper::cpp2js_QScrollBar(handler, const_cast<QScrollBar*>(v));
      }

      QScrollBar* RJSHelper::js2cpp_QScrollBar_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QScrollBar: not a QObject";
              return nullptr;
          }
          //QScrollBar_Wrapper* wrapper = getWrapper<QScrollBar_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QScrollBar_Wrapper* wrapper = qobject_cast<QScrollBar_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QScrollBar_Wrapper* wrapper = dynamic_cast<QScrollBar_Wrapper*>(obj);
          //QScrollBar_Wrapper* wrapper = (QScrollBar_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QScrollBar: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QScrollBar*)wrapper->getWrappedVoid();
          //return getWrapped_QScrollBar(wrapper);
          return QScrollBar_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QScrollBar_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QScrollBar: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QScrollBar_Type);
          //return fun.call().toInt()==RJSType::QScrollBar_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QScrollBar::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QSettings(RJSApi& handler, QSettings* v) {
          QSettings_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QSettings_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QSettings: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QSettings_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QSettings_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QSettings('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSettings");
          if (cl.isUndefined()) {
              qWarning() << "Class QSettings is undefined. Use QSettings_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSettings('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSettings(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSettings(RJSApi& handler, const QSettings* v) {
          return RJSHelper::cpp2js_QSettings(handler, const_cast<QSettings*>(v));
      }

      QSettings* RJSHelper::js2cpp_QSettings_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSettings: not a QObject";
              return nullptr;
          }
          //QSettings_Wrapper* wrapper = getWrapper<QSettings_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QSettings_Wrapper* wrapper = qobject_cast<QSettings_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSettings_Wrapper* wrapper = dynamic_cast<QSettings_Wrapper*>(obj);
          //QSettings_Wrapper* wrapper = (QSettings_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSettings: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QSettings*)wrapper->getWrappedVoid();
          //return getWrapped_QSettings(wrapper);
          return QSettings_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSettings_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSettings: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QSettings_Type);
          //return fun.call().toInt()==RJSType::QSettings_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QSettings::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QShortcut(RJSApi& handler, QShortcut* v) {
          QShortcut_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QShortcut_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QShortcut: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QShortcut_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QShortcut_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QShortcut('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QShortcut");
          if (cl.isUndefined()) {
              qWarning() << "Class QShortcut is undefined. Use QShortcut_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QShortcut('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QShortcut(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QShortcut(RJSApi& handler, const QShortcut* v) {
          return RJSHelper::cpp2js_QShortcut(handler, const_cast<QShortcut*>(v));
      }

      QShortcut* RJSHelper::js2cpp_QShortcut_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QShortcut: not a QObject";
              return nullptr;
          }
          //QShortcut_Wrapper* wrapper = getWrapper<QShortcut_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QShortcut_Wrapper* wrapper = qobject_cast<QShortcut_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QShortcut_Wrapper* wrapper = dynamic_cast<QShortcut_Wrapper*>(obj);
          //QShortcut_Wrapper* wrapper = (QShortcut_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QShortcut: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QShortcut*)wrapper->getWrappedVoid();
          //return getWrapped_QShortcut(wrapper);
          return QShortcut_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QShortcut_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QShortcut: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QShortcut_Type);
          //return fun.call().toInt()==RJSType::QShortcut_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QShortcut::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QSlider(RJSApi& handler, QSlider* v) {
          QSlider_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QSlider_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QSlider: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QSlider_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QSlider_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QSlider('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSlider");
          if (cl.isUndefined()) {
              qWarning() << "Class QSlider is undefined. Use QSlider_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSlider('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSlider(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSlider(RJSApi& handler, const QSlider* v) {
          return RJSHelper::cpp2js_QSlider(handler, const_cast<QSlider*>(v));
      }

      QSlider* RJSHelper::js2cpp_QSlider_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSlider: not a QObject";
              return nullptr;
          }
          //QSlider_Wrapper* wrapper = getWrapper<QSlider_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QSlider_Wrapper* wrapper = qobject_cast<QSlider_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSlider_Wrapper* wrapper = dynamic_cast<QSlider_Wrapper*>(obj);
          //QSlider_Wrapper* wrapper = (QSlider_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSlider: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QSlider*)wrapper->getWrappedVoid();
          //return getWrapped_QSlider(wrapper);
          return QSlider_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSlider_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSlider: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QSlider_Type);
          //return fun.call().toInt()==RJSType::QSlider_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QSlider::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QSortFilterProxyModel(RJSApi& handler, QSortFilterProxyModel* v) {
          QSortFilterProxyModel_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QSortFilterProxyModel_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QSortFilterProxyModel: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QSortFilterProxyModel_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QSortFilterProxyModel_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QSortFilterProxyModel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSortFilterProxyModel");
          if (cl.isUndefined()) {
              qWarning() << "Class QSortFilterProxyModel is undefined. Use QSortFilterProxyModel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSortFilterProxyModel('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSortFilterProxyModel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSortFilterProxyModel(RJSApi& handler, const QSortFilterProxyModel* v) {
          return RJSHelper::cpp2js_QSortFilterProxyModel(handler, const_cast<QSortFilterProxyModel*>(v));
      }

      QSortFilterProxyModel* RJSHelper::js2cpp_QSortFilterProxyModel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSortFilterProxyModel: not a QObject";
              return nullptr;
          }
          //QSortFilterProxyModel_Wrapper* wrapper = getWrapper<QSortFilterProxyModel_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QSortFilterProxyModel_Wrapper* wrapper = qobject_cast<QSortFilterProxyModel_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSortFilterProxyModel_Wrapper* wrapper = dynamic_cast<QSortFilterProxyModel_Wrapper*>(obj);
          //QSortFilterProxyModel_Wrapper* wrapper = (QSortFilterProxyModel_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSortFilterProxyModel: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QSortFilterProxyModel*)wrapper->getWrappedVoid();
          //return getWrapped_QSortFilterProxyModel(wrapper);
          return QSortFilterProxyModel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSortFilterProxyModel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSortFilterProxyModel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QSortFilterProxyModel_Type);
          //return fun.call().toInt()==RJSType::QSortFilterProxyModel_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QSortFilterProxyModel::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QSpinBox(RJSApi& handler, QSpinBox* v) {
          QSpinBox_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QSpinBox_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QSpinBox: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QSpinBox_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QSpinBox_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QSpinBox('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSpinBox");
          if (cl.isUndefined()) {
              qWarning() << "Class QSpinBox is undefined. Use QSpinBox_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSpinBox('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSpinBox(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSpinBox(RJSApi& handler, const QSpinBox* v) {
          return RJSHelper::cpp2js_QSpinBox(handler, const_cast<QSpinBox*>(v));
      }

      QSpinBox* RJSHelper::js2cpp_QSpinBox_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSpinBox: not a QObject";
              return nullptr;
          }
          //QSpinBox_Wrapper* wrapper = getWrapper<QSpinBox_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QSpinBox_Wrapper* wrapper = qobject_cast<QSpinBox_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSpinBox_Wrapper* wrapper = dynamic_cast<QSpinBox_Wrapper*>(obj);
          //QSpinBox_Wrapper* wrapper = (QSpinBox_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSpinBox: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QSpinBox*)wrapper->getWrappedVoid();
          //return getWrapped_QSpinBox(wrapper);
          return QSpinBox_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSpinBox_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSpinBox: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QSpinBox_Type);
          //return fun.call().toInt()==RJSType::QSpinBox_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QSpinBox::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QSplashScreen(RJSApi& handler, QSplashScreen* v) {
          QSplashScreen_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QSplashScreen_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QSplashScreen: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QSplashScreen_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QSplashScreen_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QSplashScreen('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSplashScreen");
          if (cl.isUndefined()) {
              qWarning() << "Class QSplashScreen is undefined. Use QSplashScreen_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSplashScreen('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSplashScreen(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSplashScreen(RJSApi& handler, const QSplashScreen* v) {
          return RJSHelper::cpp2js_QSplashScreen(handler, const_cast<QSplashScreen*>(v));
      }

      QSplashScreen* RJSHelper::js2cpp_QSplashScreen_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSplashScreen: not a QObject";
              return nullptr;
          }
          //QSplashScreen_Wrapper* wrapper = getWrapper<QSplashScreen_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QSplashScreen_Wrapper* wrapper = qobject_cast<QSplashScreen_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSplashScreen_Wrapper* wrapper = dynamic_cast<QSplashScreen_Wrapper*>(obj);
          //QSplashScreen_Wrapper* wrapper = (QSplashScreen_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSplashScreen: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QSplashScreen*)wrapper->getWrappedVoid();
          //return getWrapped_QSplashScreen(wrapper);
          return QSplashScreen_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSplashScreen_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSplashScreen: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QSplashScreen_Type);
          //return fun.call().toInt()==RJSType::QSplashScreen_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QSplashScreen::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QSplitter(RJSApi& handler, QSplitter* v) {
          QSplitter_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QSplitter_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QSplitter: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QSplitter_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QSplitter_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QSplitter('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSplitter");
          if (cl.isUndefined()) {
              qWarning() << "Class QSplitter is undefined. Use QSplitter_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSplitter('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSplitter(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSplitter(RJSApi& handler, const QSplitter* v) {
          return RJSHelper::cpp2js_QSplitter(handler, const_cast<QSplitter*>(v));
      }

      QSplitter* RJSHelper::js2cpp_QSplitter_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSplitter: not a QObject";
              return nullptr;
          }
          //QSplitter_Wrapper* wrapper = getWrapper<QSplitter_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QSplitter_Wrapper* wrapper = qobject_cast<QSplitter_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSplitter_Wrapper* wrapper = dynamic_cast<QSplitter_Wrapper*>(obj);
          //QSplitter_Wrapper* wrapper = (QSplitter_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSplitter: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QSplitter*)wrapper->getWrappedVoid();
          //return getWrapped_QSplitter(wrapper);
          return QSplitter_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSplitter_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSplitter: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QSplitter_Type);
          //return fun.call().toInt()==RJSType::QSplitter_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QSplitter::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QSplitterHandle(RJSApi& handler, QSplitterHandle* v) {
          QSplitterHandle_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QSplitterHandle_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QSplitterHandle: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QSplitterHandle_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QSplitterHandle_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QSplitterHandle('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSplitterHandle");
          if (cl.isUndefined()) {
              qWarning() << "Class QSplitterHandle is undefined. Use QSplitterHandle_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSplitterHandle('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSplitterHandle(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSplitterHandle(RJSApi& handler, const QSplitterHandle* v) {
          return RJSHelper::cpp2js_QSplitterHandle(handler, const_cast<QSplitterHandle*>(v));
      }

      QSplitterHandle* RJSHelper::js2cpp_QSplitterHandle_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSplitterHandle: not a QObject";
              return nullptr;
          }
          //QSplitterHandle_Wrapper* wrapper = getWrapper<QSplitterHandle_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QSplitterHandle_Wrapper* wrapper = qobject_cast<QSplitterHandle_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSplitterHandle_Wrapper* wrapper = dynamic_cast<QSplitterHandle_Wrapper*>(obj);
          //QSplitterHandle_Wrapper* wrapper = (QSplitterHandle_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSplitterHandle: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QSplitterHandle*)wrapper->getWrappedVoid();
          //return getWrapped_QSplitterHandle(wrapper);
          return QSplitterHandle_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSplitterHandle_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSplitterHandle: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QSplitterHandle_Type);
          //return fun.call().toInt()==RJSType::QSplitterHandle_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QSplitterHandle::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QStackedLayout(RJSApi& handler, QStackedLayout* v) {
          QStackedLayout_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QStackedLayout_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QStackedLayout: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QStackedLayout_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QStackedLayout_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QStackedLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QStackedLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QStackedLayout is undefined. Use QStackedLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QStackedLayout('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QStackedLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QStackedLayout(RJSApi& handler, const QStackedLayout* v) {
          return RJSHelper::cpp2js_QStackedLayout(handler, const_cast<QStackedLayout*>(v));
      }

      QStackedLayout* RJSHelper::js2cpp_QStackedLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QStackedLayout: not a QObject";
              return nullptr;
          }
          //QStackedLayout_Wrapper* wrapper = getWrapper<QStackedLayout_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QStackedLayout_Wrapper* wrapper = qobject_cast<QStackedLayout_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QStackedLayout_Wrapper* wrapper = dynamic_cast<QStackedLayout_Wrapper*>(obj);
          //QStackedLayout_Wrapper* wrapper = (QStackedLayout_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QStackedLayout: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QStackedLayout*)wrapper->getWrappedVoid();
          //return getWrapped_QStackedLayout(wrapper);
          return QStackedLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QStackedLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QStackedLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QStackedLayout_Type);
          //return fun.call().toInt()==RJSType::QStackedLayout_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QStackedLayout::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QStackedWidget(RJSApi& handler, QStackedWidget* v) {
          QStackedWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QStackedWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QStackedWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QStackedWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QStackedWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QStackedWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QStackedWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class QStackedWidget is undefined. Use QStackedWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QStackedWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QStackedWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QStackedWidget(RJSApi& handler, const QStackedWidget* v) {
          return RJSHelper::cpp2js_QStackedWidget(handler, const_cast<QStackedWidget*>(v));
      }

      QStackedWidget* RJSHelper::js2cpp_QStackedWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QStackedWidget: not a QObject";
              return nullptr;
          }
          //QStackedWidget_Wrapper* wrapper = getWrapper<QStackedWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QStackedWidget_Wrapper* wrapper = qobject_cast<QStackedWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QStackedWidget_Wrapper* wrapper = dynamic_cast<QStackedWidget_Wrapper*>(obj);
          //QStackedWidget_Wrapper* wrapper = (QStackedWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QStackedWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QStackedWidget*)wrapper->getWrappedVoid();
          //return getWrapped_QStackedWidget(wrapper);
          return QStackedWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QStackedWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QStackedWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QStackedWidget_Type);
          //return fun.call().toInt()==RJSType::QStackedWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QStackedWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QStandardItemModel(RJSApi& handler, QStandardItemModel* v) {
          QStandardItemModel_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QStandardItemModel_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QStandardItemModel: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QStandardItemModel_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QStandardItemModel_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QStandardItemModel('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QStandardItemModel");
          if (cl.isUndefined()) {
              qWarning() << "Class QStandardItemModel is undefined. Use QStandardItemModel_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QStandardItemModel('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QStandardItemModel(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QStandardItemModel(RJSApi& handler, const QStandardItemModel* v) {
          return RJSHelper::cpp2js_QStandardItemModel(handler, const_cast<QStandardItemModel*>(v));
      }

      QStandardItemModel* RJSHelper::js2cpp_QStandardItemModel_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QStandardItemModel: not a QObject";
              return nullptr;
          }
          //QStandardItemModel_Wrapper* wrapper = getWrapper<QStandardItemModel_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QStandardItemModel_Wrapper* wrapper = qobject_cast<QStandardItemModel_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QStandardItemModel_Wrapper* wrapper = dynamic_cast<QStandardItemModel_Wrapper*>(obj);
          //QStandardItemModel_Wrapper* wrapper = (QStandardItemModel_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QStandardItemModel: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QStandardItemModel*)wrapper->getWrappedVoid();
          //return getWrapped_QStandardItemModel(wrapper);
          return QStandardItemModel_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QStandardItemModel_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QStandardItemModel: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QStandardItemModel_Type);
          //return fun.call().toInt()==RJSType::QStandardItemModel_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QStandardItemModel::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QStatusBar(RJSApi& handler, QStatusBar* v) {
          QStatusBar_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QStatusBar_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QStatusBar: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QStatusBar_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QStatusBar_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QStatusBar('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QStatusBar");
          if (cl.isUndefined()) {
              qWarning() << "Class QStatusBar is undefined. Use QStatusBar_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QStatusBar('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QStatusBar(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QStatusBar(RJSApi& handler, const QStatusBar* v) {
          return RJSHelper::cpp2js_QStatusBar(handler, const_cast<QStatusBar*>(v));
      }

      QStatusBar* RJSHelper::js2cpp_QStatusBar_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QStatusBar: not a QObject";
              return nullptr;
          }
          //QStatusBar_Wrapper* wrapper = getWrapper<QStatusBar_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QStatusBar_Wrapper* wrapper = qobject_cast<QStatusBar_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QStatusBar_Wrapper* wrapper = dynamic_cast<QStatusBar_Wrapper*>(obj);
          //QStatusBar_Wrapper* wrapper = (QStatusBar_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QStatusBar: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QStatusBar*)wrapper->getWrappedVoid();
          //return getWrapped_QStatusBar(wrapper);
          return QStatusBar_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QStatusBar_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QStatusBar: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QStatusBar_Type);
          //return fun.call().toInt()==RJSType::QStatusBar_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QStatusBar::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QSvgRenderer(RJSApi& handler, QSvgRenderer* v) {
          QSvgRenderer_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QSvgRenderer_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QSvgRenderer: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QSvgRenderer_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QSvgRenderer_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QSvgRenderer('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QSvgRenderer");
          if (cl.isUndefined()) {
              qWarning() << "Class QSvgRenderer is undefined. Use QSvgRenderer_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QSvgRenderer('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QSvgRenderer(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QSvgRenderer(RJSApi& handler, const QSvgRenderer* v) {
          return RJSHelper::cpp2js_QSvgRenderer(handler, const_cast<QSvgRenderer*>(v));
      }

      QSvgRenderer* RJSHelper::js2cpp_QSvgRenderer_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QSvgRenderer: not a QObject";
              return nullptr;
          }
          //QSvgRenderer_Wrapper* wrapper = getWrapper<QSvgRenderer_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QSvgRenderer_Wrapper* wrapper = qobject_cast<QSvgRenderer_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QSvgRenderer_Wrapper* wrapper = dynamic_cast<QSvgRenderer_Wrapper*>(obj);
          //QSvgRenderer_Wrapper* wrapper = (QSvgRenderer_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QSvgRenderer: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QSvgRenderer*)wrapper->getWrappedVoid();
          //return getWrapped_QSvgRenderer(wrapper);
          return QSvgRenderer_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QSvgRenderer_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QSvgRenderer: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QSvgRenderer_Type);
          //return fun.call().toInt()==RJSType::QSvgRenderer_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QSvgRenderer::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTabBar(RJSApi& handler, QTabBar* v) {
          QTabBar_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTabBar_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTabBar: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTabBar_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTabBar_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTabBar('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTabBar");
          if (cl.isUndefined()) {
              qWarning() << "Class QTabBar is undefined. Use QTabBar_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTabBar('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTabBar(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTabBar(RJSApi& handler, const QTabBar* v) {
          return RJSHelper::cpp2js_QTabBar(handler, const_cast<QTabBar*>(v));
      }

      QTabBar* RJSHelper::js2cpp_QTabBar_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTabBar: not a QObject";
              return nullptr;
          }
          //QTabBar_Wrapper* wrapper = getWrapper<QTabBar_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTabBar_Wrapper* wrapper = qobject_cast<QTabBar_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTabBar_Wrapper* wrapper = dynamic_cast<QTabBar_Wrapper*>(obj);
          //QTabBar_Wrapper* wrapper = (QTabBar_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTabBar: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTabBar*)wrapper->getWrappedVoid();
          //return getWrapped_QTabBar(wrapper);
          return QTabBar_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTabBar_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTabBar: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTabBar_Type);
          //return fun.call().toInt()==RJSType::QTabBar_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTabBar::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTabWidget(RJSApi& handler, QTabWidget* v) {
          QTabWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTabWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTabWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTabWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTabWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTabWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTabWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class QTabWidget is undefined. Use QTabWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTabWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTabWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTabWidget(RJSApi& handler, const QTabWidget* v) {
          return RJSHelper::cpp2js_QTabWidget(handler, const_cast<QTabWidget*>(v));
      }

      QTabWidget* RJSHelper::js2cpp_QTabWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTabWidget: not a QObject";
              return nullptr;
          }
          //QTabWidget_Wrapper* wrapper = getWrapper<QTabWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTabWidget_Wrapper* wrapper = qobject_cast<QTabWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTabWidget_Wrapper* wrapper = dynamic_cast<QTabWidget_Wrapper*>(obj);
          //QTabWidget_Wrapper* wrapper = (QTabWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTabWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTabWidget*)wrapper->getWrappedVoid();
          //return getWrapped_QTabWidget(wrapper);
          return QTabWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTabWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTabWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTabWidget_Type);
          //return fun.call().toInt()==RJSType::QTabWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTabWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTableView(RJSApi& handler, QTableView* v) {
          
            // downcast to QTableWidget:
            {
                QTableWidget* o = qobject_cast<QTableWidget*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QTableWidget(handler, o);
                }
            }
          QTableView_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTableView_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTableView: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTableView_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTableView_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTableView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTableView");
          if (cl.isUndefined()) {
              qWarning() << "Class QTableView is undefined. Use QTableView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTableView('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTableView(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTableView(RJSApi& handler, const QTableView* v) {
          return RJSHelper::cpp2js_QTableView(handler, const_cast<QTableView*>(v));
      }

      QTableView* RJSHelper::js2cpp_QTableView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTableView: not a QObject";
              return nullptr;
          }
          //QTableView_Wrapper* wrapper = getWrapper<QTableView_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTableView_Wrapper* wrapper = qobject_cast<QTableView_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTableView_Wrapper* wrapper = dynamic_cast<QTableView_Wrapper*>(obj);
          //QTableView_Wrapper* wrapper = (QTableView_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTableView: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTableView*)wrapper->getWrappedVoid();
          //return getWrapped_QTableView(wrapper);
          return QTableView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTableView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTableView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTableView_Type);
          //return fun.call().toInt()==RJSType::QTableView_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTableView::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTableWidget(RJSApi& handler, QTableWidget* v) {
          QTableWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTableWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTableWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTableWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTableWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTableWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTableWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class QTableWidget is undefined. Use QTableWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTableWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTableWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTableWidget(RJSApi& handler, const QTableWidget* v) {
          return RJSHelper::cpp2js_QTableWidget(handler, const_cast<QTableWidget*>(v));
      }

      QTableWidget* RJSHelper::js2cpp_QTableWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTableWidget: not a QObject";
              return nullptr;
          }
          //QTableWidget_Wrapper* wrapper = getWrapper<QTableWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTableWidget_Wrapper* wrapper = qobject_cast<QTableWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTableWidget_Wrapper* wrapper = dynamic_cast<QTableWidget_Wrapper*>(obj);
          //QTableWidget_Wrapper* wrapper = (QTableWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTableWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTableWidget*)wrapper->getWrappedVoid();
          //return getWrapped_QTableWidget(wrapper);
          return QTableWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTableWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTableWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTableWidget_Type);
          //return fun.call().toInt()==RJSType::QTableWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTableWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTextBrowser(RJSApi& handler, QTextBrowser* v) {
          
            // downcast to types derrived from QTextBrowser but defined in other modules:
            for (int i=0; i<downcasters_QTextBrowser.length(); i++) {
                QJSValue dc = downcasters_QTextBrowser[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QTextBrowser_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTextBrowser_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTextBrowser: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTextBrowser_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTextBrowser_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTextBrowser('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextBrowser");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextBrowser is undefined. Use QTextBrowser_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextBrowser('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextBrowser(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextBrowser(RJSApi& handler, const QTextBrowser* v) {
          return RJSHelper::cpp2js_QTextBrowser(handler, const_cast<QTextBrowser*>(v));
      }

      QTextBrowser* RJSHelper::js2cpp_QTextBrowser_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextBrowser: not a QObject";
              return nullptr;
          }
          //QTextBrowser_Wrapper* wrapper = getWrapper<QTextBrowser_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTextBrowser_Wrapper* wrapper = qobject_cast<QTextBrowser_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTextBrowser_Wrapper* wrapper = dynamic_cast<QTextBrowser_Wrapper*>(obj);
          //QTextBrowser_Wrapper* wrapper = (QTextBrowser_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextBrowser: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTextBrowser*)wrapper->getWrappedVoid();
          //return getWrapped_QTextBrowser(wrapper);
          return QTextBrowser_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTextBrowser_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextBrowser: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTextBrowser_Type);
          //return fun.call().toInt()==RJSType::QTextBrowser_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextBrowser::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTextDocument(RJSApi& handler, QTextDocument* v) {
          QTextDocument_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTextDocument_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTextDocument: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTextDocument_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTextDocument_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTextDocument('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextDocument");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextDocument is undefined. Use QTextDocument_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextDocument('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextDocument(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextDocument(RJSApi& handler, const QTextDocument* v) {
          return RJSHelper::cpp2js_QTextDocument(handler, const_cast<QTextDocument*>(v));
      }

      QTextDocument* RJSHelper::js2cpp_QTextDocument_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextDocument: not a QObject";
              return nullptr;
          }
          //QTextDocument_Wrapper* wrapper = getWrapper<QTextDocument_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTextDocument_Wrapper* wrapper = qobject_cast<QTextDocument_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTextDocument_Wrapper* wrapper = dynamic_cast<QTextDocument_Wrapper*>(obj);
          //QTextDocument_Wrapper* wrapper = (QTextDocument_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextDocument: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTextDocument*)wrapper->getWrappedVoid();
          //return getWrapped_QTextDocument(wrapper);
          return QTextDocument_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTextDocument_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextDocument: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTextDocument_Type);
          //return fun.call().toInt()==RJSType::QTextDocument_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextDocument::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTextEdit(RJSApi& handler, QTextEdit* v) {
          
            // downcast to QTextBrowser:
            {
                QTextBrowser* o = qobject_cast<QTextBrowser*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QTextBrowser(handler, o);
                }
            }
          QTextEdit_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTextEdit_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTextEdit: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTextEdit_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTextEdit_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTextEdit('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTextEdit");
          if (cl.isUndefined()) {
              qWarning() << "Class QTextEdit is undefined. Use QTextEdit_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTextEdit('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTextEdit(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTextEdit(RJSApi& handler, const QTextEdit* v) {
          return RJSHelper::cpp2js_QTextEdit(handler, const_cast<QTextEdit*>(v));
      }

      QTextEdit* RJSHelper::js2cpp_QTextEdit_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTextEdit: not a QObject";
              return nullptr;
          }
          //QTextEdit_Wrapper* wrapper = getWrapper<QTextEdit_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTextEdit_Wrapper* wrapper = qobject_cast<QTextEdit_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTextEdit_Wrapper* wrapper = dynamic_cast<QTextEdit_Wrapper*>(obj);
          //QTextEdit_Wrapper* wrapper = (QTextEdit_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTextEdit: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTextEdit*)wrapper->getWrappedVoid();
          //return getWrapped_QTextEdit(wrapper);
          return QTextEdit_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTextEdit_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTextEdit: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTextEdit_Type);
          //return fun.call().toInt()==RJSType::QTextEdit_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTextEdit::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTimer(RJSApi& handler, QTimer* v) {
          QTimer_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTimer_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTimer: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTimer_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTimer_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTimer('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTimer");
          if (cl.isUndefined()) {
              qWarning() << "Class QTimer is undefined. Use QTimer_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTimer('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTimer(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTimer(RJSApi& handler, const QTimer* v) {
          return RJSHelper::cpp2js_QTimer(handler, const_cast<QTimer*>(v));
      }

      QTimer* RJSHelper::js2cpp_QTimer_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTimer: not a QObject";
              return nullptr;
          }
          //QTimer_Wrapper* wrapper = getWrapper<QTimer_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTimer_Wrapper* wrapper = qobject_cast<QTimer_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTimer_Wrapper* wrapper = dynamic_cast<QTimer_Wrapper*>(obj);
          //QTimer_Wrapper* wrapper = (QTimer_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTimer: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTimer*)wrapper->getWrappedVoid();
          //return getWrapped_QTimer(wrapper);
          return QTimer_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTimer_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTimer: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTimer_Type);
          //return fun.call().toInt()==RJSType::QTimer_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTimer::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QToolBar(RJSApi& handler, QToolBar* v) {
          
            // downcast to types derrived from QToolBar but defined in other modules:
            for (int i=0; i<downcasters_QToolBar.length(); i++) {
                QJSValue dc = downcasters_QToolBar[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QToolBar_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QToolBar_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QToolBar: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QToolBar_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QToolBar_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QToolBar('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QToolBar");
          if (cl.isUndefined()) {
              qWarning() << "Class QToolBar is undefined. Use QToolBar_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QToolBar('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QToolBar(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QToolBar(RJSApi& handler, const QToolBar* v) {
          return RJSHelper::cpp2js_QToolBar(handler, const_cast<QToolBar*>(v));
      }

      QToolBar* RJSHelper::js2cpp_QToolBar_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QToolBar: not a QObject";
              return nullptr;
          }
          //QToolBar_Wrapper* wrapper = getWrapper<QToolBar_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QToolBar_Wrapper* wrapper = qobject_cast<QToolBar_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QToolBar_Wrapper* wrapper = dynamic_cast<QToolBar_Wrapper*>(obj);
          //QToolBar_Wrapper* wrapper = (QToolBar_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QToolBar: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QToolBar*)wrapper->getWrappedVoid();
          //return getWrapped_QToolBar(wrapper);
          return QToolBar_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QToolBar_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QToolBar: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QToolBar_Type);
          //return fun.call().toInt()==RJSType::QToolBar_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QToolBar::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QToolButton(RJSApi& handler, QToolButton* v) {
          
            // downcast to types derrived from QToolButton but defined in other modules:
            for (int i=0; i<downcasters_QToolButton.length(); i++) {
                QJSValue dc = downcasters_QToolButton[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QToolButton_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QToolButton_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QToolButton: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QToolButton_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QToolButton_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QToolButton('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QToolButton");
          if (cl.isUndefined()) {
              qWarning() << "Class QToolButton is undefined. Use QToolButton_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QToolButton('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QToolButton(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QToolButton(RJSApi& handler, const QToolButton* v) {
          return RJSHelper::cpp2js_QToolButton(handler, const_cast<QToolButton*>(v));
      }

      QToolButton* RJSHelper::js2cpp_QToolButton_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QToolButton: not a QObject";
              return nullptr;
          }
          //QToolButton_Wrapper* wrapper = getWrapper<QToolButton_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QToolButton_Wrapper* wrapper = qobject_cast<QToolButton_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QToolButton_Wrapper* wrapper = dynamic_cast<QToolButton_Wrapper*>(obj);
          //QToolButton_Wrapper* wrapper = (QToolButton_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QToolButton: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QToolButton*)wrapper->getWrappedVoid();
          //return getWrapped_QToolButton(wrapper);
          return QToolButton_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QToolButton_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QToolButton: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QToolButton_Type);
          //return fun.call().toInt()==RJSType::QToolButton_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QToolButton::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTranslator(RJSApi& handler, QTranslator* v) {
          QTranslator_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTranslator_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTranslator: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTranslator_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTranslator_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTranslator('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTranslator");
          if (cl.isUndefined()) {
              qWarning() << "Class QTranslator is undefined. Use QTranslator_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTranslator('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTranslator(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTranslator(RJSApi& handler, const QTranslator* v) {
          return RJSHelper::cpp2js_QTranslator(handler, const_cast<QTranslator*>(v));
      }

      QTranslator* RJSHelper::js2cpp_QTranslator_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTranslator: not a QObject";
              return nullptr;
          }
          //QTranslator_Wrapper* wrapper = getWrapper<QTranslator_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTranslator_Wrapper* wrapper = qobject_cast<QTranslator_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTranslator_Wrapper* wrapper = dynamic_cast<QTranslator_Wrapper*>(obj);
          //QTranslator_Wrapper* wrapper = (QTranslator_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTranslator: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTranslator*)wrapper->getWrappedVoid();
          //return getWrapped_QTranslator(wrapper);
          return QTranslator_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTranslator_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTranslator: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTranslator_Type);
          //return fun.call().toInt()==RJSType::QTranslator_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTranslator::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTreeView(RJSApi& handler, QTreeView* v) {
          
            // downcast to QTreeWidget:
            {
                QTreeWidget* o = qobject_cast<QTreeWidget*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QTreeWidget(handler, o);
                }
            }
          QTreeView_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTreeView_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTreeView: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTreeView_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTreeView_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTreeView('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTreeView");
          if (cl.isUndefined()) {
              qWarning() << "Class QTreeView is undefined. Use QTreeView_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTreeView('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTreeView(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTreeView(RJSApi& handler, const QTreeView* v) {
          return RJSHelper::cpp2js_QTreeView(handler, const_cast<QTreeView*>(v));
      }

      QTreeView* RJSHelper::js2cpp_QTreeView_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTreeView: not a QObject";
              return nullptr;
          }
          //QTreeView_Wrapper* wrapper = getWrapper<QTreeView_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTreeView_Wrapper* wrapper = qobject_cast<QTreeView_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTreeView_Wrapper* wrapper = dynamic_cast<QTreeView_Wrapper*>(obj);
          //QTreeView_Wrapper* wrapper = (QTreeView_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTreeView: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTreeView*)wrapper->getWrappedVoid();
          //return getWrapped_QTreeView(wrapper);
          return QTreeView_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTreeView_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTreeView: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTreeView_Type);
          //return fun.call().toInt()==RJSType::QTreeView_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTreeView::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QTreeWidget(RJSApi& handler, QTreeWidget* v) {
          
            // downcast to types derrived from QTreeWidget but defined in other modules:
            for (int i=0; i<downcasters_QTreeWidget.length(); i++) {
                QJSValue dc = downcasters_QTreeWidget[i]->downcast(handler, v);
                if (!dc.isUndefined()) {
                    return dc;
                }
            }
          QTreeWidget_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QTreeWidget_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QTreeWidget: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QTreeWidget_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QTreeWidget_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QTreeWidget('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QTreeWidget");
          if (cl.isUndefined()) {
              qWarning() << "Class QTreeWidget is undefined. Use QTreeWidget_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QTreeWidget('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QTreeWidget(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QTreeWidget(RJSApi& handler, const QTreeWidget* v) {
          return RJSHelper::cpp2js_QTreeWidget(handler, const_cast<QTreeWidget*>(v));
      }

      QTreeWidget* RJSHelper::js2cpp_QTreeWidget_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QTreeWidget: not a QObject";
              return nullptr;
          }
          //QTreeWidget_Wrapper* wrapper = getWrapper<QTreeWidget_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QTreeWidget_Wrapper* wrapper = qobject_cast<QTreeWidget_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QTreeWidget_Wrapper* wrapper = dynamic_cast<QTreeWidget_Wrapper*>(obj);
          //QTreeWidget_Wrapper* wrapper = (QTreeWidget_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QTreeWidget: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QTreeWidget*)wrapper->getWrappedVoid();
          //return getWrapped_QTreeWidget(wrapper);
          return QTreeWidget_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QTreeWidget_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QTreeWidget: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QTreeWidget_Type);
          //return fun.call().toInt()==RJSType::QTreeWidget_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QTreeWidget::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QVBoxLayout(RJSApi& handler, QVBoxLayout* v) {
          QVBoxLayout_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QVBoxLayout_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QVBoxLayout: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QVBoxLayout_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QVBoxLayout_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QVBoxLayout('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QVBoxLayout");
          if (cl.isUndefined()) {
              qWarning() << "Class QVBoxLayout is undefined. Use QVBoxLayout_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QVBoxLayout('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QVBoxLayout(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QVBoxLayout(RJSApi& handler, const QVBoxLayout* v) {
          return RJSHelper::cpp2js_QVBoxLayout(handler, const_cast<QVBoxLayout*>(v));
      }

      QVBoxLayout* RJSHelper::js2cpp_QVBoxLayout_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QVBoxLayout: not a QObject";
              return nullptr;
          }
          //QVBoxLayout_Wrapper* wrapper = getWrapper<QVBoxLayout_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QVBoxLayout_Wrapper* wrapper = qobject_cast<QVBoxLayout_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QVBoxLayout_Wrapper* wrapper = dynamic_cast<QVBoxLayout_Wrapper*>(obj);
          //QVBoxLayout_Wrapper* wrapper = (QVBoxLayout_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QVBoxLayout: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QVBoxLayout*)wrapper->getWrappedVoid();
          //return getWrapped_QVBoxLayout(wrapper);
          return QVBoxLayout_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QVBoxLayout_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QVBoxLayout: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QVBoxLayout_Type);
          //return fun.call().toInt()==RJSType::QVBoxLayout_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QVBoxLayout::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QValidator(RJSApi& handler, QValidator* v) {
          
            // downcast to QIntValidator:
            {
                QIntValidator* o = qobject_cast<QIntValidator*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QIntValidator(handler, o);
                }
            }
          
            // downcast to QDoubleValidator:
            {
                QDoubleValidator* o = qobject_cast<QDoubleValidator*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QDoubleValidator(handler, o);
                }
            }
          
            // downcast to QRegularExpressionValidator:
            {
                QRegularExpressionValidator* o = qobject_cast<QRegularExpressionValidator*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QRegularExpressionValidator(handler, o);
                }
            }
          QValidator_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QValidator_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QValidator: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QValidator_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QValidator_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QValidator('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QValidator");
          if (cl.isUndefined()) {
              qWarning() << "Class QValidator is undefined. Use QValidator_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QValidator('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QValidator(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QValidator(RJSApi& handler, const QValidator* v) {
          return RJSHelper::cpp2js_QValidator(handler, const_cast<QValidator*>(v));
      }

      QValidator* RJSHelper::js2cpp_QValidator_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QValidator: not a QObject";
              return nullptr;
          }
          //QValidator_Wrapper* wrapper = getWrapper<QValidator_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QValidator_Wrapper* wrapper = qobject_cast<QValidator_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QValidator_Wrapper* wrapper = dynamic_cast<QValidator_Wrapper*>(obj);
          //QValidator_Wrapper* wrapper = (QValidator_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QValidator: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QValidator*)wrapper->getWrappedVoid();
          //return getWrapped_QValidator(wrapper);
          return QValidator_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QValidator_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QValidator: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QValidator_Type);
          //return fun.call().toInt()==RJSType::QValidator_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QValidator::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QWidgetAction(RJSApi& handler, QWidgetAction* v) {
          QWidgetAction_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QWidgetAction_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QWidgetAction: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QWidgetAction_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QWidgetAction_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QWidgetAction('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QWidgetAction");
          if (cl.isUndefined()) {
              qWarning() << "Class QWidgetAction is undefined. Use QWidgetAction_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QWidgetAction('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QWidgetAction(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QWidgetAction(RJSApi& handler, const QWidgetAction* v) {
          return RJSHelper::cpp2js_QWidgetAction(handler, const_cast<QWidgetAction*>(v));
      }

      QWidgetAction* RJSHelper::js2cpp_QWidgetAction_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QWidgetAction: not a QObject";
              return nullptr;
          }
          //QWidgetAction_Wrapper* wrapper = getWrapper<QWidgetAction_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QWidgetAction_Wrapper* wrapper = qobject_cast<QWidgetAction_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QWidgetAction_Wrapper* wrapper = dynamic_cast<QWidgetAction_Wrapper*>(obj);
          //QWidgetAction_Wrapper* wrapper = (QWidgetAction_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QWidgetAction: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QWidgetAction*)wrapper->getWrappedVoid();
          //return getWrapped_QWidgetAction(wrapper);
          return QWidgetAction_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QWidgetAction_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QWidgetAction: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QWidgetAction_Type);
          //return fun.call().toInt()==RJSType::QWidgetAction_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QWidgetAction::getIdStatic())).toBool();
      }

    
      QJSValue RJSHelper::cpp2js_QWindow(RJSApi& handler, QWindow* v) {
          
            // downcast to QQuickView:
            {
                QQuickView* o = qobject_cast<QQuickView*>(v);
                if (o!=nullptr) {
                    return RJSHelper::cpp2js_QQuickView(handler, o);
                }
            }
          QWindow_Wrapper* ret = nullptr;
          bool existing = false;
          if (v) {
              // look up existing wrapper:
              QVariant var = getWrapperProperty(handler, *v);
              //qDebug() << "existing wrapper QVariant:" << var;
              ret = var.value<QWindow_Wrapper*>();
              if (ret==nullptr) {
                  if (var.isValid()) {
                      qWarning() << "RJSHelper::cpp2js_QWindow: invalid wrapper attached to QObject: " << var.typeName();
                      QObject_Wrapper* ow = var.value<QObject_Wrapper*>();
                      delete ow;
                  }
                  // create new wrapper:
                  //qDebug() << "creating new wrapper for " << (long int)v;
                  ret = new QWindow_Wrapper(handler, v, false);
                  QVariant varNew = QVariant::fromValue(ret);
                  setWrapperProperty(handler, *v, varNew);
              }
              else {
                  existing = true;
              }
          }
          else {
              // wrapper for nullptr:
              ret = new QWindow_Wrapper(handler, nullptr, false);
          }

          QJSEngine* engine = handler.getEngine();

          // JS: new QWindow('__GOT_WRAPPER__', wrapper)
          QJSValue cl = engine->globalObject().property("QWindow");
          if (cl.isUndefined()) {
              qWarning() << "Class QWindow is undefined. Use QWindow_Wrapper::init().";
          }
          QJSValueList args;
          args.append(QJSValue("__GOT_WRAPPER__"));
          args.append(QJSValue(existing));
          args.append(engine->newQObject(ret));
          QJSValue r = cl.callAsConstructor(args);

          //engine->globalObject().setProperty("__wrapper__", engine->newQObject(ret));
          //QJSValue r = engine->evaluate("new QWindow('__GOT_WRAPPER__', __wrapper__);");

          if (r.isError()) {
              qWarning()
                      << "Uncaught exception in new QWindow(wrapper)"
                      << ":" << r.toString();
          }
          return r;
      }

      QJSValue RJSHelper::cpp2js_QWindow(RJSApi& handler, const QWindow* v) {
          return RJSHelper::cpp2js_QWindow(handler, const_cast<QWindow*>(v));
      }

      QWindow* RJSHelper::js2cpp_QWindow_ptr(RJSApi& handler, const QJSValue& v) {
          QJSValue jwrapper = getWrapperQJSValue(v);
          if (jwrapper.isNumber() && jwrapper.toInt()==0) {
              // 0 is allowed for pointers (null ptr):
              return nullptr;
          }
          if (!jwrapper.isQObject()) {
              //qWarning() << "js2cpp_QWindow: not a QObject";
              return nullptr;
          }
          //QWindow_Wrapper* wrapper = getWrapper<QWindow_Wrapper>(v);
          QObject* obj = jwrapper.toQObject();
          //QWindow_Wrapper* wrapper = qobject_cast<QWindow_Wrapper*>(obj);
          RJSWrapper* wrapper = dynamic_cast<RJSWrapper*>(obj);
          //QWindow_Wrapper* wrapper = dynamic_cast<QWindow_Wrapper*>(obj);
          //QWindow_Wrapper* wrapper = (QWindow_Wrapper*)obj;
          if (wrapper==nullptr) {
              qWarning() << "js2cpp_QWindow: no wrapper";
              handler.trace();
              return nullptr;
          }
          //return (QWindow*)wrapper->getWrappedVoid();
          //return getWrapped_QWindow(wrapper);
          return QWindow_Wrapper::getWrappedBase(wrapper);
          //return wrapper->getWrapped();
      }

      bool RJSHelper::is_QWindow_ptr(RJSApi& handler, const QJSValue& v, bool acceptUndefined) {
          if (v.isUndefined() || v.isNull()) {
              return acceptUndefined;
          }
          //QJSValue fun = v.property("getObjectType");
          QJSValue fun = v.property("isOfObjectType");
          if (fun.isUndefined() || !fun.isCallable()) {
              //qDebug() << "RJSHelper::is_QWindow: cannot get type of JS object";
              //engine->evaluate("console.trace()");
              //return v.isObject();
              // type is for example string, number, etc.:
              return false;
          }
          //return fun.call(RJSType::QWindow_Type);
          //return fun.call().toInt()==RJSType::QWindow_Type;
          //return v.isObject() || (v.isNumber() && v.toInt()==0);

          return fun.call(QJSValueList() << QJSValue(RJSType_QWindow::getIdStatic())).toBool();
      }

    